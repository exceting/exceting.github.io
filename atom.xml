<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>胖虎de文库</title>
  
  <subtitle>– – – – – _ _ – _ _ –</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-12-05T03:57:02.099Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>胖虎</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL知识整合（一）：InnoDB存储引擎</title>
    <link href="http://example.com/2021/07/03/MySQL%E7%9F%A5%E8%AF%86%E6%95%B4%E5%90%88%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AInnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <id>http://example.com/2021/07/03/MySQL%E7%9F%A5%E8%AF%86%E6%95%B4%E5%90%88%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AInnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</id>
    <published>2021-07-03T01:41:00.000Z</published>
    <updated>2023-12-05T03:57:02.099Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、服务端的请求处理"><a href="#一、服务端的请求处理" class="headerlink" title="一、服务端的请求处理"></a>一、服务端的请求处理</h2><p>当一条sql由MySQL客户端发往MySQL服务端时，它所经历的流程如下：</p><p><img src="http://myblog.sharemer.com/2021/07/03/20210703-1-1.png?imageView2/0/w/650" alt="图1"></p><p>最终数据的读取和写入是由存储引擎负责的，下面来看下MySQL默认的存储引擎InnoDB的存储结构。</p><span id="more"></span><h2 id="二、InnoDB存储结构"><a href="#二、InnoDB存储结构" class="headerlink" title="二、InnoDB存储结构"></a>二、InnoDB存储结构</h2><h3 id="2-1：页"><a href="#2-1：页" class="headerlink" title="2.1：页"></a>2.1：页</h3><p>InnoDB的存储单元是<code>页</code>，一页的大小一般是<code>16KB</code>，可以通过系统变量<code>innodb_page_size</code>控制，它的默认值是16384（字节），也就是16KB。我们获取数据时，InnoDB也是以页为单位进行传输的，页的详细介绍放到了下面第三节。</p><h3 id="2-2：行-行结构"><a href="#2-2：行-行结构" class="headerlink" title="2.2：行&amp;行结构"></a>2.2：行&amp;行结构</h3><p>平时我们向表中插入一行数据，这一行数据是需要存放在磁盘上的，常见的存储格式有<code>COMPACT</code>、<code>REDUNDANT</code>、<code>DYNAMIC</code>、<code>COMPRESSED</code>，下面是设置语句：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CREATE</span> TABLE <span class="variable">$&#123;表名&#125;</span> <span class="variable">$&#123;列名&#125;</span> ROW_FORMAT = <span class="variable">$&#123;行格式名称&#125;</span></span><br><span class="line"><span class="attribute">ALTER</span> TABLE <span class="variable">$&#123;表名&#125;</span> ROW_FORMAT = <span class="variable">$&#123;行格式名称&#125;</span></span><br></pre></td></tr></table></figure><p>这些格式在原理上大体相同，下面主要以<code>COMPACT</code>为切入点进行介绍。COMPACT行格式如下：</p><p><img src="http://myblog.sharemer.com/2021/07/03/20210703-1-2.png?imageView2/0/w/1050" alt="图2"></p><h3 id="2-3：存储-数据溢出"><a href="#2-3：存储-数据溢出" class="headerlink" title="2.3：存储&amp;数据溢出"></a>2.3：存储&amp;数据溢出</h3><p>页是以16kb为单位存储的，但我们的数据又是以行为单位插入的（行记录），页容量固定，但行记录的大小不可控，因此就导致了各种数据溢出问题。</p><h4 id="2-3-1：列溢出"><a href="#2-3-1：列溢出" class="headerlink" title="2.3.1：列溢出"></a>2.3.1：列溢出</h4><p>首先是单列溢出，如果有的列数据特别大，大到一页都放不下，那这一列就溢出了，COMPACT的做法是当前页只记录该列的少量数据，剩余的数据则分散的存到其他页中，然后在当前页花20字节记录下这些页的地址：</p><p><img src="http://myblog.sharemer.com/2021/07/03/20210703-1-3.png?imageView2/0/w/680" alt="图3"></p><p>这里再说下<code>DYNAMIC</code>和<code>COMPRESSED</code>这两种行格式，它们跟COMPACT基本一致，只是在处理列溢出时的策略不太一样，DYNAMIC和COMPRESSED遇到超大列时并不会在当前页保存该列的少量数据，而是直接将真实数据分配到其他页中，当前页只记录其他页的地址，相比DYNAMIC，COMPRESSED还会压缩页数据，用来节省空间。</p><h4 id="2-3-2：页溢出"><a href="#2-3-2：页溢出" class="headerlink" title="2.3.2：页溢出"></a>2.3.2：页溢出</h4><p>再来看下页溢出，如何判定页是否溢出了呢？</p><p>页溢出临界判定：mysql规定正常情况下一页至少存储两行记录，假如我们行记录所需的真实数据存储上限为N，那么一页的数据构成就会是下面这样：</p><p><img src="http://myblog.sharemer.com/2021/07/03/20210703-1-4.png?imageView2/0/w/950" alt="图4"></p><p>只有行记录所需空间满足上面这个式子（N &lt; 8099)，页才不会溢出，否则就会溢出，而对于溢出页，就不会再要求至少存储两行记录了，因而可以进一步做数据拆分来解决掉页溢出问题。</p><h2 id="三、InnoDB页结构"><a href="#三、InnoDB页结构" class="headerlink" title="三、InnoDB页结构"></a>三、InnoDB页结构</h2><h3 id="3-1：基本结构"><a href="#3-1：基本结构" class="headerlink" title="3.1：基本结构"></a>3.1：基本结构</h3><p>前面已经简单介绍了页、行、以及行的结构，本节就来重点讲下页的结构（为了便于理解，这里将<code>图4</code>顺延了下来）：</p><p><img src="http://myblog.sharemer.com/2021/07/03/20210703-1-5.png?imageView2/0/w/950" alt="图5"></p><p>接下来详细的介绍下上图中的每一个部分。</p><h3 id="3-2：记录-Free-Space、User-Records、Infimum-Supremum"><a href="#3-2：记录-Free-Space、User-Records、Infimum-Supremum" class="headerlink" title="3.2：记录-Free Space、User Records、Infimum+Supremum"></a>3.2：记录-Free Space、User Records、Infimum+Supremum</h3><p>如图5，页由7部分数据组成，其中<code>User Records</code>是由<code>Free Space</code>转化而来，每当我们往页里插入一条记录，就会从Free Space申请一块内存作为User Records存放这条记录，Free Space用完，就可以申请新的页了：</p><p><img src="http://myblog.sharemer.com/2021/07/03/20210703-1-6.png?imageView2/0/w/850" alt="图6"></p><p>来个例子，page_demo表有三个属性，分别是c1(主键)、c2(int)、c3(varchar)，以COMPACT格式存储，这时王这张表里新增四条记录：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">INSERT</span> INTO page_demo VALUES(<span class="number">1</span>, <span class="number">100</span>, &#x27;aaa&#x27;), (<span class="number">2</span>, <span class="number">200</span>, &#x27;bbbb&#x27;), (<span class="number">3</span>, <span class="number">300</span>, &#x27;cccc&#x27;), (<span class="number">4</span>, <span class="number">400</span>, &#x27;dddd&#x27;);</span><br></pre></td></tr></table></figure><p>此时数据页的存储状态如下：</p><p><img src="http://myblog.sharemer.com/2021/07/03/20210703-1-7.png?imageView2/0/w/1050" alt="图7"></p><p>如果删除掉一条数据，那么这条数据的delete_flag会被标记为1，仅此而已，当插入新的数据时，会挤掉这条被删掉的老数据。</p><h3 id="3-2：页目录-Page-Directoy"><a href="#3-2：页目录-Page-Directoy" class="headerlink" title="3.2：页目录-Page Directoy"></a>3.2：页目录-Page Directoy</h3><p>当一张表中的记录值非常多时，要按照主键进行查询，为了保证查询效率，InnoDB又将上面的数据进行了分组，然后利用<code>Page Directory</code>保存了这些分组最后一条数据的地址偏移量，并以此来定位一个分组，详情如下：</p><p><img src="http://myblog.sharemer.com/2021/07/03/20210703-1-8.png?imageView2/0/w/1050" alt="图8"></p><p>有了这些，根据主键查询的效率就得到了提升，具体过程：通过<code>二分法</code>找到该分组对应的槽信息，然后通过邻槽的最后一条记录找到该槽对应组里主键值最小的记录，以这条记录开始，通过next_record一直往下遍历（单链表遍历），匹配要查的主键。二分查找法的时间复杂度为<code>O(logN)</code></p><h3 id="3-3：页头-Page-Header"><a href="#3-3：页头-Page-Header" class="headerlink" title="3.3：页头-Page Header"></a>3.3：页头-Page Header</h3><p>页头主要用来存储页的一些状态信息，这些信息如下：</p><table><thead><tr><th align="left">名称</th><th align="left">大小</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">PAGE_N_DIR_SLOTS</td><td align="left">2bytes</td><td align="left">页目录内的槽数量</td></tr><tr><td align="left">PAGE_HEAP_TOP</td><td align="left">2bytes</td><td align="left">还未使用的空间最小地址，该地址后就是Free Space</td></tr><tr><td align="left">PAGE_N_HEAP</td><td align="left">2bytes</td><td align="left">首bit标记本页是否为紧凑型，剩余15bit表示本页的总记录数（包含Infimum+Supremum、被删除数据）</td></tr><tr><td align="left">PAGE_N_RECS</td><td align="left">2bytes</td><td align="left">本页用户记录的数量（不包含Infimum+Supremum、被删除数据）</td></tr><tr><td align="left">PAGE_FREE</td><td align="left">2bytes</td><td align="left">被删记录同样会通过next_record组成一个“废弃链表”，这些记录空间可被重复利用，PAGE_FREE就是链表头对应记录在页中的偏移量</td></tr><tr><td align="left">PAGE_GARBAGE</td><td align="left">2bytes</td><td align="left">已删除记录所占字节数</td></tr><tr><td align="left">PAGE_LAST_INSERT</td><td align="left">2bytes</td><td align="left">最后插入记录的位置</td></tr><tr><td align="left">PAGE_DIRECTION</td><td align="left">2bytes</td><td align="left">记录插入的方向（新插入记录的主键值比上一条记录大，此时插入方向视为右插，否则是左插，即左小右大，PAGE_DIRECTION就用来记录最后插入数据的插入方向）</td></tr><tr><td align="left">PAGE_N_DIRECTION</td><td align="left">2bytes</td><td align="left">同一个方向连续多次插入记录时，会用该字段计数，如果后续插入方向发生变化，便会清零重计</td></tr><tr><td align="left">PAGE_MAX_TRX_ID</td><td align="left">8bytes</td><td align="left">修改本页的最大事务id，该值仅在二级索引页面中定义</td></tr><tr><td align="left">PAGE_LEVEL</td><td align="left">2bytes</td><td align="left">本页在B+树中所处的层级</td></tr><tr><td align="left">PAGE_INDEX_ID</td><td align="left">8bytes</td><td align="left">索引ID，表示本页属于哪个索引</td></tr><tr><td align="left">PAGE_BTR_SEG_LEAF</td><td align="left">10bytes</td><td align="left">B+树叶子节点段的头部信息，仅在B+树的跟页面中定义</td></tr><tr><td align="left">PAGE_BTR_SEG_TOP</td><td align="left">10bytes</td><td align="left">B+树非叶子节点段的头部信息，仅在B+树的跟页面中定义</td></tr></tbody></table><center>表1</center><h3 id="3-4：文件头-File-Header"><a href="#3-4：文件头-File-Header" class="headerlink" title="3.4：文件头-File Header"></a>3.4：文件头-File Header</h3><p>如果说Page Header是用来描述页内记录的状态，那么File Header则用来记录页本身的信息，这些信息如下：</p><table><thead><tr><th align="left">名称</th><th align="left">大小</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">FIL_PAGE_SPACE_OR_CHKSUM</td><td align="left">4bytes</td><td align="left">mysql版本 &lt; 4.0.14：表示本页所在的表空间ID；mysql版本 &gt;&#x3D; 4.0.14：表示本页的校验和</td></tr><tr><td align="left">FIL_PAGE_OFFSET</td><td align="left">4bytes</td><td align="left">页号（即页ID，InnoDB通过页号来确定一个页）；当要存放的数据本身很大，以至于出现了前面所说的溢出现象，这时就需要多个页存放这些数据了，聚合这些数据最简单的办法就是通过页号将它们串连成一个<code>双向链表</code>，下方的两个属性就是用来干这个的</td></tr><tr><td align="left">FIL_PAGE_PREV</td><td align="left">4bytes</td><td align="left">上一页的页号</td></tr><tr><td align="left">FIL_PAGE_NEXT</td><td align="left">4bytes</td><td align="left">下一页的页号</td></tr><tr><td align="left">FIL_PAGE_LSN</td><td align="left">8bytes</td><td align="left">本页被最后修改时对应的LSN值（日志序列号）</td></tr><tr><td align="left">FIL_PAGE_TYPE</td><td align="left">2bytes</td><td align="left">本页的类型，InnoDB为了不同的目的将页分成了好几种，具体的类型以及类型值详见<code>表3</code></td></tr><tr><td align="left">FIL_PAGE_FILE_FLUSH_LSN</td><td align="left">8bytes</td><td align="left">仅在系统表空间的第一个页中定义，代表文件至少被刷新到了对应的LSN值</td></tr><tr><td align="left">FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td><td align="left">4bytes</td><td align="left">本页所在的表空间ID</td></tr></tbody></table><center>表2</center><table><thead><tr><th align="left">页类型</th><th align="left">类型值</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">FIL_PAGE_TYPE_ALLOCATED</td><td align="left">0x0000</td><td align="left">新分配，还未使用</td></tr><tr><td align="left">FIL_PAGE_UNDO_LOG</td><td align="left">0x0002</td><td align="left">undo日志页</td></tr><tr><td align="left">FIL_PAGE_INODE</td><td align="left">0x0003</td><td align="left">存储段的信息</td></tr><tr><td align="left">FIL_PAGE_IBUF_FREE_LIST</td><td align="left">0x0004</td><td align="left">Change Buffer空闲链表</td></tr><tr><td align="left">FIL_PAGE_IBUF_BITMAP</td><td align="left">0x0005</td><td align="left">Change Buffer的一些属性</td></tr><tr><td align="left">FIL_PAGE_TYPE_SYS</td><td align="left">0x0006</td><td align="left">存储一些系统数据</td></tr><tr><td align="left">FIL_PAGE_TYPE_TRX_SYS</td><td align="left">0x0007</td><td align="left">事务系统数据</td></tr><tr><td align="left">FIL_PAGE_TYPE_FSP_HDR</td><td align="left">0x0008</td><td align="left">表空间头部信息</td></tr><tr><td align="left">FIL_PAGE_TYPE_XDES</td><td align="left">0x0009</td><td align="left">存储区的一些属性</td></tr><tr><td align="left">FIL_PAGE_TYPE_BLOB</td><td align="left">0x000A</td><td align="left">溢出页</td></tr><tr><td align="left">FIL_PAGE_INDEX</td><td align="left">0x45BF</td><td align="left">索引页（也就是存放我们业务数据的页，之前例子中的页就是这种）</td></tr></tbody></table><center>表3</center><h3 id="3-5：文件尾-File-Trailer"><a href="#3-5：文件尾-File-Trailer" class="headerlink" title="3.5：文件尾-File Trailer"></a>3.5：文件尾-File Trailer</h3><p>InnoDB存储引擎会把数据存放在磁盘上，但磁盘速度很慢，所以InnoDB会以页为单位将数据载入到内存中处理，处理后的数据会再刷入磁盘中，如果在刷入磁盘的过程中发生意外（比如断电、死机），势必会导致严重的后果，为了避免这种情况的发生，InnoDB追加了File Trailer，结合File Header一起来校验页的完整性，它由8字节组成，分为两个部分：</p><p><img src="http://myblog.sharemer.com/2021/07/03/20210703-1-9.png?imageView2/0/w/560" alt="图9"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、服务端的请求处理&quot;&gt;&lt;a href=&quot;#一、服务端的请求处理&quot; class=&quot;headerlink&quot; title=&quot;一、服务端的请求处理&quot;&gt;&lt;/a&gt;一、服务端的请求处理&lt;/h2&gt;&lt;p&gt;当一条sql由MySQL客户端发往MySQL服务端时，它所经历的流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://myblog.sharemer.com/2021/07/03/20210703-1-1.png?imageView2/0/w/650&quot; alt=&quot;图1&quot;&gt;&lt;/p&gt;
&lt;p&gt;最终数据的读取和写入是由存储引擎负责的，下面来看下MySQL默认的存储引擎InnoDB的存储结构。&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="mysql" scheme="http://example.com/tags/mysql/"/>
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Redis知识整合（四）：集群</title>
    <link href="http://example.com/2021/05/26/Redis%E7%9F%A5%E8%AF%86%E6%95%B4%E5%90%88%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E9%9B%86%E7%BE%A4/"/>
    <id>http://example.com/2021/05/26/Redis%E7%9F%A5%E8%AF%86%E6%95%B4%E5%90%88%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E9%9B%86%E7%BE%A4/</id>
    <published>2021-05-26T00:20:00.000Z</published>
    <updated>2023-12-03T10:42:00.293Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上回主要介绍了redis的主从模式，主从模式最主要的作用是提高redis的可用性，假如主节点挂了，从节点可以在<code>哨兵机制</code>的协助下晋升为主节点继续对外服务，但主从终归是多个redis节点都保存同一份数据，在redis数据快速膨胀时，又该如何应对呢？redis对于这种情况提供了Cluster模式，这是redis的分布式解决方案，使得大批量数据可以拆分成小部分保存进多个redis节点中，本篇笔记将展开说一下<code>Redis Cluster</code>.</p></blockquote><span id="more"></span><h3 id="一、分布式DB常用的分区方案"><a href="#一、分布式DB常用的分区方案" class="headerlink" title="一、分布式DB常用的分区方案"></a>一、分布式DB常用的分区方案</h3><p>分布式数据库在存储全量数据时，首先要解决的是如何把整个数据集按照分区规则映射到多个节点上：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-1.png?imageView2/0/w/560" alt="图1"></p><p>这里介绍几个常用分分区方案：</p><h4 id="1-1：取模"><a href="#1-1：取模" class="headerlink" title="1.1：取模"></a>1.1：取模</h4><p>这是最常用的方式，假如现在有N个存储节点，则计算方式为：p &#x3D; hash(key) % N，也就是取唯一标识（在本例中就是redis key）进行哈希计算后跟当前节点数取模，最终就可以得出这条数据会被分配到哪台机器上，这是这种方式的优缺点：</p><ul><li>优点：简单易用</li><li>缺点：扩缩容时可能导致全部节点失效（<code>rehash</code>），建议扩缩容时按照<code>原节点数 × 2</code>来进行，这样只要原来的哈希值不变，余数也就不会变</li></ul><h4 id="1-2：一致性哈希"><a href="#1-2：一致性哈希" class="headerlink" title="1.2：一致性哈希"></a>1.2：一致性哈希</h4><p>这种方式的实现思路是为每个节点分配一个token值，取值范围在0~2^32间，当给节点分配完token，这些节点就会形成一个闭环：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-2.png?imageView2/0/w/600" alt="图2"></p><p>当有新的数据到来时，跟前面一样先计算出唯一标识（key）的哈希值，然后拿着这个哈希值顺时针找到第一个大于等于该值的token（找不到比自身大的token就放进顺时针第一个节点中，所以才说这是个闭合的环嘛），将其存入该token对应的节点中：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-3.png?imageView2/0/w/650" alt="图3"></p><p>这样一来，增减节点时只会影响哈希环中相邻的节点，对其他节点无影响：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-5.png?imageView2/0/w/1100" alt="图4"></p><p>至于加减节点导致的一小部分数据不可用，需要手动处理，如果利用一致性哈希存缓存数据，那么也可以忽略这部分数据，等回源时再次写入正确的节点即可。</p><p>如果节点过少，则节点变化将大范围影响哈希环中的数据映射，而且数据会严重倾斜，所以一致性哈希不适合节点数较少时使用。</p><p>在使用一致性哈希时，节点扩缩容容易导致负载不均衡（如图4），尤其是删除一个节点时，被删节点的负载将全部打到下一个节点，如果下一个节点不堪重负挂掉，此时更大的压力将会顺延至下下一个节点，以此类推，最终可能导致服务全员故障，为了解决一致性哈希的这些问题，诞生了<code>虚拟节点</code>的概念，这是对一致性哈希算法的优化，算法的本质没有变化，但与之前不同的是现在数据不与实际的节点交互而是跟抽象出来的虚拟节点交互：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-7.png?imageView2/0/w/600" alt="图5"></p><p>图中简化了，实际上虚拟节点是逻辑层面的节点，数量会非常多。</p><p>加这一层虚拟节点做一致性哈希的代理层，然后再将虚拟节点映射到具体的机器上，只要这个映射逻辑足够散列，那么之前的问题将不复存在，比如现在我们去掉一个节点：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-9.png?imageView2/0/w/600" alt="图6"></p><p>可以看到，受被删节点影响的数据最终会被节点2和节点3的虚拟节点接收，这就是虚拟节点比原生一致性哈希优秀的地方，通过一层抽象，解决了一致性哈希的痛点。</p><h4 id="1-3：哈希槽"><a href="#1-3：哈希槽" class="headerlink" title="1.3：哈希槽"></a>1.3：哈希槽</h4><p>它结合了上述两种哈希算法的特点实现，首先它会抽象出来一大堆的哈希槽，这些哈希槽都有自己编号，每个物理节点负责存储一定范围内的哈希槽，存储数据时跟前两种哈希算法一样，先计算出唯一标识（key）的哈希值，然后看该值在哪个槽区间里，若命中区间，则存进负责该槽区间的节点：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-10.png?imageView2/0/w/600" alt="图7"></p><p>增减节点时需要重新分配每个节点负责的槽范围，将一些错位数据做迁移，这样可以保证每个节点仍然是均匀的负责一个哈希槽区间，也就自然不存在数据倾斜等问题，Redis Cluster正是采用哈希槽的方式实现数据分区的，它一共有16383个槽位，流程跟<code>图7</code>中描绘的一样，分区算法为：<code>CRC16(key) % 16383</code></p><h3 id="二、Redis集群搭建"><a href="#二、Redis集群搭建" class="headerlink" title="二、Redis集群搭建"></a>二、Redis集群搭建</h3><h4 id="2-1：集群配置-启动"><a href="#2-1：集群配置-启动" class="headerlink" title="2.1：集群配置&amp;启动"></a>2.1：集群配置&amp;启动</h4><p>redis集群一般需要至少6个节点（3主3从）才能保证组成完整的高可用集群，单节点的redis-6379.conf主要配置如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">port 6379 #端口号</span><br><span class="line">cluster-enabled yes #开启集群模式</span><br><span class="line">cluster-node-timeout 15000 #节点超时时间（单位：ms）</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">↓集群配置文件，若没有则自动创建，当集群内节点信息发生变化（如添加/下线节点、故障转移等），节点</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">会自动保存集群状态到该配置文件中（redis自动维护该文件，不需要手动修改）</span></span><br><span class="line">cluster-config-file &quot;node-6379.conf&quot;</span><br></pre></td></tr></table></figure><p>配置完成后将所有节点都启动起来，假设有这样6个节点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-server conf/redis-6379.conf</span><br><span class="line">redis-server conf/redis-6380.conf</span><br><span class="line">redis-server conf/redis-6381.conf</span><br><span class="line">redis-server conf/redis-6382.conf</span><br><span class="line">redis-server conf/redis-6383.conf</span><br><span class="line">redis-server conf/redis-6384.conf</span><br></pre></td></tr></table></figure><p>启动完成后，来随便看一个节点的集群配置文件，比如node-6379.conf：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5adabec665d2b4005adabec665d2b40adabec665 127.0.0.1:6379 myself,master - 0 0 0 connected vars currentEpoch 0 lastVoteEpoch 0</span><br></pre></td></tr></table></figure><p>这里面记录的是集群的初始状态，其中第一个40位的十六进制字符串表示的是节点ID，它是节点在集群中的唯一标识，很多集群操作都需要借助这个ID来完成（ID在初始化集群时生成，节点重启会重用）</p><h4 id="2-2：握手"><a href="#2-2：握手" class="headerlink" title="2.2：握手"></a>2.2：握手</h4><p>到上面的步骤为止，节点只是打开了集群模式，完成了启动，它们彼此并不知道彼此的节点信息，接下来这一步操作就可以让它们感知到身处同一个集群里的彼此，这个操作由客户端发起：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster meet $&#123;ip&#125; $&#123;port&#125;</span><br></pre></td></tr></table></figure><p>发送meet就可以让节点间进行握手通信，就像下面这样：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-11.png?imageView2/0/w/700" alt="图8"></p><p>当某个节点对着其他节点全部发一次meet消息后，集群中每个节点就会慢慢感知到其他的节点，最终在每一个节点内执行下面这个命令，都可以获取到所有的节点信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; cluster nodes</span><br><span class="line">5adabec665d2b4005adabec665d2b40adabec665 127.0.0.1:6379 myself,master - 0 0 0 connected</span><br><span class="line">8ebabevc789d2b6125becbec123d2f45adabecec 127.0.0.1:6380 master - 0 146345454 1 connected</span><br><span class="line">fdadadacddd2b4666adabec125d2aaaadabecdec 127.0.0.1:6381 master - 0 146345454 2 connected</span><br><span class="line">dddddddcddd5bbbbbadabec567d2bb0adabecfed 127.0.0.1:6382 master - 0 146345454 3 connected</span><br><span class="line">fadabec567d6bddddadabec690d2b40adabecede 127.0.0.1:6383 master - 0 146345454 4 connected</span><br><span class="line">dadacecef8d1b4a85adabece76d2b40adabecded 127.0.0.1:6384 master - 0 146345454 5 connected</span><br></pre></td></tr></table></figure><p>至于meet的过程，我们放到后面详细说。</p><p>节点建立握手后，集群还无法工作，整体处于下线状态，所有数据的读写都会被禁止，这是因为还没给主节点分配槽位，没有槽位连插入的数据放到哪个节点都不知道。</p><h4 id="2-3：分配哈希槽"><a href="#2-3：分配哈希槽" class="headerlink" title="2.3：分配哈希槽"></a>2.3：分配哈希槽</h4><p>redis是通过哈希槽进行数据分区的，这在之前已经提过了，分配槽位用到的指令是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster addslots &#123;x...y&#125; #xy就是当前节点负责的槽范围</span><br></pre></td></tr></table></figure><p>我们设6379&#x2F;6380&#x2F;6381三个节点为主节点，将16384个槽均匀分配给这三个节点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379 cluster addslots &#123;0...5461&#125;</span><br><span class="line">redis-cli -h 127.0.0.1 -p 6380 cluster addslots &#123;5462...10922&#125;</span><br><span class="line">redis-cli -h 127.0.0.1 -p 6381 cluster addslots &#123;19023...16383&#125;</span><br></pre></td></tr></table></figure><p>在每个分配好槽位的主节点执行<code>cluster info</code>可以查看具体的集群状态信息，使用<code>cluster nodes</code>则可以查看整个集群的情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; cluster nodes</span><br><span class="line">5adabec665d2b4005adabec665d2b40adabec665 127.0.0.1:6379 myself,master - 0 0 0 connected 0-5461</span><br><span class="line">8ebabevc789d2b6125becbec123d2f45adabecec 127.0.0.1:6380 master - 0 146345454 1 connected 5462-10922</span><br><span class="line">fdadadacddd2b4666adabec125d2aaaadabecdec 127.0.0.1:6381 master - 0 146345454 2 connected 10923-16383</span><br><span class="line">dddddddcddd5bbbbbadabec567d2bb0adabecfed 127.0.0.1:6382 master - 0 146345454 3 connected</span><br><span class="line">fadabec567d6bddddadabec690d2b40adabecede 127.0.0.1:6383 master - 0 146345454 4 connected</span><br><span class="line">dadacecef8d1b4a85adabece76d2b40adabecded 127.0.0.1:6384 master - 0 146345454 5 connected</span><br></pre></td></tr></table></figure><p>相比之前，三个主节点已经输出了自己负责的槽位信息。</p><h4 id="2-4：配置主从"><a href="#2-4：配置主从" class="headerlink" title="2.4：配置主从"></a>2.4：配置主从</h4><p>上述集群中还有3个节点没有利用到，这3个节点就是我们要设置的从节点，在集群模式下建立主从关系有些不太一样，用的是这个指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster replicate $&#123;master-node-id&#125;</span><br></pre></td></tr></table></figure><p>在集群中，从节点负责复制主节点的槽信息和数据。虽然指令不同，但复制的流程则和原来讲的普通主从模式一致，最终我们这个集群的完整拓补图将会是下面这样：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-12.png?imageView2/0/w/600" alt="图9"></p><p>此时如果再执行<code>cluster nodes</code>命令，主从信息也会被打印出来（这里不再演示）。</p><h4 id="2-5：redis-trib-rb"><a href="#2-5：redis-trib-rb" class="headerlink" title="2.5：redis-trib.rb"></a>2.5：redis-trib.rb</h4><p>如果你觉得上面的流程太过复杂，没关系，redis提供了官方的快速搭建集群的工具：redis-trib.rb，它采用ruby实现，可以帮我们简化集群创建、检查、迁移槽、均衡等常见运维操作。</p><p>使用前需要先装ruby：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wget https://cache.ruby-lang.org/pub/ruby/$&#123;big_ver&#125;/ruby-$&#123;ver&#125;.tar.gz #下载压缩包，big_ver为大版本号，如2.3，ver为具体版本号，如2.3.1</span><br><span class="line">tar xvf ruby-yy.tar.gz #解压</span><br><span class="line">./configure -prefix=/usr/local/ruby</span><br><span class="line">make #编译</span><br><span class="line">make install</span><br><span class="line">cd /usr/local/ruby</span><br><span class="line">sudo cp bin/ruby /usr/local/bin</span><br><span class="line">sudo cp bin/gem /usr/local/bin</span><br></pre></td></tr></table></figure><p>安装rubygem redis依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http://rubygems.org/downloads/redis-$&#123;ver&#125;.gem #下载redis.gem，ver是具体的版本号，如3.3.0</span><br><span class="line">gem install -l redis-$&#123;ver&#125;.gem</span><br><span class="line">gem list --check redis gem</span><br></pre></td></tr></table></figure><p>安装redis-trib.rb：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /$&#123;redis_home&#125;/src/redis-trib.rb /usr/local/bin</span><br></pre></td></tr></table></figure><p>安装完ruby环境后，执行redis-trib.rb命令确认环境是否正确即可，若准确则打印相关信息。</p><p>然后开始创建集群：</p><p>①首先准备好6个开启集群模式节点，过程跟之前一样，不再赘述。</p><p>②执行redis-trib.rb创建集群：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-trib.rb create --replicas 1 127.0.0.1:6379 127.0.0.1:6380 127.0.0.1:6381 127.0.0.1:6382 127.0.0.1:6383 127.0.0.1:6384</span><br></pre></td></tr></table></figure><p><code>--replicas</code>可以指定每个主节点配置几个从节点，这里设置的是1，如果是多台机器部署，redis-trib.rb会尽可能保证主从不在同一个机器里（不然会弱化高可用）</p><p>上面的指令执行后，会将当前的主从分配信息打印出来，然后征求你的同意，你只要输入了<code>yes</code>，redis-trib.rb就会紧接着进行节点握手和槽分配；相比原生搭建集群，redis-trib.rb的确可以帮我们省去很多麻烦。</p><h3 id="三、节点通信"><a href="#三、节点通信" class="headerlink" title="三、节点通信"></a>三、节点通信</h3><h4 id="3-1：Gossip"><a href="#3-1：Gossip" class="headerlink" title="3.1：Gossip"></a>3.1：Gossip</h4><p>如<code>图8</code>所示，为什么某个节点对着其他节点全部发一次meet消息后，每个节点就会慢慢感知到其他的节点呢？这是因为redis利用<code>Gossip</code>协议（一种分布式一致性协议，为最终一致）做信息同步，Gossip的工作原理就是节点间彼此不断的通信进行信息交换，这样持续一段时间后，所有的节点就都知道了集群的完整信息（这种方式很像流言的传播，所以Gossip协议也叫流言协议），过程如下：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-13-fix2.png?imageView2/0/w/1400" alt="图10"></p><p>注意图中的流程是按照6379的meet消息同时发到各节点，各节点又同时发pong给6379的，但实际操作中这肯定不是同时发生的，但这并不影响节点的传播。</p><p>上面所涉及到的<code>meet</code>、<code>ping</code>、<code>pong</code>消息均为Redis Gossip消息，除了这些还有<code>fail</code>消息，当任意节点发现某一个节点挂掉后，会向集群内广播一个fail消息，其他节点接收到这条fail消息后会把对应的坏节点更新为下线状态（后面会详细介绍<code>故障转移</code>）。</p><h4 id="3-2：定时消息"><a href="#3-2：定时消息" class="headerlink" title="3.2：定时消息"></a>3.2：定时消息</h4><p>上面的流程图告诉我们集群内的每个节点都会定时对其他节点通信进行信息交换，频率是10次&#x2F;秒，高频是为了让信息扩散的更快，可是这样就会导致另一个问题：每次请求都携带很多信息（比如自身和其他节点的状态信息等），这样势必会造成网络带宽的浪费；为了解决这一问题，节点间每次只选取部分节点进行通信，选取逻辑主要源自两部分，这里以6379这个节点（定时发ping消息）为例：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-14.png?imageView2/0/w/850" alt="图11"></p><p>根据这两个选取规则可以估算出每个节点每秒需要发送的消息数为：<code>1 + 10 * num(node.pong_last_time &gt; cluster_node_timeout/2)</code>，其中<code>cluster_node_timeout</code>可配，默认15s，当我们的带宽资源紧张时可以适当调大该值来降低贷款占用率，当然扩大该值意味着故障转移、槽信息更新、新节点发现等信息的同步速度降低，所以调整该值大小需要仔细斟酌，有得必有失。</p><p>除了削减每次发送的消息数量，还缩小了每次发送的数据包，每条Gossip消息都由消息头和消息体组成，其中消息头中的myslots字段（自己负责的槽信息，约占2kb），而主要的削减对象是消息体，消息体中主要携带其他节点的信息，用于信息交换，但每次都全量携带所有节点的信息显然太浪费，所以Redis进行了削减，每次只携带<code>cluster.nodes.size/10</code>个其他节点的信息。</p><h4 id="3-3：扩容"><a href="#3-3：扩容" class="headerlink" title="3.3：扩容"></a>3.3：扩容</h4><p>前面我们就讲过集群中的每条数据都会通过哈希计算被映射进一个槽位，而每个槽位又按照编号均匀分布在集群的每个节点中，所以扩缩容说白了就是槽和数据在各个节点间移动。现在我们假设给集群加入了两个节点，它们融入进cluster的流程如下：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-15.png?imageView2/0/w/1100" alt="图10"></p><p>截至目前，新节点依旧没有对外服务，因为还没分配槽，只要两个节点有一个不是从节点（假设6385非从），那么slots一定会重新分配，就像这样（其他主节点匀给新节点一部分slots）：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-16.png?imageView2/0/w/380" alt="图11"></p><p>迁移过程较复杂，我们以一个槽位的迁移为切入点进行详细介绍，假设现在要将6381的某个槽对应的数据迁移到6385，过程如下：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-17.png?imageView2/0/w/650" alt="图12"></p><p>这个过程很复杂，如果全部通过手动来做那肯定不合适，所以redis-trib.rb为我们提供了槽重新分片的功能：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-trib.rb reshard $&#123;host:port&#125; --from $&#123;source-node-id&#125; --to $&#123;target-node-id&#125; --slots $&#123;need-migrate-slots-total&#125; --yes --timeout $&#123;pre-migrate-timeout&#125; --pipline $&#123;per-migrate-key-total&#125;</span><br></pre></td></tr></table></figure><p>入参释义：</p><ol><li>host:port：必传，是集群中任意节点的地址，用来获取整个集群的信息</li><li>source-node-id：源节点id，可用逗号传多个</li><li>target-node-id：目标节点id，只允许填写一个，例如图11中就可以认为source-node-id是6379&#x2F;6380&#x2F;6381三个节点，而目标节点就是6385</li><li>need-migrate-slots-total：需要迁移的槽的总数量，新增主节点可以根据16384&#x2F;nodes.size估算出来</li><li>pre-migrate-timeout：单次migrate超时时间，缺省值：60000ms</li><li>per-migrate-key-total：单次migrate迁移的键数量，缺省值：10</li></ol><blockquote><p>ps：因为reshard命令每次只允许指定一个<code>目标节点</code>，所以当扩容多个节点时需要一个个的进行迁移（此时被加进来的节点为<code>目标节点</code>），而缩容时如果需要缩多个节点，可以将这些下线节点同时指定为源节点，但迁移至其集群内其他节点时也需要一个个执行（此时其他节点为<code>目标节点</code>）。</p></blockquote><h4 id="3-4：缩容"><a href="#3-4：缩容" class="headerlink" title="3.4：缩容"></a>3.4：缩容</h4><p>理解了扩容，缩容就好理解了，如果要从集群下掉一个节点，流程如下：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-18.png?imageView2/0/w/500" alt="图13"></p><p><strong>1.迁移槽</strong></p><p>假如我们要将上面例子中的某个主节点下掉，这里槽迁移过程和扩容时是一样的，唯一的不同点是现在的目标节点有三个，而源节点只有一个，所以需要将源节点里的槽位列出来，算出来其负责的槽位数，然后用<code>槽位数/3</code>计算出其余三个节点均摊多少槽位，然后分三次reshard即可。</p><p><strong>2.忘记节点</strong></p><p>通过以下命令来完成：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">向集群内每个节点发送下面的命令，发送后对应节点就会把下线节点加入到禁用列表里，</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">处于禁用列表中的node不再参与Gossip通信，但该列表只有60s有效期，所以得在过</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">期前让集群内所有节点都收到cluster forget指令</span></span><br><span class="line">cluster forget $&#123;target-node-id&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果觉得上面的流程麻烦，还可以使用redis-trib对着任意集群节点发送以下指令</span></span><br><span class="line">redis-trib.rb del-node $&#123;host:port&#125; $&#123;target-node-id&#125;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">↑上面这个指令内部逻辑就是循环集群内其他节点挨个发cluster forget指令，除此</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">之外，它还会将下线节点的从节点（如果有的话）指向别的主节点（原则上是指定给从</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">节点最少的那个主节点）</span></span><br></pre></td></tr></table></figure><h4 id="3-5：故障转移"><a href="#3-5：故障转移" class="headerlink" title="3.5：故障转移"></a>3.5：故障转移</h4><p>通过前面几个小节，我们知道了redis集群如何做心跳检查和扩缩容，这一小节，我们就来聊聊故障的转移。</p><p>一个正常集群内的各个节点会定期发送ping&#x2F;pong消息，用来同步集群信息和做心跳检查（参考<code>图11</code>），那么自然也会通过这种方式发现故障节点，通过图11我们知道，一个节点与另一个节点间的ping消息正常情况下不会超出<code>cluster_node_timeout</code>，若超过，说明ping消息失败且重连失败，导致cluster_node_timeout一直得不到刷新，这时便可以判定对方为<code>主观下线（pfail）</code>，现在还不能给这个节点判死刑，因为单台机器认定的故障不具备权威性，这条主观下线信息最终会被传播出去，当超过半数的主节点均认为该节点下线时，此时这个节点才是真正意义上的下线，即<code>客观下线</code>，详细流程如下：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-25.png?imageView2/0/w/860" alt="图14"></p><p>故障节点变为<code>客观下线</code>后，如果被下线的节点持有槽，那么接下来就需要<code>故障恢复</code>，当它的从节点也收到客观下线的消息时，就开始选举一个能替换它对外服务的节点作为新的主节点，选举和恢复流程如下：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-27.png?imageView2/0/w/980" alt="图15"></p><p>故障转移时间跟所配的cluster-node-timeout息息相关（默认15s），配置时可以根据业务容忍度做出适当的调整。</p><h4 id="3-6：路由"><a href="#3-6：路由" class="headerlink" title="3.6：路由"></a>3.6：路由</h4><h5 id="3-6-1：重定向"><a href="#3-6-1：重定向" class="headerlink" title="3.6.1：重定向"></a>3.6.1：重定向</h5><p>槽分配都是在服务端完成的，且服务端每个节点都保存有一份当前的槽信息，那客户端要如何准确的访问整个集群呢？redis官方的做法是让客户端无脑发起直连，被连到的服务端做路由分析与转发，流程如下：</p><p>前两种方案都是建立在服务端节点无作为的情况下进行的，这样做有一个坏处，Gossip协议是最终一致的，那么槽信息的同步必定会存在延迟，这样在做槽迁移时会存在大量路由错误的key，而且第二种方案还加大了系统的复杂度，得不偿失。</p><p>第三种方案是服务端自身做路由转发，这也就意味着服务端节点本身具备判断槽分配的能力，即便是正在槽迁移，路由至错误节点，错误节点也能很好的更正路由（多次路由转发必定会找到正确的那个节点），而且这个方案并没有额外增加模块，没有增加维护成本，所以redis官方采用了这种方案，流程如下：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-19.png?imageView2/0/w/560" alt="图16"></p><p>客户端指令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6379</span><br><span class="line">127.0.0.1:6379&gt; set $&#123;key&#125; $&#123;value&#125;</span><br><span class="line">(error) MOVED $&#123;slot-num&#125; 127.0.0.1:6381 #表示当前key所属槽分布在6381上</span><br><span class="line"></span><br><span class="line">127.0.0.1:6381&gt; set $&#123;key&#125; $&#123;value&#125;</span><br><span class="line">OK #重新到6381上则顺利执行</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">你或许觉得上面的操作过于麻烦，没关系，还可以给redis-cli加-c自动路由（内部逻辑跟上面是一样的，只是redis-cli帮我们屏蔽掉了）</span></span><br><span class="line">redis-cli -p 6379 -c</span><br><span class="line">127.0.0.1:6379&gt; set $&#123;key&#125; $&#123;value&#125;</span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">Redirected to slot [<span class="variable">$&#123;slot-num&#125;</span>] located at 127.0.0.1:6381 <span class="comment">#即便在6379上执行，也可以自动路由</span></span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><blockquote><p>集群环境下，不能很好的支持<code>mget</code>等批量命令，因为多个key无法保证都落到同一个节点上，可以通过<code>&#123;&#125;</code>做路由控制，因为cluster做哈希计算时如果发现key里包含一对<code>&#123;&#125;</code>，则只让<code>&#123;&#125;</code>内的部分参与哈希计算，可以通过这个特点来让一些需要批量操作的key落入同一个节点内。</p></blockquote><p>集群中每个节点都保存一份完整的slot-node映射关系，其保存在<code>clusterState</code>结构中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line">    clusterNode *myself; <span class="comment">//自身节点</span></span><br><span class="line">    clusterNode *slots[CLUSTER_SLOTS]; <span class="comment">//16384个槽-节点映射数组，下标为槽</span></span><br><span class="line">    ...略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面客户端请求重定向的逻辑伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">execute_or_redirect</span><span class="params">(key)</span>:</span><br><span class="line"><span class="type">int</span> slot = key_hash_slot(key);</span><br><span class="line">ClusterNode node = slots[slot];</span><br><span class="line"><span class="keyword">if</span>(node == clusterState.myself):</span><br><span class="line"><span class="keyword">return</span> executeCommand(key);</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;(error) MOVED [slot-num] [ip]:[port]&#x27;</span>;</span><br></pre></td></tr></table></figure><p>通过上面的了解，我们知道了客户端与集群交互的基本流程，但这个流程存在一个问题，倘若大部分时候都请求不到准确的节点，那岂不是意味着客户端大部分访问都需要通信两次才能完成？这对IO来说是笔不菲的开销，有没有更聪明的办法来做路由呢？</p><h5 id="3-6-2：Smart-Client"><a href="#3-6-2：Smart-Client" class="headerlink" title="3.6.2：Smart Client"></a>3.6.2：Smart Client</h5><p>事实上现在大部分语言的客户端都解决了这个问题，比如<code>Jedis</code>，解决办法就是在本地直接缓存下来slot-node映射信息（初始化时访问任意节点发送<code>cluster slots</code>指令即可获得），等key来了可以直接在客户端做好路由发给正确的节点，当偶尔发生MOVE响应时就更新本地的映射信息。</p><p>拿<code>JedisCluster</code>来说，它的处理流程如下：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-20.png?imageView2/0/w/700" alt="图17"></p><p>上面在出问题的情况下（比如连接出错、重定向）会重试一定的次数，当超出重试个数就会抛出以下异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JedisClusterMaxRedirectionsException(<span class="string">&quot;Too many Cluster redirections?&quot;</span>);</span><br></pre></td></tr></table></figure><p>所以不管是太多次连接出错，还是大量重定向发生，都会抛出这个异常。</p><h5 id="3-6-3：ASK重定向"><a href="#3-6-3：ASK重定向" class="headerlink" title="3.6.3：ASK重定向"></a>3.6.3：ASK重定向</h5><p>这绝对是我最感兴趣的部分，参考<code>图12</code>，如果客户端在发送命令时redis集群正在进行槽迁移，那么势必会出现下面这种情况：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-22.png?imageView2/0/w/400" alt="图18"></p><p>出现了上面的问题，如果要保证客户端的可用性，此时源节点肯定会通知客户端重定向至目标节点，那么redis具体是怎么做的呢？答案就是<code>ASK重定向</code>，与<code>MOVED重定向</code>有一些不同，它只会发生在槽迁移阶段，它的具体流程如下：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-23.png?imageView2/0/w/400" alt="图19"></p><p>通过这个流程可以保证在槽迁移过程中客户端也能很好的得到响应，再来看看服务端具体的处理流程：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-24.png?imageView2/0/w/750" alt="图20"></p><h3 id="四、问题-建议"><a href="#四、问题-建议" class="headerlink" title="四、问题&amp;建议"></a>四、问题&amp;建议</h3><h4 id="4-1：配置上的建议"><a href="#4-1：配置上的建议" class="headerlink" title="4.1：配置上的建议"></a>4.1：配置上的建议</h4><p><code>3.5</code>中的故障转移过程中整个集群是不可用状态，可以通过将<code>cluster-require-full-coverage</code>设为<code>no</code>来保证出现故障时其他未故障节点可用。</p><h4 id="4-2：带宽开销"><a href="#4-2：带宽开销" class="headerlink" title="4.2：带宽开销"></a>4.2：带宽开销</h4><p>Redis对带宽的消耗主要体现在两方面，一是Gossip本身会消耗带宽，二是指令处理，官方建议redis集群最大规模在1000以内，也是出于对消息通信成本的考虑，可以通过增加物理机器来增加整体带宽；</p><p>提高cluster-node-timeout可以降低Gossip通信速率，但同样会影响故障转移的速度，请酌情选择合适的值。</p><p>如果条件允许，集群尽量部署在更多的机器上，如果大量的节点集中部署在少量物理机器上，这时机器的带宽消耗将非常严重。</p><h4 id="4-3：集群倾斜"><a href="#4-3：集群倾斜" class="headerlink" title="4.3：集群倾斜"></a>4.3：集群倾斜</h4><p>导致集群倾斜的原因和解决之道：</p><ul><li>节点和槽分布严重不均：可以通过<code>redis-trib.rb rebalance</code>均衡槽的分配</li><li>不同槽对应的键数量差异过大：我们知道键通过CRC16哈希函数映射到槽上，正常情况下槽内键数会相对均匀，但当大量使用hash_tag时（例如user:user1:ids，user1就是hash_tag），会有不同的键映射到同一个槽的情况，通过命令<code>cluster countkeysinslot $&#123;slot&#125;</code>可以获得槽对应的键数，识别出哪些槽映射了过多的键，再通过命令<code>cluster getkeysinslot $&#123;slot&#125; $&#123;count&#125;</code>迭代出槽下所有的键，从而发现过度使用hash_tag的键。</li><li>集合对象包含大量元素：大集合对象可在客户端通过<code>--bigkeys</code>指令输出，找出大集合后可根据业务场景进行拆分（大集合的键迁移时还容易超时导致失败）</li><li>内存相关配置不一致：集群内各节点的内存配置要保持一致（比如xxxx-max-ziplist-value等）。</li></ul><h4 id="4-4：手动故障转移"><a href="#4-4：手动故障转移" class="headerlink" title="4.4：手动故障转移"></a>4.4：手动故障转移</h4><p>在从节点执行<code>cluster failover</code>命令将会发起故障转移流程。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;上回主要介绍了redis的主从模式，主从模式最主要的作用是提高redis的可用性，假如主节点挂了，从节点可以在&lt;code&gt;哨兵机制&lt;/code&gt;的协助下晋升为主节点继续对外服务，但主从终归是多个redis节点都保存同一份数据，在redis数据快速膨胀时，又该如何应对呢？redis对于这种情况提供了Cluster模式，这是redis的分布式解决方案，使得大批量数据可以拆分成小部分保存进多个redis节点中，本篇笔记将展开说一下&lt;code&gt;Redis Cluster&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="redis" scheme="http://example.com/tags/redis/"/>
    
    <category term="缓存技术" scheme="http://example.com/tags/%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Redis知识整合（三）：高可用-主从</title>
    <link href="http://example.com/2021/05/24/Redis%E7%9F%A5%E8%AF%86%E6%95%B4%E5%90%88%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E9%AB%98%E5%8F%AF%E7%94%A8-%E4%B8%BB%E4%BB%8E/"/>
    <id>http://example.com/2021/05/24/Redis%E7%9F%A5%E8%AF%86%E6%95%B4%E5%90%88%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E9%AB%98%E5%8F%AF%E7%94%A8-%E4%B8%BB%E4%BB%8E/</id>
    <published>2021-05-24T14:25:00.000Z</published>
    <updated>2023-12-03T10:52:17.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis知识整合（三）：高可用-主从"><a href="#Redis知识整合（三）：高可用-主从" class="headerlink" title="Redis知识整合（三）：高可用-主从"></a>Redis知识整合（三）：高可用-主从</h1><blockquote><p>要想提高一个有状态服务的可用性，最简单直接的办法就是扩展从节点，这样主节点挂了，从节点就可以上位并代替原先的节点继续对外提供服务，同时也可用从节点做负载均衡，作为目前最好用的分布式缓存之一的redis自然也支持主从配置，这篇文档的主要内容就是围绕这个话题展开的。</p></blockquote><span id="more"></span><h3 id="一、配置-部署"><a href="#一、配置-部署" class="headerlink" title="一、配置&amp;部署"></a>一、配置&amp;部署</h3><h4 id="1-1：建立主从关系"><a href="#1-1：建立主从关系" class="headerlink" title="1.1：建立主从关系"></a>1.1：建立主从关系</h4><p>如何让一个redis节点变成另一个节点的从节点呢？很简单，首先在从节点的配置文件中加上以下配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof [master host] [master port]</span><br></pre></td></tr></table></figure><p>↑这同样也是个命令，可以直接在从节点上执行</p><p>也可以在启动redis-server的命令后面加上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--slaveof [master host] [master port]</span><br></pre></td></tr></table></figure><p>注：<code>slaveof</code>是一个异步命令，开始只保存主节点信息，后续复制操作都是在从节点内异步执行的，<code>info replication</code>可以帮助我们查看当前的复制情况（主从节点都可以执行这个指令，只是输出信息不一样而已）。</p><h4 id="1-2：废除主从关系"><a href="#1-2：废除主从关系" class="headerlink" title="1.2：废除主从关系"></a>1.2：废除主从关系</h4><p>在从节点执行以下命令可废除与主节点的关联，并晋升为主节点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof no one</span><br></pre></td></tr></table></figure><p>废除关系后，原从节点内的数据还在，只是失去了同步原主节点数据的能力。</p><h4 id="1-3：切主"><a href="#1-3：切主" class="headerlink" title="1.3：切主"></a>1.3：切主</h4><p>非常简单，只需要在从节点再次执行以下命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof [new master host] [new master port]</span><br></pre></td></tr></table></figure><p>执行后，发生以下变化：</p><ol><li>断开与旧主节点的复制关系</li><li>建立与新主节点的复制关系</li><li><strong>删除当前自身所有的数据</strong></li><li>复制新主节点的数据</li></ol><h4 id="1-4：只读"><a href="#1-4：只读" class="headerlink" title="1.4：只读"></a>1.4：只读</h4><p>一般情况下，从节点对外应只提供读操作，可以通过以下配置启用节点的只读模式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slave-read-only = yes</span><br></pre></td></tr></table></figure><h4 id="1-5：部署方案"><a href="#1-5：部署方案" class="headerlink" title="1.5：部署方案"></a>1.5：部署方案</h4><p>redis主从可行的部署方案如下：</p><p><img src="http://myblog.sharemer.com/2021/05/24/20210524-1-1.png?imageView2/0/w/800" alt="图1"></p><p>无论是哪种主从模式，都可以解决单点故障问题，但需要注意的是，一主多从虽然可以做读操作的负载均衡，但会加大主节点的负载（因为所有从节点都订阅了主节点的变更），为了解决这个问题，便有了树状部署方式，从节点继续向下拓展，这样可以有效降低主节点的负载（主节点只需要关心自己下一层的从节点即可）</p><blockquote><p>我现在的公司通常为一主一从、集群部署，主从所在的物理机必定不是同一台，这样可以有效降低缓存雪崩的概率（两台物理机同时gg的概率很小），且没有开启持久化等影响主进程的操作，完全将redis当成缓存来用。</p></blockquote><h3 id="二、同步过程"><a href="#二、同步过程" class="headerlink" title="二、同步过程"></a>二、同步过程</h3><ol><li>保存主节点信息：当<code>slaveof</code>命令执行完毕后，复制流程还没有真正开始，而是将master的ip+port保存了下来。</li><li>主从建立socket连接：从节点有个维护复制相关逻辑的定时器，当其发现存在新的主节点后，会尝试与其建立连接，用来接收主节点发来的复制命令（建连失败时，定时任务会无限重试，除非建连成功或执行<code>slave no one</code>）</li><li>发送<code>ping</code>请求：目的是检查socket是否可用、主节点是否受理（若不满足条件，从节点会断开socket，并在下次定时循环中重试）</li><li>权限校验：在主节点设置了<code>requirepass</code>的情况下，则需要密码校验，从节点需要设置<code>masterauth</code>来保证通过主节点的校验（若未通过校验，同3）</li><li>同步数据集：一切就绪后，从节点会向主节点发送一个<code>psync</code>指令，主节点第一次会将自己全部的数据生成快照发送给从节点（rdb文件）；2.8之前只支持<code>sync</code>同步，sync无脑全量复制，比如从节点断连后重连，也会触发一次全量复制，从节点在全量复制时是无法对外提供服务的，为了解决这一痛点，redis在2.8支持了<code>psync</code>，psync支持<code>全量复制</code>和<code>部分复制</code>，当第一次同步数据时才会全量复制，重连操作一般会利用<code>主节点运行ID</code>、<code>复制偏移量</code>和<code>复制积压缓冲区</code>，并采用<code>部分复制</code>的方式补发断连期间产生的增量数据（指令：<code>psync [runid] [offset]</code>）。</li><li>增量复制：当5完成后，接下来主节点会持续的将写命令发送给从节点，来保证主从一致性</li></ol><p>整体流程图（黄色部分为<code>复制建设流程</code>，紫色为<code>全量复制流程</code>，绿色为稳定期间的<code>增量同步流程</code>，蓝色为从节点挂掉又恢复后的<code>部分复制流程</code>）：</p><p><img src="http://myblog.sharemer.com/2021/05/24/20210524-1-8.png?imageView2/0/w/1600" alt="图2"></p><h3 id="三、常见问题"><a href="#三、常见问题" class="headerlink" title="三、常见问题"></a>三、常见问题</h3><h4 id="3-1：传输延迟"><a href="#3-1：传输延迟" class="headerlink" title="3.1：传输延迟"></a>3.1：传输延迟</h4><p>主节点一般通过网络传输同步数据，存在延迟的风险，redis通过以下配置项控制是否关闭<code>TCP_NODELAY</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repl-disable-tcp-nodelay = yes ### 默认no</span><br></pre></td></tr></table></figure><ul><li>开启：主节点为了节省带宽会合并较小的TCP数据包，默认发送时间取决于Linux内核，默认40ms，这种方式虽然节省了带宽但也加大了主从延迟，适用于主从网络环境较紧张的场景，比如主从跨机房部署。</li><li>关闭：主节点产生的命令数据无论多大都会及时的发送给从节点，这样主从延迟会变小，但加大了网络带宽，适用于主从网络环境较好的场景，比如主从同机房部署。</li></ul><h4 id="3-2：主从配置不一致"><a href="#3-2：主从配置不一致" class="headerlink" title="3.2：主从配置不一致"></a>3.2：主从配置不一致</h4><p>主从节点有关内存阈值的配置一定要保持一致</p><h4 id="3-3：避免复制风暴"><a href="#3-3：避免复制风暴" class="headerlink" title="3.3：避免复制风暴"></a>3.3：避免复制风暴</h4><p>如果一个主节点挂载了很多从节点，当这个主节点重启时，它的所有从节点势必会同时发起全量复制流程，虽然可以共享rdb文件，但这对主节点的带宽消耗是灾难性的，解决方案就是改变部署结构，参考图1中的树状结构部署，以减少直接挂载到主节点的从节点数量。</p><h4 id="3-4：各缓冲区-超时时间不够用"><a href="#3-4：各缓冲区-超时时间不够用" class="headerlink" title="3.4：各缓冲区&#x2F;超时时间不够用"></a>3.4：各缓冲区&#x2F;超时时间不够用</h4><p>可以估算出大致的阈值，然后设置一个大于该估算值的结果，比如估算rdb同步超时时间，假设网卡带宽峰值为100M&#x2F;s，那么rdb传输耗时就是：repl_timeout &#x3D; rdb大小 &#x2F; 100MB；</p><p>再比如估算复制积压缓冲区应设大小，假如网络中断时长为net_break_time(秒)，然后根据高峰期每秒的master_repl_offset推算出高峰期每秒的大概写入量write_size_per_sec，然后保证：<code>repl_backlog_size &gt; net_break_time * write_size_per_sec</code>即可。</p><h4 id="3-5：最终一致"><a href="#3-5：最终一致" class="headerlink" title="3.5：最终一致"></a>3.5：最终一致</h4><p>诚如你所见，redis主从复制是最终一致的，既然是最终一致，那就有可能在极端情况下造成少量数据丢失，应注意这个问题，至少你不应该完全信任redis，需要做好防范措施，比如定期回源刷新数据，保证少量问题数据可以自动得到修复。</p><h3 id="四、哨兵（Sentinel）"><a href="#四、哨兵（Sentinel）" class="headerlink" title="四、哨兵（Sentinel）"></a>四、哨兵（Sentinel）</h3><h4 id="4-1：基本工作流程"><a href="#4-1：基本工作流程" class="headerlink" title="4.1：基本工作流程"></a>4.1：基本工作流程</h4><p>前面的内容主要介绍了redis的主从模式，主从模式最主要的作用是提高redis的可用性，假如主节点挂了，从节点可以晋升为主节点继续对外提供服务，这个自动调整主从的过程可以通过<code>Sentinel</code>机制来实现，如果没有Sentinel，我们就得手动搞定这一切了，想想就可怕（redis在2.8版本才支持了Sentinel）。</p><p>Redis Sentinel高可用架构包含了多个sentinel节点和多个redis节点（主+从），每个sentinel节点都会对这些redis节点和其他sentinel节点进行监控（事实上sentinel节点也是redis节点，只是比较特殊，它们不存储数据且只接收部分命令），大致结构如下：</p><p><img src="http://myblog.sharemer.com/2021/05/24/20210524-1-10.png?imageView2/0/w/650" alt="图3"></p><p>当某个sentinel发现自己所监控的某个节点不可达后，会对这个节点做下线标识，如果该节点是redis的master节点，它就会和其他sentinel协商，当大多数sentinel都认为这个主节点不可达时，就会选出一个sentinel代表来完成故障转移工作，同时会将这个变化实时同步给redis client，这个过程是全自动的，下面的流程图展示了这个过程（假设主节点挂掉）：</p><p><img src="http://myblog.sharemer.com/2021/05/24/20210524-1-11.png?imageView2/0/w/1920" alt="图4"></p><h4 id="4-2：安装-部署"><a href="#4-2：安装-部署" class="headerlink" title="4.2：安装&amp;部署"></a>4.2：安装&amp;部署</h4><p>假如我们现在要搭建图3里的Redis Sentinel架构，那要如何配置呢？</p><h5 id="4-2-1：启动主节点"><a href="#4-2-1：启动主节点" class="headerlink" title="4.2.1：启动主节点"></a>4.2.1：启动主节点</h5><p>这是主节点主要的的配置信息(<code>redis-6379.conf</code>)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 6379 # 端口号</span><br><span class="line">daemonize yes # 以守护线程的方式在后台运行</span><br><span class="line">logfile &quot;log-6379.log&quot; # redis日志输出文件</span><br><span class="line">dbfilename &quot;dump-6379.rdb&quot; # rdb输出文件</span><br><span class="line">dir &quot;/opt/soft/redis/data/&quot; # rdb输出文件所在的路径</span><br></pre></td></tr></table></figure><p>启动+测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis-6379.conf</span><br><span class="line"></span><br><span class="line">redis-cli -h 127.0.0.1 -p 6379 ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><h5 id="4-2-2：启动从节点"><a href="#4-2-2：启动从节点" class="headerlink" title="4.2.2：启动从节点"></a>4.2.2：启动从节点</h5><p>两个从节点的配置除了端口号等细节外是一样的，我们这里拿其中一个举例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">port 6380</span><br><span class="line">daemonize yes</span><br><span class="line">logfile &quot;log-6380.log&quot;</span><br><span class="line">dbfilename &quot;dump-6380.rdb&quot;</span><br><span class="line">dir &quot;/opt/soft/redis/data/&quot;</span><br><span class="line">slaveof 127.0.0.1 6379 # 跟上面的主节点建立主从关系</span><br></pre></td></tr></table></figure><p>启动+测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis-6380.conf</span><br><span class="line">redis-server redis-6381.conf</span><br><span class="line"></span><br><span class="line">redis-cli -h 127.0.0.1 -p 6380 ping</span><br><span class="line">PONG</span><br><span class="line">redis-cli -h 127.0.0.1 -p 6381 ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><p>然后确认一遍主从关系是否正确，这是主节点视角的验证：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 6379 info replication</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=281,lag=1</span><br><span class="line">slave1:ip=127.0.0.1,port=6381,state=online,offset=281,lag=0</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这是从节点视角的验证（以其中一个为例）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 6380 info replication</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>到这里，主从架构就搭建完成了，接下来开始搭建sentinel环境。</p><h5 id="4-2-3：部署sentinel"><a href="#4-2-3：部署sentinel" class="headerlink" title="4.2.3：部署sentinel"></a>4.2.3：部署sentinel</h5><p>前面我们就了解到sentinel的本质也是redis节点，且不管几个sentinel，它们每个节点的部署方法都是一致的，所以我们只关注一个sentinel节点如何部署就好。</p><p>这是主要的配置信息(redis-sentinel-26379.conf)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">port 26379</span><br><span class="line">daemonize yes</span><br><span class="line">logfile &quot;log-26379.log&quot;</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2 # 监听指定的主节点，将其命名为mymaster，且判断主节点失败至少需要2个sentinel节点同意</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000 # 定时检查发送的检查指令响应超出30s视为失败</span><br><span class="line">sentinel parallel-syncs mymaster 1 # 含义参考下面的说明</span><br><span class="line">sentinel failover-timeout mymaster 180000 # 含义参考下面的说明</span><br><span class="line">说明：</span><br><span class="line">sentinel monitor [master_name] [master_ip] [master_port] [quorum]</span><br><span class="line">sentinel会定期监控主节点，上面的配置可以指定要监控的主节点，quorum比较特殊，它可以</span><br><span class="line">代表判定主节点最终不可达所需要的票数，也可以代表至少需要max(quorum,num(sentinel)/2 + 1)</span><br><span class="line">个sentinel参与才能选出sentinel的领导者来处理故障转移任务；</span><br><span class="line">quorum的取值建议设为num(sentinel)/2+1</span><br><span class="line">============================================================================</span><br><span class="line">sentinel down-after-milliseconds [master_name] [time]</span><br><span class="line">sentinel节点会定期发送ping命令来确定redis节点和sentinel节点是否可达，若ping所用</span><br><span class="line">时间超出了配置的times（毫秒），则判为不可达</span><br><span class="line">============================================================================</span><br><span class="line">sentinel parallel-syncs [master_name] [nums]</span><br><span class="line">当主节点故障时，sentinel选出新的主节点，此时从节点会向新主节点发起复制，nums用来控制</span><br><span class="line">同时发起复制的从节点数量，可以通过调小该值达到降低主节点的网络/IO开销的目的</span><br><span class="line">============================================================================</span><br><span class="line">sentinel failover-timeout [master_name] [time]</span><br><span class="line">故障转移超时时间，作用于故障转移的各个阶段，比如重新选主、命令从节点向主节点发起复制（不</span><br><span class="line">含复制时间）、等待原主节点恢复后命令其发起复制，在这几个步骤里任意步骤超过failover-timout</span><br><span class="line">就视为故障转移失败</span><br></pre></td></tr></table></figure><p>启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel redis-sentinel-26379.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或</span></span><br><span class="line">redis-server redis-sentinel-26379.conf --sentinel</span><br></pre></td></tr></table></figure><p>当三个sentinel节点都启动完毕后，输入以下指令检验其准确性：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 26379 info Sentinel</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Sentinel</span></span><br><span class="line">sentinel_masters 1</span><br><span class="line">sentinel_tilt:0</span><br><span class="line">sentinel_running_scripts:0</span><br><span class="line">sentinel_scripts_queue_length:0</span><br><span class="line">master0:name=mymaster,status=ok,address=127.0.0.1:6379,slaves=2,sentinels=3</span><br></pre></td></tr></table></figure><p>到这里整个sentinel+主从架构就搭建完成了，它们会按照之前说的那样工作；虽然redis可以单机多实例部署，但为了保证高可用，不建议将所有的节点都部署在同一台物理机上。</p><p>所有节点都启动后，sentinel配置文件发生了变化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">port 26379</span><br><span class="line">daemonize yes</span><br><span class="line">logfile &quot;log-26379.log&quot;</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line">sentinel config-epoch mymaster 0</span><br><span class="line">sentinel leader-epoch mymaster 0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发现2个slave</span></span><br><span class="line">sentinel-know-slave mymaster 127.0.0.1 6380</span><br><span class="line">sentinel-know-slave mymaster 127.0.0.1 6381</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发现另外2个sentinel节点</span></span><br><span class="line">sentinel known-sentinel mymaster 127.0.0.1 26380 xxxxxxxx(runid)</span><br><span class="line">sentinel known-sentinel mymaster 127.0.0.1 26381 yyyyyyyy(runid)</span><br><span class="line">sentinel current-epoch 0</span><br></pre></td></tr></table></figure><p>可以看到<code>down-after-milliseconds</code>、<code>parallel-syncs</code>、<code>failover-timeout</code>消失了，取而代之的是sentinel发现的各种节点信息，也就是说每个sentinel都是有能力自动发现所有需要监控的节点的。</p><h5 id="4-2-4：监控多个master"><a href="#4-2-4：监控多个master" class="headerlink" title="4.2.4：监控多个master"></a>4.2.4：监控多个master</h5><p>非常简单，只需要将原来的配置改成监听多个master的即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">port 26379</span><br><span class="line">daemonize yes</span><br><span class="line">logfile &quot;log-26379.log&quot;</span><br><span class="line">sentinel monitor mymaster-1 127.0.0.1 6379 2</span><br><span class="line">sentinel down-after-milliseconds mymaster-1 30000</span><br><span class="line">sentinel parallel-syncs mymaster-1 1</span><br><span class="line">sentinel failover-timeout mymaster-1 180000</span><br><span class="line"></span><br><span class="line">sentinel monitor mymaster-2 127.0.0.1 6389 2</span><br><span class="line">sentinel down-after-milliseconds mymaster-2 30000</span><br><span class="line">sentinel parallel-syncs mymaster-2 1</span><br><span class="line">sentinel failover-timeout mymaster-2 180000</span><br></pre></td></tr></table></figure><p>假如现在有一个sentinel集群，同时服务了两套redis主从服务，拓扑图就变成了下面这样：</p><p><img src="http://myblog.sharemer.com/2021/05/24/20210524-1-12.png?imageView2/0/w/850" alt="图5"></p><h5 id="4-2-5：部署技巧"><a href="#4-2-5：部署技巧" class="headerlink" title="4.2.5：部署技巧"></a>4.2.5：部署技巧</h5><ul><li>sentinel节点、主从节点应尽可能不部署到同一台物理机上</li><li>至少部署3个且奇数个sentinel节点，这是为了提高故障判定的准确率（多sentinel节点协商可以降低误判），奇数是为了在满族要求的机器数量基础上节约一台机器。</li><li>只配一套sentinel监听所有节点，还是专门以主节点为维度给每个主节点单独配置一套？只配一套可以降低维护成本，但是这样容错率很低，比如sentinel集群出问题会影响所有的redis节点，但反过来给每个主节点单独配置一套又拉高了维护成本和资源浪费，那该怎么取舍呢？这个可以分情况：如果是同一个业务下的主节点可以共用一套sentinel，反之多套。</li></ul><h4 id="4-3：哨兵专属指令集"><a href="#4-3：哨兵专属指令集" class="headerlink" title="4.3：哨兵专属指令集"></a>4.3：哨兵专属指令集</h4><table><thead><tr><th align="left">指令</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left"><code>sentinel masters</code> [master_name]</td><td align="left">列出所有被监控的主节点状态以及相关的统计信息，可指定主节点</td></tr><tr><td align="left"><code>sentinel slaves</code></td><td align="left">列出所有被监控的从节点状态以及相关的统计信息</td></tr><tr><td align="left"><code>sentinel sentinels</code> [master_name]</td><td align="left">列出正在监听指定主节点的sentinel节点信息（但不包含当前sentinel节点）</td></tr><tr><td align="left"><code>sentinel get-master-addr-by-name</code> [master_name]</td><td align="left">输出指定主节点的ip+port</td></tr><tr><td align="left"><code>sentinel reset</code> [pattern]</td><td align="left">当前sentinel对符合<code>pattern</code>的主节点进行配置重置，清除主节点的相关状态，重新发现该主节点和其他sentinel节点</td></tr><tr><td align="left"><code>sentinel failover</code> [master_name]</td><td align="left">对指定主节点（在不和其他sentinel协商的情况下）进行强制故障转移，转移完成后，其他sentinel按照该结果更新自身配置</td></tr><tr><td align="left"><code>sentinel ckquorum</code> [master_name]</td><td align="left">检测当前sentinel节点数是否达到所配的<code>quorum</code>，若未达到，则无法进行故障转移工作</td></tr><tr><td align="left"><code>sentinel flushconfig</code></td><td align="left">将sentinel节点的配置刷到磁盘上</td></tr><tr><td align="left"><code>sentinel remove</code> [master_name]</td><td align="left">取消当前sentinel节点对指定主节点的监控</td></tr><tr><td align="left"><code>sentinel monitor</code> [master_name] [ip] [port] [quorum]</td><td align="left">增加要监控的主节点，详细请参考上面配置文件里对该指令的介绍</td></tr><tr><td align="left"><code>sentinel set</code> [master_name]</td><td align="left">可以利用该指令动态的修改一些配置文件内的属性</td></tr><tr><td align="left"><code>sentinel is-master-down-by-addr</code></td><td align="left">当某个sentinel节点发现主节点坏掉时，为了防止误判，会向其他sentinel节点发送此命令，来获取其他节点对于主节点的判定结果，超出quorum个sentinel判定主节点失效则视为真正失效，此时会发起故障转移，除此之外，它还可以让当前sentinel申请成为故障转移的领导者</td></tr></tbody></table><h4 id="4-4：客户端"><a href="#4-4：客户端" class="headerlink" title="4.4：客户端"></a>4.4：客户端</h4><p>对于客户端来讲，sentinel最重要的一个功能就是将变更后的主节点通知到客户端，如果客户端仍然按照之前的方式进行直连master肯定是不行的，客户端需要跟sentinel进行交互，获取可用的master节点信息，具体过程如下：</p><p><img src="http://myblog.sharemer.com/2021/05/24/20210524-1-13.png?imageView2/0/w/950" alt="图6"></p><p>java里面利用<code>Jedis</code>的JedisSentinelPool和<code>redisson</code>的SentinelServersConfig就可以完成这个过程，具体使用不再赘述。</p><h4 id="4-5：原理"><a href="#4-5：原理" class="headerlink" title="4.5：原理"></a>4.5：原理</h4><h5 id="4-5-1：监控"><a href="#4-5-1：监控" class="headerlink" title="4.5.1：监控"></a>4.5.1：监控</h5><p>sentinel监控其他节点在前面的流程图中就一条线带过，但其实内部逻辑涵盖了三个定时任务，分别是：</p><p><img src="http://myblog.sharemer.com/2021/05/24/20210524-1-14.png?imageView2/0/w/950" alt="图7"></p><h5 id="4-5-2：下线协商"><a href="#4-5-2：下线协商" class="headerlink" title="4.5.2：下线协商"></a>4.5.2：下线协商</h5><p>现在假如master挂掉，此时sentinel会如何处理呢？master挂掉，意味着任意sentinel都无法ping通它，此时sentinel节点会向其他sentinel节点发送<code>sentinel is-master-down-by-addr</code>指令，来获取其他节点对于master节点的判定结果，当超过<code>quorum</code>个sentinel节点都认为master挂掉时，才会真的进行故障转移，这是为了防止单点误判，过程如下：</p><p><img src="http://myblog.sharemer.com/2021/05/24/20210524-1-15.png?imageView2/0/w/650" alt="图8"></p><h5 id="4-5-3：选举领导者"><a href="#4-5-3：选举领导者" class="headerlink" title="4.5.3：选举领导者"></a>4.5.3：选举领导者</h5><p>当认定一个主节点挂掉后（客观下线），并不会立即进行故障转移，而是在sentinel节点间选举出来一个领导者，然后由领导者进行故障转移，这个选举过程采用<code>raft算法</code>实现，具体过程如下：</p><p><img src="http://myblog.sharemer.com/2021/05/24/20210524-1-16.png?imageView2/0/w/700" alt="图9"></p><p>需要注意，图中仅列出了sentinel-2发起申请领导者角色，但实际上任意一个sentinel节点都会请求其他sentinel节点让自己变成领导者，每个sentinel有且仅有一票，最后谁得票多就选谁，如果一轮没选出领导者，那就继续进行下一轮选举，逻辑一致。</p><h5 id="4-5-4：故障转移"><a href="#4-5-4：故障转移" class="headerlink" title="4.5.4：故障转移"></a>4.5.4：故障转移</h5><p>选出领导者，接下来就可以进行故障转移了：</p><p><img src="http://myblog.sharemer.com/2021/05/24/20210524-1-17.png?imageView2/0/w/750" alt="图10"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Redis知识整合（三）：高可用-主从&quot;&gt;&lt;a href=&quot;#Redis知识整合（三）：高可用-主从&quot; class=&quot;headerlink&quot; title=&quot;Redis知识整合（三）：高可用-主从&quot;&gt;&lt;/a&gt;Redis知识整合（三）：高可用-主从&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;要想提高一个有状态服务的可用性，最简单直接的办法就是扩展从节点，这样主节点挂了，从节点就可以上位并代替原先的节点继续对外提供服务，同时也可用从节点做负载均衡，作为目前最好用的分布式缓存之一的redis自然也支持主从配置，这篇文档的主要内容就是围绕这个话题展开的。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="redis" scheme="http://example.com/tags/redis/"/>
    
    <category term="缓存技术" scheme="http://example.com/tags/%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Redis知识整合（二）：数据的持久化</title>
    <link href="http://example.com/2021/05/21/Redis%E7%9F%A5%E8%AF%86%E6%95%B4%E5%90%88%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://example.com/2021/05/21/Redis%E7%9F%A5%E8%AF%86%E6%95%B4%E5%90%88%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/</id>
    <published>2021-05-21T15:15:00.000Z</published>
    <updated>2023-12-03T10:55:59.577Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如果重启redis服务，或者重启redis所在的机器，那么对于将数据全部保存在内存中的redis而言，这两个操作无疑会让其数据全部丢失，此时如果我们没有做更多的容错方案，比如横向做集群、纵向做主从，此时就会造成<code>缓存雪崩</code>，所以我们或许需要给redis内的数据做个持久化，让其在恢复时读取持久化数据，恢复原始数据，redis有两种持久化方式，分别是<code>RDB</code>和<code>AOF</code>，RDB的实时性不如AOF，AOF恢复速度不如RDB</p></blockquote><span id="more"></span><h2 id="一、RDB"><a href="#一、RDB" class="headerlink" title="一、RDB"></a>一、RDB</h2><h3 id="1-1：概览"><a href="#1-1：概览" class="headerlink" title="1.1：概览"></a>1.1：概览</h3><p>RDB持久化会将当前redis进程内的数据生成快照保存到硬盘中（rdb文件），相关指令为<code>bgsave</code></p><p>我们可以通过配置<code>redis.conf</code>使其自动持久化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">save &lt;seconds&gt; &lt;changes&gt; #表示seconds秒内存在changes次修改时，自动触发bgsave命令</span><br><span class="line">dbfilename dump.rdb #这里指定保存的文件名</span><br></pre></td></tr></table></figure><p>在没有开启<code>AOF</code>的情况下<code>shutdown</code>掉redis，也会自动触发一次bgsave;</p><p>还有一种情况会自动触发bgsave，从节点发起全量复制时，主节点会自动触发bgsave并将生成的rdb文件发送给从节点。</p><h3 id="1-2：过程"><a href="#1-2：过程" class="headerlink" title="1.2：过程"></a>1.2：过程</h3><p>bgsave过程如下：</p><p><img src="http://myblog.sharemer.com/2021/05/21/20210521-1-1.png?imageView2/0/w/680" alt="图1-1"></p><p>这是个重操作，好在不影响主进程，即便如此，bgsave也不能频繁执行，这也是rdb持久化方式无法做到秒级持久化的原因，采用这种方式持久化就要承担部分数据丢失的风险。</p><h2 id="二、AOF"><a href="#二、AOF" class="headerlink" title="二、AOF"></a>二、AOF</h2><h3 id="2-1：概览"><a href="#2-1：概览" class="headerlink" title="2.1：概览"></a>2.1：概览</h3><p>针对rdb不适合实时持久化的问题，redis提供了<code>aof</code>持久化方案来解决。</p><p>开启aof持久化的redis.conf配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes #这一项置为true（默认false）</span><br><span class="line">appendfilename &quot;appendonly.aof&quot; #这里指定保存的文件名</span><br></pre></td></tr></table></figure><h3 id="2-2：流程"><a href="#2-2：流程" class="headerlink" title="2.2：流程"></a>2.2：流程</h3><p>aof的大体流程如下：</p><p><img src="http://myblog.sharemer.com/2021/05/21/20210521-1-2.png?imageView2/0/w/880" alt="图2-1"></p><p>主要分为<code>同步aof</code>文件和<code>定期刷新aof</code>文件两大块，定期刷新文件时保证数据不丢失的做法是增量双写（<code>1-1</code>）和旧数据同步（<code>1-2</code>），其中1-2中批量同步新aof文件时，可以通过<code>aof-rewrite-incremental-fsync</code>来控制每次同步的数据大小，默认32M。</p><p>aof重写文件的触发时机主要由以下两种方式控制：</p><ul><li>手动调用<code>bgrewriteaof</code>命令</li><li>根据<code>auto-aof-rewrite-min-size</code>和<code>auto-aof-rewrite-percentage</code>参数控制自动触发时机</li></ul><blockquote><p>auto-aof-rewrite-min-size：运行aof重写时aof文件的最小体积，默认64M</p><p>auto-aof-rewrite-percentage：当前aof文件的增量大小和上一次重写后aof文件大小的比值</p></blockquote><p>根据以上描述，重写aof文件的自动触发条件为：</p><p><img src="http://myblog.sharemer.com/2021/05/21/20210521-1-3.png?imageView2/0/w/880" alt="图2-2"></p><h2 id="三、重启加载"><a href="#三、重启加载" class="headerlink" title="三、重启加载"></a>三、重启加载</h2><p>不管是aof还是rdb，都是为了让redis重启时可以恢复原来的数据，整个过程如下：</p><p><img src="http://myblog.sharemer.com/2021/05/21/20210521-1-4.png?imageView2/0/w/880" alt="图3-1"></p><p>可以看到，当rdb和aof同时启用时，优先使用aof.</p><h2 id="四、优化"><a href="#四、优化" class="headerlink" title="四、优化"></a>四、优化</h2><h3 id="4-1：fork操作"><a href="#4-1：fork操作" class="headerlink" title="4.1：fork操作"></a>4.1：fork操作</h3><p>无论是aof还是rdb，涉及到的fork操作都是重操作，其耗时取决于redis主进程中的内存大小（每次fork都需要复制主进程的内存页表），主进程内存每增加1GB将拖慢fork操作20ms，可以在<code>info stats</code>统计中查看<code>latest_fork_usec</code>指标获取最近一次fork操作的耗时。</p><p>改善fork耗时：</p><ul><li>优先使用物理机或高效支持fork操作的虚拟化技术，避免使用<code>Xen</code></li><li>控制redis的最大可用内存（因为fork耗时跟内存量息息相关），生产环境建议redis实例内存控制在10G内</li><li>合理配置Linux内存分配策，避免物理内存不足导致的fork失败</li><li>降低fork操作的频率，如适当放宽aof的触发时机</li></ul><h3 id="4-2：子进程开销监控-优化"><a href="#4-2：子进程开销监控-优化" class="headerlink" title="4.2：子进程开销监控&amp;优化"></a>4.2：子进程开销监控&amp;优化</h3><p>通过前面的了解，我们知道redis中的子进程主要负责aof和rdb文件的重写，它的运行过程主要涉及CPU、内存、磁盘三部分的消耗：</p><h4 id="4-2-1：CPU"><a href="#4-2-1：CPU" class="headerlink" title="4.2.1：CPU"></a>4.2.1：CPU</h4><p>开销：子进程将进程内的数据分批次写入磁盘属于CPU密集型操作（对单核CPU的利用率可达90%）</p><p>优化：主要以减少资源竞争为优化点，比如：</p><ul><li>redis为CPU密集型服务，所以不要绑定单核CPU操作，因为子进程非常耗CPU，会严重影响父进程（单核上下文竞争）</li><li>要避免和其他CPU密集型服务部署在一起，避免过渡竞争CPU</li><li>多实例部署redis时，应保证同一时刻只有一个子进程在运行</li></ul><h4 id="4-2-2：硬盘"><a href="#4-2-2：硬盘" class="headerlink" title="4.2.2：硬盘"></a>4.2.2：硬盘</h4><p>开销：子进程主要负责将aof或rdb文件写入硬盘，也就造成了硬盘写入压力（可通过系统工具sar、iostat、iotop等分析出重写期间硬盘的负载情况）</p><p>优化：</p><ul><li>不要和其他高硬盘负载的服务部署在一起（比如存储服务、消息队列等）</li><li>aof重写会消耗大量的硬盘IO，所以在重写期间应减少aof缓冲区往aof里fsync的操作（设置<code>no-appendfsync-no-rewrite</code>为true即可，表示在重写期间不做fsync操作，但这样也可能会丢失整个aof重写期间的数据）</li><li>在开启aof且redis处于高流量写入场景时，若使用普通机械硬盘，则在aof同步硬盘时会发生瓶颈</li><li>对于单机多实例的部署，可以配置不同实例分盘存储aof，分摊硬盘写入压力</li></ul><h4 id="4-2-3：AOF追加阻塞"><a href="#4-2-3：AOF追加阻塞" class="headerlink" title="4.2.3：AOF追加阻塞"></a>4.2.3：AOF追加阻塞</h4><p>通过图2-1我们知道，被写入aof缓冲区的数据在everysec策略下会每隔1s调用系统的fsync写一次磁盘，既然是一次调用，那必然存在耗时，fsync是通过delay的方式定期触发的，每次redis主线程在发起fsync调用前都会判断上次fsync的时间，如果耗时超出2s，redis主线程便会陷入阻塞，等待上次fsync执行完，所以aof理论上最多会丢失2s的数据（通过info Persistence中的<code>aof_delayed_fsync</code>可以查看aof同步任务是否发生了delay）。</p><p>避免这种情况发生的办法就是优化硬盘（参考4.2.2）</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;如果重启redis服务，或者重启redis所在的机器，那么对于将数据全部保存在内存中的redis而言，这两个操作无疑会让其数据全部丢失，此时如果我们没有做更多的容错方案，比如横向做集群、纵向做主从，此时就会造成&lt;code&gt;缓存雪崩&lt;/code&gt;，所以我们或许需要给redis内的数据做个持久化，让其在恢复时读取持久化数据，恢复原始数据，redis有两种持久化方式，分别是&lt;code&gt;RDB&lt;/code&gt;和&lt;code&gt;AOF&lt;/code&gt;，RDB的实时性不如AOF，AOF恢复速度不如RDB&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="redis" scheme="http://example.com/tags/redis/"/>
    
    <category term="缓存技术" scheme="http://example.com/tags/%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Redis知识整合（一）：常用数据结构&amp;指令集</title>
    <link href="http://example.com/2021/05/18/Redis%E7%9F%A5%E8%AF%86%E6%95%B4%E5%90%88%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E6%8C%87%E4%BB%A4%E9%9B%86/"/>
    <id>http://example.com/2021/05/18/Redis%E7%9F%A5%E8%AF%86%E6%95%B4%E5%90%88%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E6%8C%87%E4%BB%A4%E9%9B%86/</id>
    <published>2021-05-18T04:56:00.000Z</published>
    <updated>2023-12-03T10:59:45.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言：Redis各版本重大更新"><a href="#前言：Redis各版本重大更新" class="headerlink" title="前言：Redis各版本重大更新"></a>前言：Redis各版本重大更新</h2><p>截至2021年5月，Redis的稳定版本已经更新到了6.2，所以这里我想整理一下redis自发布以来每一个大版本的重要更新，当然我不会全部都展示出来，只挑那些具有重要革新的功能说。</p><span id="more"></span><h3 id="redis2-6"><a href="#redis2-6" class="headerlink" title="redis2.6"></a>redis2.6</h3><p>发行于2012年，相比旧版，它新支持了以下功能：</p><ul><li>redis-server支持Lua脚本</li><li>键的过期时间可以精确到毫秒</li><li>slave节点提供只读功能</li><li>新指令：<code>bitcount</code>、<code>bittop</code>（操作位图用的）</li><li>基于浮点数的自增功能：<code>incrbyfloat</code>、<code>hincrbyfloat</code></li><li>redis-cli支持用<code>--eval</code>参数实现Lua脚本</li></ul><h3 id="redis2-8"><a href="#redis2-8" class="headerlink" title="redis2.8"></a>redis2.8</h3><p>发行于2013年11月，新功能如下：</p><ul><li>支持部分主从复制，降低了由于网络问题导致频繁全量复制RDB时对系统造成的压力</li><li>支持IPv6</li><li>支持<code>config rewrite</code>指令可以将<code>config set</code>持久化到redis的配置文件中</li><li>新指令：pubsub（给订阅发布功能用的）</li><li>redis哨兵v2</li></ul><h3 id="redis3-0"><a href="#redis3-0" class="headerlink" title="redis3.0"></a>redis3.0</h3><p>发行于2015年4月，新功能如下：</p><ul><li>支持redis集群（<code>Redis Cluster</code>），这是redis官方的集群方案，在这之前，有两种方案也可以实现redis的集群：<code>Codis</code> 和<code>Twemproxy</code></li><li>LRU算法大幅提升</li><li><code>migrate</code>连接缓存，大幅提升键的迁移速度</li><li><code>incr</code>、<code>bitcount</code>命令性能提升</li></ul><h3 id="redis3-2"><a href="#redis3-2" class="headerlink" title="redis3.2"></a>redis3.2</h3><ul><li>新增GEO功能</li><li>对redis底层字符串（<code>SDS</code>）在速度和节省空间上都做了相关优化</li><li>支持用<code>upstart</code>或<code>systemd</code>管理redis进程</li><li>新的list编码类型：quicklist</li><li>新增<code>hstrlen</code>指令、增强<code>debug</code>、<code>spop</code>指令（支持的参数更多了）、增强<code>cluster nodes</code>指令（提速）</li><li>新RDB格式（兼容旧版），提升了RDB文件的加载速度</li><li>Jemalloc更新至4.0.3版本</li></ul><h3 id="redis4-0"><a href="#redis4-0" class="headerlink" title="redis4.0"></a>redis4.0</h3><ul><li>提供模块功能，方便第三方拓展功能</li><li>PSYNC2.0：优化了之前版本中，主从节点切换必然引起全量复制的问题</li><li>支持LFU，并对已有缓存过期算法进行了优化</li><li>提供非阻塞式的<code>del</code>和<code>flushall</code>&#x2F;<code>flushdb</code>功能，解决了删除大key时可能会造成redis阻塞的问题</li><li>提供RDB-AOF混合持久化格式，充分结合了RDB和AOF的优点</li><li>新增<code>memory</code>指令，使内存监控更加全面</li><li>Redis Cluster兼容NAT和docker</li></ul><h2 id="一、五种数据结构"><a href="#一、五种数据结构" class="headerlink" title="一、五种数据结构"></a>一、五种数据结构</h2><p>redis有五种数据结构，在操作它们时会使用到不同的api，在实际开发中，这些api也是离我们开发最近的一块内容，所以熟练掌握常用的api对我们非常有用。</p><h3 id="字符串（string）"><a href="#字符串（string）" class="headerlink" title="字符串（string）"></a>字符串（string）</h3><p>最基本的k-v格式，value是一个字符串，它的内部编码如下：</p><p><img src="http://myblog.sharemer.com/2021/05/18/20210518-1-1.png?imageView2/0/w/500" alt="图1-1"></p><p>指令集：</p><table><thead><tr><th align="left">指令</th><th align="left">解释</th><th align="left">时间复杂度</th></tr></thead><tbody><tr><td align="left"><code>set</code> [k] [v]</td><td align="left">最常用的质量，写入一对k-v</td><td align="left">O(1)</td></tr><tr><td align="left"><code>mset</code> [k1] [v1] [k2] [v2] …</td><td align="left">批量写入k-v</td><td align="left">O(k) k&#x3D;键数</td></tr><tr><td align="left"><code>set</code> [k] [v] <code>nx</code></td><td align="left">只有当key不存在时才会写入成功（新增）</td><td align="left">O(1)</td></tr><tr><td align="left"><code>setnx</code> [k] [v]</td><td align="left">作用等同于上面一条</td><td align="left">O(1)</td></tr><tr><td align="left"><code>set</code> [k] [v] <code>xx</code></td><td align="left">只有当key存在时才会写入成功（修改）</td><td align="left">O(1)</td></tr><tr><td align="left"><code>setxx</code> [k] [v]</td><td align="left">作用等同于上面一条</td><td align="left">O(1)</td></tr><tr><td align="left"><code>get</code> [k]</td><td align="left">取value值</td><td align="left">O(1)</td></tr><tr><td align="left"><code>del</code> [k1] [k2] …</td><td align="left">删除掉k-v数据，支持传多个key</td><td align="left">O(k) k&#x3D;键数</td></tr><tr><td align="left"><code>incr</code> [k]</td><td align="left">自增</td><td align="left">O(1)</td></tr><tr><td align="left"><code>decr</code> [k]</td><td align="left">自减</td><td align="left">O(1)</td></tr><tr><td align="left"><code>incrby</code> [k] [num]</td><td align="left">自增指定的数字</td><td align="left">O(1)</td></tr><tr><td align="left"><code>decrby</code> [k] [num]</td><td align="left">自减指定的数字</td><td align="left">O(1)</td></tr><tr><td align="left"><code>incrbyfloat</code> [k] [num]</td><td align="left">自增指定的数字（针对浮点数自增）</td><td align="left">O(1)</td></tr><tr><td align="left"><code>append</code> [k] [v]</td><td align="left">往原有字符串尾部追加内容</td><td align="left">O(1)</td></tr><tr><td align="left"><code>strlen</code> [k]</td><td align="left">获取value的长度（单位：字节）</td><td align="left">O(1)</td></tr><tr><td align="left"><code>setrange</code> [k] [offset] [v]</td><td align="left">字符替换，offset为被替换字符的位置</td><td align="left">O(1)</td></tr><tr><td align="left"><code>getrange</code> [k] [start] [end]</td><td align="left">获取部分字符串，截取区间：[start, end]</td><td align="left">O(n) n&#x3D;字符串长度</td></tr></tbody></table><p>适用范围：做基本的分布式缓存、分布式锁、计数&#x2F;限流、保存集群下的登录状态等。</p><h3 id="列表（list）"><a href="#列表（list）" class="headerlink" title="列表（list）"></a>列表（list）</h3><p>顾名思义，一个key对应了一个列表，列表内保存着多个value，其内部结构和编码如下：</p><p><img src="http://myblog.sharemer.com/2021/05/18/20210518-1-2.png?imageView2/0/w/560" alt="图1-2"></p><p>其中<code>list-max-ziplist-entries</code>和<code>list-max-ziplist-value</code>都是redis的配置项。</p><p>指令集：</p><table><thead><tr><th align="left">指令</th><th align="left">解释</th><th align="left">时间复杂度</th></tr></thead><tbody><tr><td align="left"><code>rpush</code> [k] [v1] [v2] …</td><td align="left">从列表的右边插入元素</td><td align="left">O(k) k&#x3D;插入元素数</td></tr><tr><td align="left"><code>lpush</code> [k] [v1] [v2] …</td><td align="left">从列表的左边插入元素</td><td align="left">同上</td></tr><tr><td align="left"><code>linsert</code> [k] <code>before/after</code> [vx] [vn]</td><td align="left">向vx的前或后面插入vn</td><td align="left">O(n) n&#x3D;vx与表头&#x2F;尾的距离</td></tr><tr><td align="left"><code>lrange</code> [k] [start] [end]</td><td align="left">输出指定范围的列表，范围：[start, end]，start&#x2F;end为下标值</td><td align="left">O(s+n) s&#x3D;start偏移量；n&#x3D;start~end的范围</td></tr><tr><td align="left"><code>lindex</code> [k] [index]</td><td align="left">获取指定下标的value</td><td align="left">O(n) n&#x3D;index偏移量</td></tr><tr><td align="left"><code>llen</code> [k]</td><td align="left">获取列表长度</td><td align="left">O(1)</td></tr><tr><td align="left"><code>lpop</code> [k]</td><td align="left">弹出左边第一个元素</td><td align="left">O(1)</td></tr><tr><td align="left"><code>rpop</code> [k]</td><td align="left">弹出右边第一个元素</td><td align="left">O(1)</td></tr><tr><td align="left"><code>blpop</code> [k] [timeout]</td><td align="left">阻塞式弹出左边第一个元素，timout非必须，当列表中没有元素时阻塞</td><td align="left">O(1)</td></tr><tr><td align="left"><code>brpop</code> [k] [timeout]</td><td align="left">阻塞式弹出右边第一个元素，timout非必须，当列表中没有元素时阻塞</td><td align="left">O(1)</td></tr><tr><td align="left"><code>lrem</code> [num] [v]</td><td align="left">删除v包括其前后的元素，这取决于num：num&gt;0，从左至右删除最多num个元素；num&lt;0，从右至左删除最多|count|个元素；num&#x3D;0，全部删除</td><td align="left">O(n) n&#x3D;列表长度</td></tr><tr><td align="left"><code>ltrim</code> [k] [start] [end]</td><td align="left">只保留[start, end]区间的数据</td><td align="left">O(n) n&#x3D;start~end的长度</td></tr><tr><td align="left"><code>lset</code> [k] [index] [v]</td><td align="left">修改指定下标中的元素</td><td align="left">O(n) n&#x3D;index偏移量</td></tr></tbody></table><p>如你所见，我们可以利用lpush和brpop来实现一个消息队列：</p><p><img src="http://myblog.sharemer.com/2021/05/18/20210518-1-3.png?imageView2/0/w/860" alt="图1-3"></p><p>除此之外，我们可以利用它来保存一个信息id列表，然后用<code>lrange</code>指令实现列表的高效分页，拿到单页id集合后再去批量查询这些id对应的详细信息，最终聚合成完整信息输出给客户端，这样既节约资源，又便于我们设计和复用缓存结构。（ps：根据lrange的复杂度不难推断出在数据量庞大的情况下会影响其性能，这时可以尝试大key拆分成小key，比如可以利用CRC32(value) % key_num来做数据拆分，当然也可以利用redis3.2推出的<code>quicklist</code>内部编码实现，它对大key的性能一样很高）</p><h3 id="集合（set）"><a href="#集合（set）" class="headerlink" title="集合（set）"></a>集合（set）</h3><p>跟list一样，一个key对应一堆value，但是set不允许有重复的value，同时它也是无序的，其内部结构和编码如下：</p><p><img src="http://myblog.sharemer.com/2021/05/18/20210518-1-4.png?imageView2/0/w/560" alt="图1-4"></p><p>其中<code>set-max-intset-entrie</code>可配。</p><p>指令集：</p><table><thead><tr><th align="left">指令</th><th align="left">解释</th><th align="left">时间复杂度</th></tr></thead><tbody><tr><td align="left"><code>sadd</code> [k] [v1] [v2] …</td><td align="left">添加元素</td><td align="left">O(k) k&#x3D;插入元素数</td></tr><tr><td align="left"><code>srem</code> [k] [v1] [v2] …</td><td align="left">删除元素</td><td align="left">O(k) k&#x3D;删除元素数</td></tr><tr><td align="left"><code>scard</code> [k]</td><td align="left">获取元素总数</td><td align="left">O(1)</td></tr><tr><td align="left"><code>sismember</code> [k] [v]</td><td align="left">v是否在集合k中</td><td align="left">O(1)</td></tr><tr><td align="left"><code>srandmember</code> [k] [num]</td><td align="left">从集合k中随机返回num个元素</td><td align="left">O(k) k&#x3D;num</td></tr><tr><td align="left"><code>spop</code> [k] [num]</td><td align="left">从集合k中随机弹出num个元素</td><td align="left">O(1)</td></tr><tr><td align="left"><code>smembers</code> [k]</td><td align="left">获取所有元素（结果无序）</td><td align="left">O(n) n&#x3D;元素总数</td></tr><tr><td align="left"><code>sscan</code> [k]</td><td align="left">迭代出所有元素，类似下面<code>scan</code>的用法</td><td align="left">同上</td></tr><tr><td align="left"><code>sinter</code> [k1] [k2] …</td><td align="left">求多个集合的交集</td><td align="left">O(m*k) k&#x3D;多个集合中最少元素数，m&#x3D;集合数</td></tr><tr><td align="left"><code>sinterstore</code> [dk] [k1] [k2] …</td><td align="left">将算出的交集存入dk中</td><td align="left">同上</td></tr><tr><td align="left"><code>suinon</code> [k1] [k2] …</td><td align="left">求多个集合的并集</td><td align="left">O(k) k&#x3D;多个集合的总元素数</td></tr><tr><td align="left"><code>suinonstore</code> [dk] [k1] [k2] …</td><td align="left">将算出的并集存入dk中</td><td align="left">同上</td></tr><tr><td align="left"><code>sdiff</code> [k1] [k2] …</td><td align="left">求多个集合的差集</td><td align="left">同上</td></tr><tr><td align="left"><code>sdiffstore</code> [dk] [k1] [k2] …</td><td align="left">将算出的差集存入dk中</td><td align="left">同上</td></tr></tbody></table><p>相比list，set并不能用来分页以及展示一个列表，因为它是无序的，但我们仍然可以为它找到合适的应用场景，比如可以用它来存储用户的喜好标签，便于利用取<code>交集</code>、<code>差集</code>等功推荐同好；也可以存储某些权益信息，比如某大V粉丝集合，利用<code>sismember</code>指令可以很快得出一个用户是否是另一个用户的粉丝（得出按钮展示“已关注”还是“未关注”），这同样可以计算一个大V与另一个大V的粉丝重合度。</p><h3 id="有序集合（zset）"><a href="#有序集合（zset）" class="headerlink" title="有序集合（zset）"></a>有序集合（zset）</h3><p>相比set，zset可以进行灵活排序、分页等操作，同样它也不允许有重复元素，其内部结构和编码如下：</p><p><img src="http://myblog.sharemer.com/2021/05/18/20210518-1-5.png?imageView2/0/w/580" alt="图1-5"></p><p>其中<code>zset-max-ziplist-entries</code>和<code>zset-max-ziplist-value</code>都是redis的配置项。</p><p>指令集：</p><table><thead><tr><th align="left">指令</th><th align="left">解释</th><th align="left">时间复杂度</th></tr></thead><tbody><tr><td align="left"><code>zadd</code> [k] [s1] [v1] [s2] [v2] …</td><td align="left">添加成员</td><td align="left">O(k*log(n)) k&#x3D;插入个数，n&#x3D;总个数</td></tr><tr><td align="left"><code>zscore</code> [k] [v]</td><td align="left">获取某成员分数</td><td align="left">O(1)</td></tr><tr><td align="left"><code>zcard</code> [k]</td><td align="left">获取元素总数</td><td align="left">O(1)</td></tr><tr><td align="left"><code>zcount</code> [k] [min] [max]</td><td align="left">获取score值在[min, max]区间的元素总数</td><td align="left">O(log(n)) n&#x3D;总个数</td></tr><tr><td align="left"><code>zincrby</code> [k] [num] [v]</td><td align="left">给v加num分</td><td align="left">同上</td></tr><tr><td align="left"><code>zrank</code> [k] [v]</td><td align="left">返回v的正序排名</td><td align="left">同上</td></tr><tr><td align="left"><code>zrevrank</code> [k] [v]</td><td align="left">返回v的倒序排名</td><td align="left">同上</td></tr><tr><td align="left"><code>zrem</code> [k] [v1] [v2] …</td><td align="left">删除元素</td><td align="left">O(k*log(n)) k&#x3D;删除个数，n&#x3D;总个数</td></tr><tr><td align="left"><code>zscan</code> [k]</td><td align="left">迭代出[k]里所有的元素，类似下面<code>scan</code>的用法</td><td align="left">O(N) N&#x3D;总个数</td></tr><tr><td align="left"><code>zrange</code> [k] [start] [end] <code>withsocres</code></td><td align="left">按分数从小到大返回[start, end]区间内的数据（score+v都会返回）</td><td align="left">O(log(n)+k) k&#x3D;获取数；n&#x3D;总个数</td></tr><tr><td align="left"><code>zrevrange</code> [k] [start] [end] <code>withscores</code></td><td align="left">按分数从大到小返回[start, end]区间内的数据（score+v都会返回）</td><td align="left">同上</td></tr><tr><td align="left"><code>zrangebyscore</code> [k] [min] [max] <code>withscores</code></td><td align="left">返回score值在[min, max]区间的数据（按从小到大排序）</td><td align="left">同上</td></tr><tr><td align="left"><code>zrevrangebyscore</code> [k] [max] [min] <code>withscores</code></td><td align="left">返回score值在[max, min]区间的数据（按从大到小排序）</td><td align="left">同上</td></tr><tr><td align="left"><code>zremrangebyrank</code> [k] [start] [end]</td><td align="left">删除[start, end]名次区间内的数据</td><td align="left">O(log(n)+k) k&#x3D;删除数；n&#x3D;总个数</td></tr><tr><td align="left"><code>zremrangebyscore</code> [k] [min] [max]</td><td align="left">删除分数在[min, max]区间内的数据</td><td align="left">同上</td></tr><tr><td align="left"><code>zinterstore</code> [dk] [num] [k1] [k2] …</td><td align="left">将k1、k2等集合的交集存入dk中</td><td align="left">O(n<em>k)+O(m</em>log(m)) n&#x3D;成员数最小集合的成员数，k&#x3D;参与取交集的集合数，m&#x3D;结果集中的成员数</td></tr><tr><td align="left"><code>zunionstore</code> [dk] [num] [k1] [k2] …</td><td align="left">将k1、k2等集合的并集存入dk中</td><td align="left">O(n)+O(m*log(m)) n&#x3D;所有集合成员数之和，m&#x3D;结果集中的成员数</td></tr></tbody></table><p>作为一个支持正序、倒序、分页的集合，它特别适合做一些排行榜类的需求，这样可以很方便的获取名次、分数等关键信息；</p><p>除此之外也可以做一些含排序操作的列表页：比如b站的个人空间中up主的稿件列表，可以按照时间、播放量、收藏量来进行正序和倒序展示，同时还支持分页，那么我们就可以建设3个统计维度的有序集合（分别以投稿时间、播放量、收藏量做score），value保存稿件id，然后按照排序类型、页码查询出单页数据，再利用单页的id集合批量查询稿件详细信息，最终将这些信息聚合成接口返回给客户端即可。</p><h3 id="哈希（hash）"><a href="#哈希（hash）" class="headerlink" title="哈希（hash）"></a>哈希（hash）</h3><p>hash类型的数据本身就是一个k-v结构，也就是一个redis key对应多个k-v，结构和内部编码如下：</p><p><img src="http://myblog.sharemer.com/2021/05/18/20210518-1-6.png?imageView2/0/w/590" alt="图1-6"></p><p>其中<code>hash-max-ziplist-entries</code>和<code>hash-max-ziplist-value</code>都是redis的配置项。</p><p>指令集：</p><table><thead><tr><th align="left">指令</th><th align="left">解释</th><th align="left">时间复杂度</th></tr></thead><tbody><tr><td align="left"><code>hset</code> [k] [KEY] [VALUE]</td><td align="left">为[k]添加一对[KEY]-[VALUE]</td><td align="left">O(1)</td></tr><tr><td align="left"><code>hget</code> [k] [KEY]</td><td align="left">获取[k]里[KEY]对应的value</td><td align="left">O(1)</td></tr><tr><td align="left"><code>hdel</code> [k] [KEY1] [KEY2] …</td><td align="left">删除[k]里的某些[KEY]</td><td align="left">O(k) k&#x3D;被删KEY的个数</td></tr><tr><td align="left"><code>hlen</code> [k]</td><td align="left">获取[k]里[KEY]的数量</td><td align="left">O(1)</td></tr><tr><td align="left"><code>hgetall</code> [k]</td><td align="left">获取[k]里所有的[KEY]-[VALUE]</td><td align="left">O(n) n&#x3D;KEY数</td></tr><tr><td align="left"><code>hscan</code> [k]</td><td align="left">迭代的方式获取[k]里所有的[KEY]-[VALUE]，用法跟后面的<code>scan</code>类似</td><td align="left">O(n) n&#x3D;单次迭代结果数</td></tr><tr><td align="left"><code>hmget</code> [k] [KEY1] [KEY2] …</td><td align="left">批量获取[k]里一些[KEY]的[VALUE]</td><td align="left">O(k) k&#x3D;获取的KEY数</td></tr><tr><td align="left"><code>hmset</code> [k] [KEY1] [VALUE1] [KEY2] [VALUE2] …</td><td align="left">为[k]添加多个[KEY]-[VALUE]</td><td align="left">O(k) k&#x3D;插入的KEY数</td></tr><tr><td align="left"><code>hexists</code> [k] [KEY]</td><td align="left">判断[k]内是否存在[KEY]键</td><td align="left">O(1)</td></tr><tr><td align="left"><code>hkeys</code> [k]</td><td align="left">获取[k]内所有的[KEY]</td><td align="left">O(n) n&#x3D;KEY数</td></tr><tr><td align="left"><code>hvals</code> [k]</td><td align="left">获取[k]内所有的[VALUE]</td><td align="left">同上</td></tr><tr><td align="left"><code>hsetnx</code> [k] [KEY] [VALUE]</td><td align="left">当[VALUE]不存在时才设置成功</td><td align="left">O(1)</td></tr><tr><td align="left"><code>hincrby</code> [k] [KEY] [num]</td><td align="left">对[k]内[KEY]的值自增num</td><td align="left">O(1)</td></tr><tr><td align="left"><code>hincrbyfloat</code> [k] [KEY] [num]</td><td align="left">对[k]内[KEY]的浮点值自增num</td><td align="left">O(1)</td></tr><tr><td align="left"><code>hstrlen</code> [k] [KEY]</td><td align="left">获取[k]内[KEY]对应[VALUE]的length</td><td align="left">O(1)</td></tr></tbody></table><p>用处主要是用来结构化的存储一些数据，比如可以把一个对象各个属性和属性值当成hash结构缓存入redis。</p><h2 id="二、通用指令"><a href="#二、通用指令" class="headerlink" title="二、通用指令"></a>二、通用指令</h2><p>下面是一些通用的指令，不同于上面的指令，这些指令不会针对某些数据结构生效，而是全局有效。</p><table><thead><tr><th align="left">指令</th><th align="left">解释</th><th align="left">时间复杂度</th></tr></thead><tbody><tr><td align="left"><code>keys</code> [xx]*</td><td align="left">获取所有前缀为“xx”的key，若直接为<code>keys *</code>就是获取所有key，重操作</td><td align="left">O(n) n&#x3D;key总数</td></tr><tr><td align="left"><code>scan</code> [cursor] [xx]* [count]</td><td align="left">非阻塞式获取所有key，相比<code>keys</code>，<code>scan</code>是利用[cursor]做游标进行迭代的，[count]则是返回的条数，默认10条，每次迭代结果中会返回下次迭代所需的[cursor]，这样就可以一步步迭代出来所有的key了，它不是一个重操作，也就不会长阻塞redis线程</td><td align="left">O(n) n&#x3D;单次迭代结果数</td></tr><tr><td align="left"><code>dbsize</code></td><td align="left">获取当前db内的key总数</td><td align="left">O(1)</td></tr><tr><td align="left"><code>exists</code> [k1] [k2] …</td><td align="left">是否存在[k1]、[k2]等键</td><td align="left">O(n) n&#x3D;查看key的个数</td></tr><tr><td align="left"><code>del</code> [k1] [k2] …</td><td align="left">删除[k1]、[k2]等键</td><td align="left">O(n) n&#x3D;删除key的个数</td></tr><tr><td align="left"><code>expire</code> [k] [time]</td><td align="left">让[k]time秒后过期</td><td align="left">O(1)</td></tr><tr><td align="left"><code>persist</code> [k]</td><td align="left">取消[k]的过期时间</td><td align="left">O(1)</td></tr><tr><td align="left"><code>ttl</code> [k]</td><td align="left">返回[k]的剩余过期时间，若返回-1，说明没设过期时间，-2表示[k]不存在，&gt;0表示剩余的时间，单位秒</td><td align="left">O(1)</td></tr><tr><td align="left"><code>type</code> [k]</td><td align="left">查看[k]对应值的类型（string、set、zset、list、hash）</td><td align="left">O(1)</td></tr><tr><td align="left"><code>object encoding</code> [k]</td><td align="left">查看[k]的内部编码（int、embstr、raw、ziplist、hashtable、linkedlist、skiplist、intset）</td><td align="left">O(1)</td></tr><tr><td align="left"><code>rename</code> [k1] [k2]</td><td align="left">将[k1]重命名为[k2]</td><td align="left">O(1)</td></tr><tr><td align="left"><code>renamenx</code> [k1] [k2]</td><td align="left">当k2不存在时才能重命名成功</td><td align="left">O(1)</td></tr><tr><td align="left"><code>randomkey</code></td><td align="left">随机返回一个key</td><td align="left">O(1)</td></tr><tr><td align="left"><code>dump</code> [k]</td><td align="left">将[k]的值dump成RDB格式的数据</td><td align="left">O(1)+O(M*N) M&#x3D;k对应的对象数；N&#x3D;对象平均大小，对于值很小的情况，复杂度趋近O(1)</td></tr><tr><td align="left"><code>restore</code> [k] [ttl] [v]</td><td align="left">跟dump结合使用，[v]&#x3D;dump出的数据，适用于数据转移（比如将redis1中的[k]转移到redis2中）；[ttl]为过期时间，若为0，则表示没有过期时间（这种迁移方式非原子性）</td><td align="left">同上，但有序集合为O(N * M * log(N))</td></tr><tr><td align="left"><code>migrate</code> [ip] [port] &#96;key</td><td align="left">“”<code>[db] [timeout]</code>copy<code>replace</code>keys&#96; [k1] [k2]…</td><td align="left">数据迁移（这个命令实际上是在源实例中执行一次dump+del，在目标实例中执行一次restore），[ip]+[port]为迁移的目标机器，&#96;key</td></tr><tr><td align="left"><code>select</code> [db]</td><td align="left">选择redis数据库，db为数据库下标（一般常为0）redis3中已弱化db功能，redis cluster更是不支持多db，默认0号db</td><td align="left">O(1)</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言：Redis各版本重大更新&quot;&gt;&lt;a href=&quot;#前言：Redis各版本重大更新&quot; class=&quot;headerlink&quot; title=&quot;前言：Redis各版本重大更新&quot;&gt;&lt;/a&gt;前言：Redis各版本重大更新&lt;/h2&gt;&lt;p&gt;截至2021年5月，Redis的稳定版本已经更新到了6.2，所以这里我想整理一下redis自发布以来每一个大版本的重要更新，当然我不会全部都展示出来，只挑那些具有重要革新的功能说。&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="redis" scheme="http://example.com/tags/redis/"/>
    
    <category term="缓存技术" scheme="http://example.com/tags/%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>插入式注解处理器的一次使用经历</title>
    <link href="http://example.com/2021/02/08/%E6%8F%92%E5%85%A5%E5%BC%8F%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8%E7%BB%8F%E5%8E%86/"/>
    <id>http://example.com/2021/02/08/%E6%8F%92%E5%85%A5%E5%BC%8F%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8%E7%BB%8F%E5%8E%86/</id>
    <published>2021-02-08T08:21:00.000Z</published>
    <updated>2023-12-03T11:05:05.949Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>插入式注解处理器在《深入理解Java虚拟机》一书中有一些介绍（前端编译篇有提到），但一直没有机会使用，直到碰到这个需求，觉得再合适不过了，就简单用了一下，这里做个记录。</p></blockquote><h2 id="一、需求"><a href="#一、需求" class="headerlink" title="一、需求"></a>一、需求</h2><p>我们为公司提供了一套通用的JAVA基础组件包，组件包内有不同的模块，比如熔断模块、负载均模块、rpc模块等等，这些模块均会被打成jar包，然后发布到公司的内部代码仓库中，供其他人引入使用。</p><p>这份代码会不断的迭代，我们希望可以通过<code>promethus</code>来监控现在公司内使用各版本代码库的比例，希望达到的效果图如下：</p><p><img src="https://myblog.sharemer.com/2021/02/08/20210208-1.png?imageView2/0/w/600" alt="图1-1"></p><p>我们希望看到每一个版本的使用率，这有利于我们做版本兼容，必要的时候可以对古早版本使用者溯源。</p><span id="more"></span><h2 id="二、问题"><a href="#二、问题" class="headerlink" title="二、问题"></a>二、问题</h2><p>需求似乎很简单，但真要获取自身的jar版本号还是挺麻烦的，有个比较简单但阴间的办法，就是给每一个组件都加上当前的jar版本号，写到配置文件里或者直接设置成常量，这样上报promethus时就可以直接获取到jar包版本号了，这个方法虽然可以解决问题，但每次迭代版本都要跟着改一遍所有组件包的版本号数据，过于麻烦。</p><p>有没有更好的解决办法呢？比如我们可不可以在gradle打包构建时拿到jar包的版本号，然后注入到每个组件中去呢？就像lombok那样，不需要写get、set方法，只需要加个注解标记就可以自动注入get、set方法。</p><p>比如我们可以给每个组件定义一个空常量，加上自定义的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TrisceliVersion</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">version</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure><p>然后像lombok生成set&#x2F;get方法那样注入真正的版本号：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TrisceliVersion</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">version</span> <span class="operator">=</span> <span class="string">&quot;1.0.31-SNAPSHOT&quot;</span>;</span><br></pre></td></tr></table></figure><p>参考lombok的实现，这其实是可以做到的，下面来看解决方案。</p><h2 id="三、解决"><a href="#三、解决" class="headerlink" title="三、解决"></a>三、解决</h2><p>java中解析一个注解的方式主要有两种：编译期扫描、运行期反射，这是lombok <code>@Setter</code>的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Setter &#123;</span><br><span class="line">  <span class="comment">// 略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>@Setter</code>的<code>Retention</code>是<code>SOURCE</code>类型的，也就是说这个注解只在编译期有效，它甚至不会被编入class文件，所以lombok无疑是第一种解析方式，那用什么方式可以在编译期就让注解被解析到并执行我们的解析代码呢？答案就是定义插入式注解处理器（通过JSR-269提案定义的<code>Pluggable Annotation Processing API</code>实现）</p><p>插入式注解处理器的触发点如下图所示：</p><p><img src="https://myblog.sharemer.com/2021/02/08/20210208-3-1.png?imageView2/0/w/950" alt="图3-1"></p><p>也就是说插入式注解处理器可以帮助我们在编译期修改抽象语法树（AST）！所以现在我们只需要自定义一个这样的处理器，然后其内部拿到jar版本信息（因为是编译期，可以找到源码的path，源码里随便搞个文件存放版本号，然后用java io读取进来即可），再将注解对应语法树上的常量值设置成jar包版本号，语法树变了，最终生成的字节码也会跟着变，这样就实现了我们想在编译期给常量version注入值的愿望。</p><p>自定义一个插入式注解处理器也很简单，首先要将自己的注解定义出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span> <span class="comment">//只在编译期有效，最终不会打进class文件中</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD&#125;)</span> <span class="comment">//仅允许作用于类属性之上</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TrisceliVersion &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义一个继承了<code>AbstractProcessor</code>的处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> AbstractProcessor&#125; 就属于 Pluggable Annotation Processing API</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrisceliVersionProcessor</span> <span class="keyword">extends</span> <span class="title class_">AbstractProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JavacTrees javacTrees;</span><br><span class="line">    <span class="keyword">private</span> TreeMaker treeMaker;</span><br><span class="line">    <span class="keyword">private</span> ProcessingEnvironment processingEnv;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化处理器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> processingEnv 提供了一系列的实用工具</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ProcessingEnvironment processingEnv)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.init(processingEnv);</span><br><span class="line">        <span class="built_in">this</span>.processingEnv = processingEnv;</span><br><span class="line">        <span class="built_in">this</span>.javacTrees = JavacTrees.instance(processingEnv);</span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> ((JavacProcessingEnvironment) processingEnv).getContext();</span><br><span class="line">        <span class="built_in">this</span>.treeMaker = TreeMaker.instance(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> SourceVersion <span class="title function_">getSupportedSourceVersion</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SourceVersion.latest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;String&gt; <span class="title function_">getSupportedAnnotationTypes</span><span class="params">()</span> &#123;</span><br><span class="line">        HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        set.add(TrisceliVersion.class.getName()); <span class="comment">// 支持解析的注解</span></span><br><span class="line">        <span class="keyword">return</span> set;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (TypeElement t : annotations) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Element e : roundEnv.getElementsAnnotatedWith(t)) &#123; <span class="comment">// 获取到给定注解的element（element可以是一个类、方法、包等）</span></span><br><span class="line">                <span class="comment">// JCVariableDecl为字段/变量定义语法树节点</span></span><br><span class="line">                JCTree.<span class="type">JCVariableDecl</span> <span class="variable">jcv</span> <span class="operator">=</span> (JCTree.JCVariableDecl) javacTrees.getTree(e);</span><br><span class="line">                <span class="type">String</span> <span class="variable">varType</span> <span class="operator">=</span> jcv.vartype.type.toString();</span><br><span class="line">                <span class="keyword">if</span> (!<span class="string">&quot;java.lang.String&quot;</span>.equals(varType)) &#123; <span class="comment">// 限定变量类型必须是String类型，否则抛异常</span></span><br><span class="line">                    printErrorMessage(e, <span class="string">&quot;Type &#x27;&quot;</span> + varType + <span class="string">&quot;&#x27;&quot;</span> + <span class="string">&quot; is not support.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                jcv.init = treeMaker.Literal(getVersion()); <span class="comment">// 给这个字段赋值，也就是getVersion的返回值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 利用processingEnv内的Messager对象输出一些日志</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e element</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m error message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printErrorMessage</span><span class="params">(Element e, String m)</span> &#123;</span><br><span class="line">        processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, m, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getVersion</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取version，这里省略掉复杂的代码，直接返回固定值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;v1.0.1&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>定义好的处理器需要<code>SPI机制</code>被发现，所以需要定义<code>META.services</code>：</p><p><img src="https://myblog.sharemer.com/2021/02/08/20210208-3-2.png?imageView2/0/w/950" alt="图3-2"></p><h2 id="四、测试"><a href="#四、测试" class="headerlink" title="四、测试"></a>四、测试</h2><p>新建测试模块，引入刚才写好的代码包：</p><p><img src="https://myblog.sharemer.com/2021/02/08/20210208-3-3.png?imageView2/0/w/980" alt="图4-1"></p><p>这是Test类：</p><p><img src="https://myblog.sharemer.com/2021/02/08/20210208-4-2.png?imageView2/0/w/800" alt="图4-2"></p><p>现在我们只需要让gradle build一下，新得到的字节码中该字段就有值了：</p><p><img src="https://myblog.sharemer.com/2021/02/08/20210208-4-3.png?imageView2/0/w/800" alt="图4-3"></p><p>这只是<code>插入式注解处理器</code>功能的冰山一角，既然它可以通过修改抽象语法树来控制生成的字节码，那么自然就有人能充分利用其特性来实现一些很酷的插件，比如lombok，我们再也不用写诸如set&#x2F;get这种模板式的代码了，只要我们足够有创意，就可以让基于这一套API实现的插件在功能上有很大的发挥空间。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;插入式注解处理器在《深入理解Java虚拟机》一书中有一些介绍（前端编译篇有提到），但一直没有机会使用，直到碰到这个需求，觉得再合适不过了，就简单用了一下，这里做个记录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、需求&quot;&gt;&lt;a href=&quot;#一、需求&quot; class=&quot;headerlink&quot; title=&quot;一、需求&quot;&gt;&lt;/a&gt;一、需求&lt;/h2&gt;&lt;p&gt;我们为公司提供了一套通用的JAVA基础组件包，组件包内有不同的模块，比如熔断模块、负载均模块、rpc模块等等，这些模块均会被打成jar包，然后发布到公司的内部代码仓库中，供其他人引入使用。&lt;/p&gt;
&lt;p&gt;这份代码会不断的迭代，我们希望可以通过&lt;code&gt;promethus&lt;/code&gt;来监控现在公司内使用各版本代码库的比例，希望达到的效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://myblog.sharemer.com/2021/02/08/20210208-1.png?imageView2/0/w/600&quot; alt=&quot;图1-1&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们希望看到每一个版本的使用率，这有利于我们做版本兼容，必要的时候可以对古早版本使用者溯源。&lt;/p&gt;</summary>
    
    
    
    <category term="JVM" scheme="http://example.com/categories/JVM/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
    <category term="注解处理器" scheme="http://example.com/tags/%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>分布式任务调度系统-PowerJob</title>
    <link href="http://example.com/2020/09/03/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F-PowerJob/"/>
    <id>http://example.com/2020/09/03/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F-PowerJob/</id>
    <published>2020-09-03T04:12:00.000Z</published>
    <updated>2023-12-03T11:18:50.492Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在调研分布式任务如何选型，最终选择了比较年轻的<code>PowerJob</code>，下面会简单介绍下这个框架的使用以及它的运行流程。</p></blockquote><span id="more"></span><h2 id="一、选择PowerJob的原因"><a href="#一、选择PowerJob的原因" class="headerlink" title="一、选择PowerJob的原因"></a>一、选择PowerJob的原因</h2><h3 id="1-1：同类产品对比"><a href="#1-1：同类产品对比" class="headerlink" title="1.1：同类产品对比"></a>1.1：同类产品对比</h3><p><a href="https://www.yuque.com/powerjob/guidence/ztn4i5">官方文档</a>给出的同类产品对比图：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-1.png?imageView2/0/w/846" alt="表1"></p><blockquote><p>作者の人生经验：<a href="https://zhuanlan.zhihu.com/p/157614020">https://zhuanlan.zhihu.com/p/157614020</a></p></blockquote><h3 id="1-2：特点"><a href="#1-2：特点" class="headerlink" title="1.2：特点"></a>1.2：特点</h3><p>定制方面：代码较简单，易于理解和改造，比如我们就集成了自己的服务发现平台来管理powerjob服务端节点。</p><p>功能方面：很全面，我们能想到的功能它全部支持</p><p>体积方面：非常轻量，代码量少，而且不依赖外部乱七八糟的服务（比如zk），仅需要一个mysql即可</p><h3 id="1-3：成熟度"><a href="#1-3：成熟度" class="headerlink" title="1.3：成熟度"></a>1.3：成熟度</h3><p>产品上线仅3个月，已积累<code>1.8k</code>的star：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-2.png" alt="图1"></p><p>并且已有较大的公司和机构接入：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-3.png?imageView2/0/w/500" alt="图2"></p><h2 id="二、PowerJob的工作流程"><a href="#二、PowerJob的工作流程" class="headerlink" title="二、PowerJob的工作流程"></a>二、PowerJob的工作流程</h2><h3 id="2-1：基本概念：app、worker、job、server"><a href="#2-1：基本概念：app、worker、job、server" class="headerlink" title="2.1：基本概念：app、worker、job、server"></a>2.1：基本概念：app、worker、job、server</h3><p>app可以理解为我们的一个工程项目，worker可以理解成一个app的集群节点，而job则是一个任务（可以是简单的定时任务，也可以是复杂的MapReduce），它跟具体某个app对应，而一个app则可以拥有很多job，它们的关系如下：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-4.png?imageView2/0/w/600" alt="图3"></p><p>server即为PowerJob节点，主要负责任务的监听和派发，可以单点部署，也可以集群部署，它的工作流程详细参考<code>2.2</code>和<code>2.3</code></p><h3 id="2-2：app-server的绑定"><a href="#2-2：app-server的绑定" class="headerlink" title="2.2：app&amp;server的绑定"></a>2.2：app&amp;server的绑定</h3><p>首先，在worker里配置上所需的server节点信息（这些节点信息也可以从服务发现获取），在worker启动时会注册到server，此时server便拥有了所有app的worker信息：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-5.png?imageView2/0/w/1124" alt="图4"></p><p>这层绑定关系在worker们启动后即可确认，这时worker端会启动两个定时任务，一个是heartbeat，用来给server端发送心跳，这样server端即可知道对应app有多少个worker在运行了，另外一个是discovery，用来同步server端状态，如果有备份server，可以用来做高可用。</p><p>图里powerjob服务端是单点部署，这不高可用，下面来看下powerjob是如何实现服务高可用的。</p><h3 id="2-3：高可用"><a href="#2-3：高可用" class="headerlink" title="2.3：高可用"></a>2.3：高可用</h3><p>2.2的过程运转的不错，但是如果server端故障，那么所有的任务将直接终止无法执行，这是我们不愿意看到的，因此需要给powerjob备份一个节点，假设现在它有两个节点，那么当单点故障时，powerjob会通过discovery机制做故障转移：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-6.png?imageView2/0/w/1200" alt="图5"></p><p>我们目前基于集群部署，一般有3台机器，一台<code>master</code>，两台<code>slave</code>。</p><h3 id="2-4：server端的调度"><a href="#2-4：server端的调度" class="headerlink" title="2.4：server端的调度"></a>2.4：server端的调度</h3><p>说完了整体的绑定流程，下面来详细看下server端是如何轮询和派发任务的：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-7.png?imageView2/0/w/1024" alt="图6"></p><h3 id="2-5：部署顺序"><a href="#2-5：部署顺序" class="headerlink" title="2.5：部署顺序"></a>2.5：部署顺序</h3><ol><li>部署PowerJob的server端（这个一般情况下都预先部署好了）</li><li>编写自己的job类app项目，写好各类job，在自身配置文件里指定一个server来调度自己</li><li>前往PowerJob客户端注册该app信息</li><li>启动发布该app项目（此时app集群会跟对应的server绑定上）</li><li>在PowerJob客户端利用该app登录，将该app里的job配置上去（此时便可指定cron表达式、并发度、是否mapreduce之类的信息）</li></ol><p>经过上面的步骤，你在app内编写的job程序便可被对应的PowerJob的server调度到了，不过上面的过程是裸用powerjob时需要做的，现在已经被我们大仓简化了，具体用法会出使用文档。</p><h2 id="三、任务类型-验证"><a href="#三、任务类型-验证" class="headerlink" title="三、任务类型&amp;验证"></a>三、任务类型&amp;验证</h2><h3 id="3-1：如何定义PowerJob任务"><a href="#3-1：如何定义PowerJob任务" class="headerlink" title="3.1：如何定义PowerJob任务"></a>3.1：如何定义PowerJob任务</h3><p>任务类必须要实现powerjob提供的一些接口，它们继承关系图如下：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-8.png?imageView2/0/w/900" alt="图7"></p><p>业务方只需要继承（实现）这些类（接口）即可，powerjob在执行任务时会率先从spring上下文里获取实例，如果你没使用spring，那么powerjob就会利用反射机制来触发你的业务逻辑（这在下方具体实例中有所体现，表单里填写的是类的全限定名）。</p><h3 id="3-1：任务类型-单机任务"><a href="#3-1：任务类型-单机任务" class="headerlink" title="3.1：任务类型-单机任务"></a>3.1：任务类型-单机任务</h3><p>这种就是普通定期执行的任务，属于最常用最普通的任务，现在来做下测试，测试用例代码如下：</p><figure class="highlight java"><figcaption><span>代码块1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StandaloneProcessor</span> <span class="keyword">implements</span> <span class="title class_">BasicProcessor</span> &#123; <span class="comment">//实现BasicProcessor接口</span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ProcessResult <span class="title function_">process</span><span class="params">(TaskContext context)</span> &#123; <span class="comment">//核心触发逻辑</span></span><br><span class="line">        log.info(<span class="string">&quot;简单定时任务-触发！，参数是：&#123;&#125;&quot;</span>, context.getJobParams());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProcessResult</span>(<span class="literal">true</span>, context + <span class="string">&quot;: &quot;</span> + <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将我们的job发布，发布完成后在powerjob平台对应app下配置该任务的调度信息：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-9.png?imageView2/0/w/900" alt="图8"></p><p>配好之后就可以运行我们的job了，来看看日志平台的打印：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-10.png?imageView2/0/w/900" alt="图9"></p><h3 id="3-2：任务类型-广播任务"><a href="#3-2：任务类型-广播任务" class="headerlink" title="3.2：任务类型-广播任务"></a>3.2：任务类型-广播任务</h3><h4 id="3-2-1：广播任务改造"><a href="#3-2-1：广播任务改造" class="headerlink" title="3.2.1：广播任务改造"></a>3.2.1：广播任务改造</h4><p>将上面的任务改成广播模式：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-11.png?imageView2/0/w/900" alt="图10"></p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-12.png?imageView2/0/w/900" alt="图11"></p><p>其实就是由原先单机触发，广播给worker集群里每个节点都触发一次。</p><h4 id="3-2-2：广播模式接口实现"><a href="#3-2-2：广播模式接口实现" class="headerlink" title="3.2.2：广播模式接口实现"></a>3.2.2：广播模式接口实现</h4><p>实例代码如下：</p><figure class="highlight java"><figcaption><span>代码块2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BroadcastProcessorDemo</span> <span class="keyword">extends</span> <span class="title class_">BroadcastProcessor</span> &#123; <span class="comment">//继承BroadcastProcessor类</span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ProcessResult <span class="title function_">preProcess</span><span class="params">(TaskContext context)</span> <span class="keyword">throws</span> Exception &#123; <span class="comment">//在所有节点广播执行前执行，只会在一台机器执行一次</span></span><br><span class="line">        log.info(<span class="string">&quot;广播前，参数：&#123;&#125;&quot;</span>, context.getJobParams());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProcessResult</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ProcessResult <span class="title function_">process</span><span class="params">(TaskContext taskContext)</span> <span class="keyword">throws</span> Exception &#123; <span class="comment">//核心逻辑，会广播给所有节点并行处理</span></span><br><span class="line">        log.info(<span class="string">&quot;广播核心逻辑触发！参数：&#123;&#125;&quot;</span>, taskContext.getJobParams());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProcessResult</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ProcessResult <span class="title function_">postProcess</span><span class="params">(TaskContext context, List&lt;TaskResult&gt; taskResults)</span> <span class="keyword">throws</span> Exception &#123; <span class="comment">//在所有节点广播执行完成后执行，只会在一台机器执行一次</span></span><br><span class="line">        <span class="comment">//通知执行结果，有点类似下面要测试的MapReduce的reduce方法</span></span><br><span class="line">        log.info(<span class="string">&quot;广播任务执行完毕，reduce触发！TaskContext: &#123;&#125;，List&lt;TaskResult&gt;: &#123;&#125;&quot;</span>,</span><br><span class="line">            JSONObject.toJSONString(context), JSONObject.toJSONString(taskResults));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProcessResult</span>(<span class="literal">true</span>, <span class="string">&quot;success&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在powerjob设置该任务：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-13.png?imageView2/0/w/900" alt="图12"></p><p>运行结果如下：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-14.png?imageView2/0/w/900" alt="图13"></p><p>广播模式执行流程如下（可以跟下方的MapReduce模式坐下对比）：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-15.png?imageView2/0/w/900" alt="图14"></p><h3 id="3-3：任务类型-Map（大任务拆分）"><a href="#3-3：任务类型-Map（大任务拆分）" class="headerlink" title="3.3：任务类型-Map（大任务拆分）"></a>3.3：任务类型-Map（大任务拆分）</h3><p>map就是一次大的任务可以被拆分成细碎的小批次任务进行分布式执行，测试用例代码如下：</p><figure class="highlight java"><figcaption><span>代码块3</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapProcessorDemo</span> <span class="keyword">extends</span> <span class="title class_">MapProcessor</span> &#123; <span class="comment">//继承MapProcessor</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">batchSize</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">//单批发送数据量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">batchNum</span> <span class="operator">=</span> <span class="number">2</span>; <span class="comment">//一共2批，默认上限为200批，再多就要适当调整batchSize大小了</span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ProcessResult <span class="title function_">process</span><span class="params">(TaskContext context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (isRootTask()) &#123; <span class="comment">//如果是根任务（说明map刚被调度到），则触发任务拆分</span></span><br><span class="line">            log.info(<span class="string">&quot;根任务，需要做任务拆分~&quot;</span>);</span><br><span class="line">            List&lt;SubTask&gt; subTasks = Lists.newLinkedList();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; batchNum; j++) &#123;</span><br><span class="line">                <span class="type">SubTask</span> <span class="variable">subTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubTask</span>();</span><br><span class="line">                subTask.siteId = j;</span><br><span class="line">                subTask.itemIds = Lists.newLinkedList();</span><br><span class="line">                subTasks.add(subTask); <span class="comment">//批次入集合</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; batchSize; i++) &#123; <span class="comment">//内部id集合，这里只是举例，实际业务场景可以是从db里获取的业务id集合</span></span><br><span class="line">                    subTask.itemIds.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> map(subTasks, <span class="string">&quot;MAP_TEST_TASK&quot;</span>); <span class="comment">//最后调用map，触发这些批次任务的执行</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//子任务，说明批次已做过拆分，此时被调度到时会触发下方逻辑</span></span><br><span class="line">            <span class="type">SubTask</span> <span class="variable">subTask</span> <span class="operator">=</span> (SubTask) context.getSubTask(); <span class="comment">//直接从上下文对象里拿到批次对象</span></span><br><span class="line">            log.info(<span class="string">&quot;子任务，拿到的批次实体为：&#123;&#125;&quot;</span>, JSON.toJSONString(subTask));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProcessResult</span>(<span class="literal">true</span>, <span class="string">&quot;RESULT:true&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SubTask</span> &#123; <span class="comment">//定义批次实体（业务方可自由发挥）</span></span><br><span class="line">        <span class="keyword">private</span> Integer siteId; <span class="comment">//批次id</span></span><br><span class="line">        <span class="keyword">private</span> List&lt;Integer&gt; itemIds; <span class="comment">//批次内部所携带的id（可以是我们自己的业务id）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码意义注释已给出，发布完成后可在powerjob平台配置，如下：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-16.png?imageView2/0/w/900" alt="图15"></p><p>然后看下运行结果：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-17-1.png?imageView2/0/w/900" alt="图16"></p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-17.png?imageView2/0/w/900" alt="图17"></p><p>上面就是一次map任务触发的演示过程（注：被拆分的map子任务只要有一个失败，即认为整个map任务为失败状态，但不具备事务性）。</p><p>Map任务执行流程如下：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-18.png?imageView2/0/w/500" alt="图18"></p><h3 id="3-4：任务类型-MapReduce（大任务拆分与归并）"><a href="#3-4：任务类型-MapReduce（大任务拆分与归并）" class="headerlink" title="3.4：任务类型-MapReduce（大任务拆分与归并）"></a>3.4：任务类型-MapReduce（大任务拆分与归并）</h3><p>相比普通map，MapReduce在子任务执行完毕后可以知道它们的执行结果，并做出接下来的自定义逻辑处理，测试用例代码如下：</p><figure class="highlight java"><figcaption><span>代码块4</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapReduceProcessorDemo</span> <span class="keyword">extends</span> <span class="title class_">MapReduceProcessor</span> &#123; <span class="comment">//需要继承MapReduceProcessor</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">batchSize</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">batchNum</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ProcessResult <span class="title function_">process</span><span class="params">(TaskContext context)</span> &#123; <span class="comment">//该方法跟普通map方法实现一致，主要用来拆分子任务和执行子任务</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (isRootTask()) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;根任务，需要做任务拆分~&quot;</span>);</span><br><span class="line">            List&lt;SubTask&gt; subTasks = Lists.newLinkedList();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; batchNum; j++) &#123;</span><br><span class="line">                <span class="type">SubTask</span> <span class="variable">subTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubTask</span>();</span><br><span class="line">                subTask.siteId = j;</span><br><span class="line">                subTask.itemIds = Lists.newLinkedList();</span><br><span class="line">                subTasks.add(subTask); <span class="comment">//批次入集合</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; batchSize; i++) &#123;</span><br><span class="line">                    subTask.itemIds.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> map(subTasks, <span class="string">&quot;MAP_TEST_TASK&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">SubTask</span> <span class="variable">subTask</span> <span class="operator">=</span> (SubTask) context.getSubTask();</span><br><span class="line">            log.info(<span class="string">&quot;子任务，拿到的批次实体为：&#123;&#125;&quot;</span>, JSON.toJSONString(subTask));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProcessResult</span>(<span class="literal">true</span>, <span class="string">&quot;RESULT:true&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ProcessResult <span class="title function_">reduce</span><span class="params">(TaskContext context, List&lt;TaskResult&gt; taskResults)</span> &#123; <span class="comment">//相比普通map任务，多出reduce方法，这里将两个参数全部打印出来</span></span><br><span class="line">        log.info(<span class="string">&quot;子任务执行完毕，reduce触发！TaskContext: &#123;&#125;，List&lt;TaskResult&gt;: &#123;&#125;&quot;</span>,</span><br><span class="line">            JSONObject.toJSONString(context), JSONObject.toJSONString(taskResults));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProcessResult</span>(<span class="literal">true</span>, <span class="string">&quot;RESULT:true&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SubTask</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Integer siteId;</span><br><span class="line">        <span class="keyword">private</span> List&lt;Integer&gt; itemIds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码意义注释已给出，发布完成后可在powerjob平台配置，如下：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-19.png?imageView2/0/w/900" alt="图19"></p><p>现在看下运行结果：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-20.png?imageView2/0/w/900" alt="图20"></p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-21.png?imageView2/0/w/900" alt="图21"></p><p>MapReduce的运行流程如下：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-22.png?imageView2/0/w/900" alt="图22"></p><h3 id="3-5：工作流"><a href="#3-5：工作流" class="headerlink" title="3.5：工作流"></a>3.5：工作流</h3><p>工作量，顾名思义，遵循<code>任务A → 任务B → 任务C</code>这个流程，只需要在表单里选中下方选项即可将任务本身设置成一个工作流任务：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-23.png?imageView2/0/w/900" alt="图23"></p><p>需要注意的是，工作流有自己的调度触发器，因此后面框框即便填了CRON表达式，也不会生效。</p><p>现在让我们将前面实验中的所有任务都设置成工作流模式：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-24.png?imageView2/0/w/900" alt="图24"></p><p>现在去工作流编辑里编辑工作流触发顺序：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-25.png?imageView2/0/w/900" alt="图25"></p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-26.png?imageView2/0/w/900" alt="图26"></p><p>任务按照编排好的顺序，执行了下来。</p><p>现在我们把工作流改成下面这样：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-27.png" alt="图27"></p><p>触发顺序就成了下面这样：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-28.png?imageView2/0/w/900" alt="图28"></p><h2 id="四、定时类型-验证"><a href="#四、定时类型-验证" class="headerlink" title="四、定时类型&amp;验证"></a>四、定时类型&amp;验证</h2><h3 id="4-1：CRON表达式"><a href="#4-1：CRON表达式" class="headerlink" title="4.1：CRON表达式"></a>4.1：CRON表达式</h3><p>前面的例子均通过该方式触发，支持一般CRON表达式，但是不支持秒级任务（即便配置了每秒执行一次，实际执行却是<code>15s</code>一次，秒级任务可以通过<code>固定频率</code>或<code>固定延迟</code>来做~），由CRON表达式触发的定时任务，在任务本身超时的情况下，仍然保持对应频率执行，比如，我们让某个简单定时任务每1min执行一次，但实际运行的业务逻辑调成2min，系统调度频率如下：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-29.png?imageView2/0/w/900" alt="图29"></p><p>可以看到，即便是任务需要花费很长时间，任务也是按照每一分钟一次的频率调度，但接下来介绍的延时任务就不一样了。</p><h3 id="4-2：固定频率"><a href="#4-2：固定频率" class="headerlink" title="4.2：固定频率"></a>4.2：固定频率</h3><p>如果你需要让某个任务按照固定某个频率执行，可以尝试使用固定频率来做：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-30.png?imageView2/0/w/900" alt="图30"></p><p>来看下它的调度结果：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-31.png" alt="图31"></p><h3 id="4-3：固定延迟"><a href="#4-3：固定延迟" class="headerlink" title="4.3：固定延迟"></a>4.3：固定延迟</h3><p>如果你需要让某个任务按照固定某个频率延迟执行，沿用<code>4.1</code>的例子，现在配置成延迟任务：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-32.png?imageView2/0/w/900" alt="图32"></p><p>它的调度结果如下：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-33.png?imageView2/0/w/900" alt="图33"></p><p>可以看到，现在是2min调度一次，相比CRON和固定频率，这个调度是串行化的，后续的任务需要前面的任务执行完才可以执行。</p><h2 id="五、其他"><a href="#五、其他" class="headerlink" title="五、其他"></a>五、其他</h2><h3 id="5-1：任务表单"><a href="#5-1：任务表单" class="headerlink" title="5.1：任务表单"></a>5.1：任务表单</h3><p>如果对创建任务时表单的每一项不是很了解，请参考官方文档：<a href="https://www.yuque.com/powerjob/guidence/nyio9g#v8uF4">https://www.yuque.com/powerjob/guidence/nyio9g#v8uF4</a></p><h3 id="5-2：如何配置工作流？"><a href="#5-2：如何配置工作流？" class="headerlink" title="5.2：如何配置工作流？"></a>5.2：如何配置工作流？</h3><p>参考文档：<a href="https://www.yuque.com/powerjob/guidence/ysug77#xgylz%EF%BC%88%E4%B8%8D%E5%A4%AA%E5%A5%BD%E7%94%A8%EF%BC%8C%E7%94%A8%E7%9A%84%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%EF%BC%89">https://www.yuque.com/powerjob/guidence/ysug77#xgylz（不太好用，用的时候需要注意）</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近在调研分布式任务如何选型，最终选择了比较年轻的&lt;code&gt;PowerJob&lt;/code&gt;，下面会简单介绍下这个框架的使用以及它的运行流程。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="服务治理" scheme="http://example.com/categories/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    
    
    <category term="分布式任务调度" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/"/>
    
    <category term="PowerJob" scheme="http://example.com/tags/PowerJob/"/>
    
  </entry>
  
  <entry>
    <title>WRR算法验证实验</title>
    <link href="http://example.com/2020/08/28/WRR%E7%AE%97%E6%B3%95%E9%AA%8C%E8%AF%81%E5%AE%9E%E9%AA%8C/"/>
    <id>http://example.com/2020/08/28/WRR%E7%AE%97%E6%B3%95%E9%AA%8C%E8%AF%81%E5%AE%9E%E9%AA%8C/</id>
    <published>2020-08-28T03:21:00.000Z</published>
    <updated>2023-12-04T01:26:15.377Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、实验整理"><a href="#一、实验整理" class="headerlink" title="一、实验整理"></a>一、实验整理</h2><h3 id="1-1：实验服务情报"><a href="#1-1：实验服务情报" class="headerlink" title="1.1：实验服务情报"></a>1.1：实验服务情报</h3><p>参与实验的服务与集群配置，和P2C验证实验里的一致，请参考：<a href="https://exceting.github.io/2020/08/25/P2C%E7%AE%97%E6%B3%95%E9%AA%8C%E8%AF%81%E5%AE%9E%E9%AA%8C/">P2C算法验证实验</a></p><span id="more"></span><h3 id="1-2：实验case整理"><a href="#1-2：实验case整理" class="headerlink" title="1.2：实验case整理"></a>1.2：实验case整理</h3><h4 id="1-2-1：各节点权重值一致"><a href="#1-2-1：各节点权重值一致" class="headerlink" title="1.2.1：各节点权重值一致"></a>1.2.1：各节点权重值一致</h4><p>场景：节点权重值均为10，比例为1:1</p><p>预期：流量均匀分配</p><h4 id="1-2-2：各节点权重值均不一致"><a href="#1-2-2：各节点权重值均不一致" class="headerlink" title="1.2.2：各节点权重值均不一致"></a>1.2.2：各节点权重值均不一致</h4><p>场景：6个节点权重值分别为：10、20、30、40、50、60</p><p>预期：流量分配按照权重值从大到小逐级递减</p><h4 id="1-2-3：各节点整体权重比例1-2"><a href="#1-2-3：各节点整体权重比例1-2" class="headerlink" title="1.2.3：各节点整体权重比例1:2"></a>1.2.3：各节点整体权重比例1:2</h4><p>场景：6个节点中，3个权重值为10，另外3个权重值为20</p><p>预期：权重值为20的3个节点qps比权重为10的3个节点多出一倍</p><h4 id="1-2-4：中途节点变更"><a href="#1-2-4：中途节点变更" class="headerlink" title="1.2.4：中途节点变更"></a>1.2.4：中途节点变更</h4><p>场景：在旧节点均为10的基础上灰度新节点</p><p>预期：新节点被引入，但qps不如旧节点高，最终全部接流后达到新的平衡，且qps一致。</p><h2 id="二、实验结果"><a href="#二、实验结果" class="headerlink" title="二、实验结果"></a>二、实验结果</h2><h3 id="2-1：各节点权重值一致"><a href="#2-1：各节点权重值一致" class="headerlink" title="2.1：各节点权重值一致"></a>2.1：各节点权重值一致</h3><p>可以看到，在各节点权重值一致时，流量分配极度均匀，符合预期。</p><p><img src="http://myblog.sharemer.com/2020/08/28/20200828-1-1.png?imageView2/0/w/1024" alt="图1"></p><h3 id="2-2：各节点权重值均不一致"><a href="#2-2：各节点权重值均不一致" class="headerlink" title="2.2：各节点权重值均不一致"></a>2.2：各节点权重值均不一致</h3><p>共6个节点，当配置权重值为10、20、30、40、50、60时，则流量分配按照权重值从大到小逐级递减，测试结果如下图，符合预期。</p><p><img src="http://myblog.sharemer.com/2020/08/28/20200828-1-2.png?imageView2/0/w/1024" alt="图2"></p><h3 id="2-3：各节点整体权重比例1-2"><a href="#2-3：各节点整体权重比例1-2" class="headerlink" title="2.3：各节点整体权重比例1:2"></a>2.3：各节点整体权重比例1:2</h3><p>6个节点中，3个权重值为10，另外3个权重值为20，测试结果如下图，流量比例1:2，符合预期。</p><p><img src="http://myblog.sharemer.com/2020/08/28/20200828-1-3.png?imageView2/0/w/1024" alt="图3"></p><h3 id="2-4：中途节点变更"><a href="#2-4：中途节点变更" class="headerlink" title="2.4：中途节点变更"></a>2.4：中途节点变更</h3><p>权重值均为10，后期滚动发版service，效果如下图，符合预期。</p><p><img src="http://myblog.sharemer.com/2020/08/28/20200828-1-4.png?imageView2/0/w/1024" alt="图4"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、实验整理&quot;&gt;&lt;a href=&quot;#一、实验整理&quot; class=&quot;headerlink&quot; title=&quot;一、实验整理&quot;&gt;&lt;/a&gt;一、实验整理&lt;/h2&gt;&lt;h3 id=&quot;1-1：实验服务情报&quot;&gt;&lt;a href=&quot;#1-1：实验服务情报&quot; class=&quot;headerlink&quot; title=&quot;1.1：实验服务情报&quot;&gt;&lt;/a&gt;1.1：实验服务情报&lt;/h3&gt;&lt;p&gt;参与实验的服务与集群配置，和P2C验证实验里的一致，请参考：&lt;a href=&quot;https://exceting.github.io/2020/08/25/P2C%E7%AE%97%E6%B3%95%E9%AA%8C%E8%AF%81%E5%AE%9E%E9%AA%8C/&quot;&gt;P2C算法验证实验&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="服务治理" scheme="http://example.com/categories/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    
    
    <category term="负载均衡" scheme="http://example.com/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
    <category term="服务治理" scheme="http://example.com/tags/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>P2C算法验证实验</title>
    <link href="http://example.com/2020/08/25/P2C%E7%AE%97%E6%B3%95%E9%AA%8C%E8%AF%81%E5%AE%9E%E9%AA%8C/"/>
    <id>http://example.com/2020/08/25/P2C%E7%AE%97%E6%B3%95%E9%AA%8C%E8%AF%81%E5%AE%9E%E9%AA%8C/</id>
    <published>2020-08-25T03:00:00.000Z</published>
    <updated>2023-12-05T03:01:07.692Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇文档是针对前篇<a href="https://exceting.github.io/2020/08/13/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-P2C%E7%AE%97%E6%B3%95/">负载均衡-P2C算法</a>进行的实验验证，会利用一个<code>网关</code>和一个<code>服务端</code>的<code>集群</code>来验证P2C在各个业务场景下的表现。</p></blockquote><span id="more"></span><h2 id="一、实验整理"><a href="#一、实验整理" class="headerlink" title="一、实验整理"></a>一、实验整理</h2><h3 id="1-1：实验服务情报"><a href="#1-1：实验服务情报" class="headerlink" title="1.1：实验服务情报"></a>1.1：实验服务情报</h3><p>参与实验的是两套集群，分别是<code>网关系统</code>和<code>基础服务</code>，网关系统在接收到外部请求后会在grpc内部利用P2C算法pick出合适的基础服务节点发起调用，网关系统拥有1台机器，基础服务集群拥有6台机器，初始权重值都是10，如图：</p><p><img src="http://myblog.sharemer.com/2020/08/25/20200825-1-1.png?imageView2/0/w/900" alt="图1"></p><h3 id="1-2：实验case整理"><a href="#1-2：实验case整理" class="headerlink" title="1.2：实验case整理"></a>1.2：实验case整理</h3><p>按照P2C算法的实现，参考<a href="https://exceting.github.io/2020/08/13/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-P2C%E7%AE%97%E6%B3%95/">负载均衡-P2C算法</a>中的<code>P2CLoadBalancer.pick</code>方法，负载率的完整计算方式如下：</p><p><img src="http://myblog.sharemer.com/2020/08/25/20200825-1-2.png?imageView2/0/w/450" alt="负载率的计算"></p><blockquote><p><em>ps：上述公式中参与运算的数据来源也已在<a href="https://exceting.github.io/2020/08/13/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-P2C%E7%AE%97%E6%B3%95/">负载均衡-P2C算法</a>中做过详细介绍，如忘记，可前往查看代码。</em></p></blockquote><h4 id="1-2-1：实验A组，无cpu使用率返回时"><a href="#1-2-1：实验A组，无cpu使用率返回时" class="headerlink" title="1.2.1：实验A组，无cpu使用率返回时"></a>1.2.1：实验A组，无cpu使用率返回时</h4><p>👾 解释：用来模拟对端不支持cpu使用率携带的情况，按照之前P2C算法的代码，此时cpu恒等于默认值500，因此整体负载率取决于其余几个属性。</p><table><thead><tr><th>操作</th><th>目的</th><th>预期</th></tr></thead><tbody><tr><td>正常请求</td><td>分母一致，看下流量分配是否均匀</td><td>6台机器的流量分配大致均匀</td></tr><tr><td>尝试调小其中一台weight的值</td><td>通过调小weight的值来增大其负载率</td><td>被降低weight的机器流量分配较其它几个节点明显降低</td></tr><tr><td>尝试让某台机器的请求错误量飙升</td><td>通过增大错误量来降低client_success的值，从而增大其负载率</td><td>错误率飙升的机器流量分配较其它几个节点明显降低，恢复后流量增大</td></tr></tbody></table><center>表1</center><h4 id="1-2-2：实验B组，有cpu返回，成功率和权重值一致"><a href="#1-2-2：实验B组，有cpu返回，成功率和权重值一致" class="headerlink" title="1.2.2：实验B组，有cpu返回，成功率和权重值一致"></a>1.2.2：实验B组，有cpu返回，成功率和权重值一致</h4><p>👾 解释：此时保持<code>client_success</code>和<code>weight</code>不变，专注分子对负载率的变化，在这种情况下，分母固定，负载率则完全取决于分子，分子越小，负载率越低，被pick的概率就越大。</p><table><thead><tr><th>操作</th><th>目的</th><th>预期</th></tr></thead><tbody><tr><td>正常请求</td><td>不干涉分子分母的情况下，看下流量分配是否均匀</td><td>6台机器的流量分配大致均匀</td></tr><tr><td>尝试调大其中一台机器的cpu使用率</td><td>让该机器分子变大，负载率变小</td><td>cpu使用率变大的机器分配到的流量明显低于其他几个节点，恢复后流量增大</td></tr><tr><td>尝试调大其中一台机器的延迟率</td><td>让该机器分子变大，负载率变小</td><td>延迟率变大的机器分配到的流量明显低于其他几个节点</td></tr><tr><td>尝试无脑增大某台机器的拥塞度</td><td>让该机器分子变大，负载率变小</td><td>拥塞度变大的机器分配到的流量明显低于其他几个节点</td></tr></tbody></table><center>表2</center><h4 id="1-2-3：实验C组，衰减值测试"><a href="#1-2-3：实验C组，衰减值测试" class="headerlink" title="1.2.3：实验C组，衰减值测试"></a>1.2.3：实验C组，衰减值测试</h4><p>👾 解释：调整<code>衰减值</code>（下称<code>k值</code>），查看衰减值对P2C的影响。</p><table><thead><tr><th>操作</th><th>目的</th><th>预期</th></tr></thead><tbody><tr><td>模拟某台机器某段时间内网络延迟</td><td>不干涉分子分母的情况下，看流量是否倾斜</td><td>存在网络延迟的节点流量分配明显低于其他几个节点</td></tr><tr><td>同上，但调整k的值</td><td>测试k值对P2C算法在网络延迟情况下的影响以及它的具体作用</td><td>k值越大，网络延迟恢复后流量分配恢复到正常水平的速度越慢，反之越快</td></tr></tbody></table><center>表3</center><h4 id="1-2-4：实验D组，中途节点变更"><a href="#1-2-4：实验D组，中途节点变更" class="headerlink" title="1.2.4：实验D组，中途节点变更"></a>1.2.4：实验D组，中途节点变更</h4><p>👾 解释：不干涉分子分母，中途发版，查看发版对P2C的影响。</p><table><thead><tr><th>操作</th><th>目的</th><th>预期</th></tr></thead><tbody><tr><td>中途发版</td><td>不干涉分子分母，中途发版，查看发版对P2C的影响</td><td>不影响性能，且新入的节点及时均摊流量</td></tr></tbody></table><center>表4</center><h2 id="二、实验结果"><a href="#二、实验结果" class="headerlink" title="二、实验结果"></a>二、实验结果</h2><p>👽 以下实验均通过ab压测进行，通过开启50个线程并发请求1000w次。</p><h3 id="2-1：实验组A-结论"><a href="#2-1：实验组A-结论" class="headerlink" title="2.1：实验组A-结论"></a>2.1：实验组A-结论</h3><h4 id="2-1-1：正常请求"><a href="#2-1-1：正常请求" class="headerlink" title="2.1.1：正常请求"></a>2.1.1：正常请求</h4><p>实验结果：基本符合预期，每个节点较均匀的访问，至于为什么黄色节点的qps比较低，因为它的平均耗时比较大（配合<code>图3</code>）。</p><p><img src="http://myblog.sharemer.com/2020/08/25/20200825-1-3.png?imageView2/0/w/1024" alt="图2"></p><p>节点平均耗时（将其作为<code>latency</code>代入之前的公式，基本符合上图的qps分配，即latency越小，被pick的概率越大）：</p><p><img src="http://myblog.sharemer.com/2020/08/25/20200825-1-4.png?imageView2/0/w/1024" alt="图3"></p><h4 id="2-1-2：调小其中一个节点的weight"><a href="#2-1-2：调小其中一个节点的weight" class="headerlink" title="2.1.2：调小其中一个节点的weight"></a>2.1.2：调小其中一个节点的weight</h4><p>将其中某个节点的权重改成<code>5</code>，其余仍为<code>10</code>，可以看到，权重值为5的节点（橙色线）qps相比其他权重值为10的节点，少了一半。</p><p><img src="http://myblog.sharemer.com/2020/08/25/20200825-1-5.png?imageView2/0/w/1024" alt="图4"></p><h4 id="2-1-3：尝试让某台机器的请求错误量飙升"><a href="#2-1-3：尝试让某台机器的请求错误量飙升" class="headerlink" title="2.1.3：尝试让某台机器的请求错误量飙升"></a>2.1.3：尝试让某台机器的请求错误量飙升</h4><p>让其中某个节点在某时刻故障，一段时间后恢复，测试结果如下图，可以看到，在某节点（橙色线）发生网络故障时，qps会以一定的速度下降，然后到达最低值（此时按照3s一次的概率被pick，可以理解成该节点当前处于”半熔断“状态），期间其他节点qps加大，故障恢复后，又以一定的速度恢复至原qps。</p><p><img src="http://myblog.sharemer.com/2020/08/25/20200825-1-6.png?imageView2/0/w/1024" alt="图5"></p><h3 id="2-2：实验组B-结论"><a href="#2-2：实验组B-结论" class="headerlink" title="2.2：实验组B-结论"></a>2.2：实验组B-结论</h3><h4 id="2-2-1：正常请求"><a href="#2-2-1：正常请求" class="headerlink" title="2.2.1：正常请求"></a>2.2.1：正常请求</h4><p>让对端传送cpu使用率，公式中的其余数据不做干涉，得出下图，跟<code>2.1.1</code>一致，大致平均：</p><p><img src="http://myblog.sharemer.com/2020/08/25/20200825-1-7.png?imageView2/0/w/1024" alt="图6"></p><p><img src="http://myblog.sharemer.com/2020/08/25/20200825-1-8.png?imageView2/0/w/1024" alt="图7"></p><h4 id="2-2-2：尝试调大其中一台机器的cpu使用率"><a href="#2-2-2：尝试调大其中一台机器的cpu使用率" class="headerlink" title="2.2.2：尝试调大其中一台机器的cpu使用率"></a>2.2.2：尝试调大其中一台机器的cpu使用率</h4><p>让其中某个节点在某时刻<code>cpu使用率</code>飙升，一段时间后恢复，测试结果如下图，可以看到，在某节点（黄色线）cpu使用率飙升时，qps会以一定的速度下降，然后到达最低值，期间其他节点qps加大，故障恢复后，又以一定的速度恢复至原qps。</p><p><img src="http://myblog.sharemer.com/2020/08/25/20200825-1-9.png?imageView2/0/w/1024" alt="图8"></p><h4 id="2-2-3：调大其中一台机器的延迟率"><a href="#2-2-3：调大其中一台机器的延迟率" class="headerlink" title="2.2.3：调大其中一台机器的延迟率"></a>2.2.3：调大其中一台机器的延迟率</h4><p>让其中某个节点在某时刻<code>延迟率</code>飙升，一段时间后恢复，测试结果如下图，可以看到，在某节点（橙色线）延迟率飙升时，qps会以一定的速度下降，然后到达最低值，期间其他节点qps加大，延迟恢复后，又以一定的速度恢复至原qps。</p><p><img src="http://myblog.sharemer.com/2020/08/25/20200825-1-10.png?imageView2/0/w/1024" alt="图9"></p><h4 id="2-2-4：调大其中一台机器的拥塞度"><a href="#2-2-4：调大其中一台机器的拥塞度" class="headerlink" title="2.2.4：调大其中一台机器的拥塞度"></a>2.2.4：调大其中一台机器的拥塞度</h4><p><code>省略...</code></p><p>不再实验，同样作为分子，调大和恢复它也一样能达到上图的效果。</p><h3 id="2-3：实验组C-结论"><a href="#2-3：实验组C-结论" class="headerlink" title="2.3：实验组C-结论"></a>2.3：实验组C-结论</h3><p>同样模拟网络延迟，此时让2个节点发生网络延迟，但是衰减值不同（橙色节点为5，青色节点使用600），可以看到，衰减值越大，感知问题的速度相对越慢，恢复速度也相对越慢。</p><p><img src="http://myblog.sharemer.com/2020/08/25/20200825-1-11.png?imageView2/0/w/1024" alt="图10"></p><h3 id="2-4：实验组D-结论"><a href="#2-4：实验组D-结论" class="headerlink" title="2.4：实验组D-结论"></a>2.4：实验组D-结论</h3><p>在service运行中灰度新节点（注：图中新节点被接入后qps明显比旧节点大的原因是新节点耗时明显更低，请结合<code>图12</code>看）</p><p><img src="http://myblog.sharemer.com/2020/08/25/20200825-1-12.png?imageView2/0/w/1024" alt="图11"></p><p><img src="http://myblog.sharemer.com/2020/08/25/20200825-1-13.png?imageView2/0/w/1024" alt="图12"></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本篇文档是针对前篇&lt;a href=&quot;https://exceting.github.io/2020/08/13/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-P2C%E7%AE%97%E6%B3%95/&quot;&gt;负载均衡-P2C算法&lt;/a&gt;进行的实验验证，会利用一个&lt;code&gt;网关&lt;/code&gt;和一个&lt;code&gt;服务端&lt;/code&gt;的&lt;code&gt;集群&lt;/code&gt;来验证P2C在各个业务场景下的表现。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="服务治理" scheme="http://example.com/categories/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    
    
    <category term="负载均衡" scheme="http://example.com/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
    <category term="服务治理" scheme="http://example.com/tags/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡-P2C算法</title>
    <link href="http://example.com/2020/08/13/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-P2C%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2020/08/13/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-P2C%E7%AE%97%E6%B3%95/</id>
    <published>2020-08-13T06:56:00.000Z</published>
    <updated>2023-12-04T02:31:41.341Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>P2C</code>算法全称<code>Pick of 2 choices</code>，相比<code>WRR</code>，P2C有着更科学的LB策略，它通过随机选择两个节点后在这俩节点里选择优胜者来避免<code>羊群效应</code>，并通过<code>指数加权移动平均算法</code>统计服务端的实时状态，从而做出最优选择。</p></blockquote><span id="more"></span><h2 id="一、工作流程"><a href="#一、工作流程" class="headerlink" title="一、工作流程"></a>一、工作流程</h2><p>P2C算法下的每个节点（下称<code>Node</code>）必须含有下方图中几个指标，它们的计算方法已经标出：</p><p><img src="http://myblog.sharemer.com/2020/08/13/20200813-1-1.png?imageView2/0/w/750" alt="图1"></p><p>因此最终loadbalancer里保存的节点就会变成下图的结构，pick节点时需要做如下比较：</p><p><img src="http://myblog.sharemer.com/2020/08/13/20200813-1-2.png?imageView2/0/w/800" alt="图2"></p><p>通过上面的流程可以看到，大体流程还是随机，相比普通的随机LB，它是随机选择两个node，然后比较它们的负载率，然后选出当前负载率最小的node。</p><h2 id="二、数据统计"><a href="#二、数据统计" class="headerlink" title="二、数据统计"></a>二、数据统计</h2><p>通过上面的简单介绍，可以知道P2C算法的大体流程，那么现在问题就变得简单多了，只需要知道<code>负载率</code>，就可以完成这个“简单”的负载均衡器，但是负载率是由上图<code>五个指标</code>共同参与计算完成的，那现在问题的关键就是如何完成这五个指标的统计，下面来介绍下这五个指标如何计算。</p><h3 id="2-1：weight"><a href="#2-1：weight" class="headerlink" title="2.1：weight"></a>2.1：weight</h3><p>这个很简单，主要是人为配置的定制，用于给不同的机器按照机器配置分配上不同的权重，权重越高，越容易被pick到。这个值可以做在服务注册与发现里，进行为每个节点分配一个权重值。</p><h3 id="2-2：server-cpu"><a href="#2-2：server-cpu" class="headerlink" title="2.2：server_cpu"></a>2.2：server_cpu</h3><p>这个值可以通过服务端回写元数据来搞定，比如一次请求：</p><p><img src="http://myblog.sharemer.com/2020/08/13/20200813-1-3.png?imageView2/0/w/800" alt="图3"></p><p>所以这个值可以通过服务端埋点的方式解决掉。</p><h3 id="2-3：inflight"><a href="#2-3：inflight" class="headerlink" title="2.3：inflight"></a>2.3：inflight</h3><p>这个代表节点请求<code>拥塞度</code>，代表着当前节点有多少个请求未完成或者正开始请求，它的统计也很简单：</p><p><img src="http://myblog.sharemer.com/2020/08/13/20200813-1-4.png?imageView2/0/w/800" alt="图4"></p><p>按照这种，每次pick到发送请求前先<code>原子+1</code>，response后说明一次请求完成，这时再<code>原子-1</code>，这样<code>一增一减</code>，在超多线程pick下（即高qps），当前线程获取到的<code>inflight</code>瞬间值，就是在这个时段的<code>拥塞度</code>，比如一个节点如果很闲，响应速度也快，那么它的拥塞度肯定极低（因为一增一减的操作很快就完成，不会淤积过多）。</p><h3 id="2-4：latency-client-success"><a href="#2-4：latency-client-success" class="headerlink" title="2.4：latency &amp; client_success"></a>2.4：latency &amp; client_success</h3><p>前面的都很好了理解，这俩属性比较麻烦，它们分别代表请求<code>延迟率</code>和<code>成功率</code>。</p><p>这俩值该怎么计算？一般来说是通过平均数的方式来计算，但计算平均数的方式有很多，可以先用我们最熟悉的算术平均数来计算，它的计算公式如下：</p><p><img src="http://myblog.sharemer.com/2020/08/13/gs1-m.png" alt="img"></p><p>利用此算法套入我们的场景后，请求总耗时比上请求总次数，就是latency：</p><p><img src="http://myblog.sharemer.com/2020/08/13/gs2-m.png" alt="img"></p><p>请求总成功数比上请求总次数，就是client_success：</p><p><img src="http://myblog.sharemer.com/2020/08/13/gs3-m.png" alt="img"></p><p>整个过程可以抽象成下面这样：</p><p><img src="http://myblog.sharemer.com/2020/08/13/20200813-1-7.png?imageView2/0/w/800" alt="图5"></p><p>根据<code>图5</code>的流程，可以通过每次请求，累加总请求数、总耗时、总成功数，然后利用<code>算术平均法</code>更新<code>latency</code>和<code>client_success</code>的值，这一切可以运作的很好，可是算术平均有个很大的缺陷，不够敏感，出现的网络波动一下就被平均了，是不是想到了你和马云放在一起统计资产时被平均的悲哀？</p><h4 id="2-4-1：算术平均数模拟"><a href="#2-4-1：算术平均数模拟" class="headerlink" title="2.4.1：算术平均数模拟"></a>2.4.1：算术平均数模拟</h4><p>首先模拟<code>1000次请求</code>，让每次请求在<code>0~25</code>之间产生随机数用来作为本次请求的耗时（为了模拟真实情况，让一些请求耗时过高），每次请求计算当前的算术平均数，然后可以得到下面的统计图：</p><p><img src="http://myblog.sharemer.com/2020/08/13/20200813-1-8.png?imageView2/0/w/900" alt="图6"></p><p>可以看到，正常情况下，算术平均数表现出很好的稳定性，红线一致维持在黑线的中间，且浮动不大。</p><p>现在让我们搞点事情，假设在第100次请求到第200次请求间，模拟下网络抖动，让这期间的响应时间变成125ms（相比正常情况翻<code>五倍</code>），得到统计图如下：</p><p><img src="http://myblog.sharemer.com/2020/08/13/20200813-1-9.png?imageView2/0/w/900" alt="图7"></p><p>可以看到平均数受到这次抖动的影响，需要非常长的时间才能感知到，恢复时又需要很长时间才能恢复到抖动前的较正常的水平。</p><p>也就是说，第100~200间的100次慢请求，不光要到140次请求后才能较明显的感知平均值的上涨，还导致网络恢复后，到第1000次请求时，平均值还没有恢复到正常水平（但其实从第200次请求后，响应时间就正常了），算术平均是所有数据的总平均，受过往值的影响非常深，以至于不能很好的反应某个时段的平均趋势，那么有没有更好的统计办法来避免这类问题呢？</p><h4 id="2-4-2：指数加权移动平均算法（EWMA）模拟"><a href="#2-4-2：指数加权移动平均算法（EWMA）模拟" class="headerlink" title="2.4.2：指数加权移动平均算法（EWMA）模拟"></a>2.4.2：指数加权移动平均算法（EWMA）模拟</h4><blockquote><p>参考资料：<a href="https://blog.csdn.net/m0_38106113/article/details/81542863">深入解析TensorFlow中滑动平均模型与代码实现</a></p></blockquote><p>公式如下：</p><p><img src="http://myblog.sharemer.com/2020/08/13/gs4-m.png" alt="img"></p><p>解释：<code>vt</code>代表第t次请求的指数加权平均耗时，<code>vt-1</code>代表上次请求的指数加权平均耗时，<code>θt</code>代表第t次请求的实际耗时。</p><p><code>β值</code>的定义如下：</p><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vt ≈ <span class="number">1</span>/(<span class="number">1</span> - β) 次的平均耗时</span><br></pre></td></tr></table></figure><p>例：假设β等于0.9，1&#x2F;(1 - β) 就等于10，vt约等于前10次请求的平均耗时；假设把β值调大至0.98，1&#x2F;(1-β)&#x3D;50，就是当前请求的前50次请求的平均耗时。</p><p>由此可以推导出：</p><p>β值越大，移动平均区间越大，当前平均值的计算受到之前平均值的影响也就越大</p><p>β值越小，移动平均区间越小，当前平均值的计算受到之前平均值的影响也就越小</p><p>eg：假设现在有两次请求，第一次耗时25ms，第二次耗时50ms，代入公式，计算出第一次和第二次的指数加权平均值为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">v1</span> <span class="operator">=</span> β * <span class="number">0</span> + (<span class="number">1</span> - β) * <span class="number">25</span></span><br><span class="line"><span class="type">double</span> <span class="variable">v2</span> <span class="operator">=</span> β * v1 + (<span class="number">1</span> - β) * <span class="number">50</span> <span class="comment">// β值越小，意味着本次请求的实际耗时占比越大，β值越大，之前计算得到的平均值占比越大</span></span><br></pre></td></tr></table></figure><p>这个结论在下面的实验中会有所体现。</p></blockquote><p>相比普通平均值的计算，EWMA算法更在乎<code>历史平均值</code>对统计结果的影响，通过控制β的值就可以调整历史均值对统计趋势的影响程度。</p><p>现在用EWMA模拟下1000次请求，为了模拟真实情况，我会让一些请求耗时过高，β取值<code>0.9</code>，代表最新请求时的平均值计算会受到最近<code>10次</code>耗时的影响进行平滑过渡，运行结果绘制如下图（渲染采用Echarts）：</p><p><img src="http://myblog.sharemer.com/2020/08/13/20200813-1-11.png?imageView2/0/w/900" alt="图8"></p><p>最终得到的数据曲线没有算术平均那么稳定，但可以看出，每次网络波动会提升其加权均值，不会像算术平均那样不受网络波动影响。</p><p>接下来假设第100~200次请求，发生了网络延迟，延时<code>5倍</code>，再次利用EWMA做下模拟：</p><p><img src="http://myblog.sharemer.com/2020/08/13/20200813-1-12.png?imageView2/0/w/900" alt="图9"></p><p>请将这张图跟<code>图7</code>进行对比，你会发现，利用指数加权平均算法计算出的平均值在网络恢复时，以极快的速度恢复到了正常水平。</p><p>相比算术平均，EWMA更重要的是它平滑的模拟了平均值的趋势。</p><p>现在把<code>图9</code>里的β值调整为0.98，此时在计算当前平均值时则受到前面(1&#x2F;0.02) &#x3D; 50个平均值的影响，便得到下图：</p><p><img src="http://myblog.sharemer.com/2020/08/13/20200813-1-13.png?imageView2/0/w/901" alt="图10"></p><p>因为β值变大，后续每个平均值都会受到更多历史均值的影响，而当前耗时仅占很少影响，跟之前的结论一样，β越大，移动窗口越大，当前平均数受到历史平均值的影响就越大，反之越小，所以相比<code>图9</code>，在出现网络抖动后，更缓慢的恢复为正常均值（波形跟算术平均接近）。</p><p>还可以将β调小试试，比如将其设为0.32，那么计算均值时仅受到前面(1&#x2F;0.68) &#x3D; 1.47个均值影响，此时平均值轨迹几乎和正常响应时间重叠：</p><p><img src="http://myblog.sharemer.com/2020/08/13/20200813-1-14.png?imageView2/0/w/900" alt="图11"></p><p>可以看到，当β很小时，受影响因子无限趋近于1，越趋近于1则越贴近原本值。</p><h4 id="2-4-3：结论"><a href="#2-4-3：结论" class="headerlink" title="2.4.3：结论"></a>2.4.3：结论</h4><table><thead><tr><th>实验组</th><th>对照组</th><th>目的</th><th>结论</th></tr></thead><tbody><tr><td>图6</td><td>图8（β&#x3D;0.9）</td><td>模拟网络正常情况下，两种算法对均值的统计区别</td><td>算术平均值非常稳定，对单次网络抖动完全无感知，EWMA均值则会随着响应时间动态变化，因此单次网络抖动后会稍微提升均值，之后便很快恢复</td></tr><tr><td>图7</td><td>图9（β&#x3D;0.9）</td><td>模拟一段网络延迟，看两种算法的均值变化</td><td>算术平均值会缓慢提升，之后再次以极慢的速度下降，对网络延迟反映迟钝，网络延迟结束后仍然要花很长时间才能恢复到正常均值水平，EWMA均值则迅速提升，恢复后迅速下降至正常水平</td></tr><tr><td>图9（β&#x3D;0.9）</td><td>图10（β&#x3D;0.98）</td><td>调大EWMA的β值</td><td>β值越大，每次计算均值时受到之前均值影响越大，则平均曲线更加平滑，因此<code>图10</code>的曲线要比<code>图9</code>表现更加平滑，但付出的代价是对网络延迟反应也变的迟钝</td></tr><tr><td>图9（β&#x3D;0.9）</td><td>图11（β&#x3D;0.32）</td><td>调小EWMA的β值</td><td>β值越小，每次计算均值时受到之前均值影响越小，则平均曲线更加趋近于每次的实际耗时，因此<code>图11</code>的曲线要比<code>图9</code>表现的更加趋近于每次的实际耗时，顺理成章的，它对网络延迟的反映极迅速</td></tr></tbody></table><center>表1</center><p>通过实验，可以看出EWMA的优势巨大，但β的取值需要仔细斟酌，若β太小，则无法很好的体现出平均值，若β太大，很好的体现了平均值，但对网络波动的反应相对迟钝，这里就考虑到一个折中的方案：</p><blockquote><p>实时调整β值，比如EWMA可以在网络波动时适当<code>降低β的值</code>，使其快速感知到波动的存在，当网络波动结束后，适当<code>提升β的值</code>，这样就可以在网络稳定的情况下较好的反映一个区段内的均值情况，这样等于结合了<code>图10</code>和<code>图11</code>各自的优点，实现后将达到一种效果：快速感知网络延迟并迅速提高其均值，当网络恢复后，慢慢降回正常水平（均值恢复需要慢慢进行，因为刚恢复的节点稳定性不可信，慢慢恢复到正常水平，以信任其稳定性）</p></blockquote><h4 id="2-4-4：利用衰减函数动态调整β值"><a href="#2-4-4：利用衰减函数动态调整β值" class="headerlink" title="2.4.4：利用衰减函数动态调整β值"></a>2.4.4：利用衰减函数动态调整β值</h4><p>通过上面的要求，我们需要完善这个变化的β，那么它该如何变化呢？如何能达到碰到网络波动时迅速感知，当波动过后慢慢恢复的效果呢？慢慢恢复需要多慢？可不可以通过调整某个阈值来控制恢复的速率？</p><p>带着上面的问题，需要了解一下：衰减函数（<a href="http://www.ruanyifeng.com/blog/2012/03/ranking_algorithm_newton_s_law_of_cooling.html">牛顿冷却定律</a>）</p><p>公式为：</p><p><img src="http://myblog.sharemer.com/2020/08/13/gs5-m.png" alt="img"></p><p><code>e</code>是常量，<code>Δt</code>表示第t次请求的耗时，<code>k</code>表示<code>衰减系数</code>，它的函数图如下：</p><p><img src="http://myblog.sharemer.com/2020/08/13/20200813-1-15.png" alt="图12"></p><p>我们把<code>k*Δt</code>看做<code>x的取值</code>，那么<code>k</code>和<code>Δt</code>成正比，即：<code>k</code>和<code>Δt</code>取值越大，β就越小</p><p>现在来看看这个结论支不支持我们要实现的功能：</p><ol><li>网络抖动时，假设<code>Δt</code>非常大，即便不乘<code>k值</code>，β值也会变得很小，这是符合我们预期的，我们需要的就是在网络抖动时，迅速感知</li><li>网络恢复时，<code>Δt</code>迅速降低，假设此时<code>Δt</code>非常小，则<code>k值</code>越大，<code>图12</code>里对应的<code>x</code>越大，β的值就越小，事实上通过实验可以得出，如果<code>k</code>值很大，得出的曲线近乎等于<code>图11</code>。</li></ol><p>经过上面的梳理，发现k值似乎没有起到衰减作用，反而因为它的存在导致β值降低，它的取值在网络抖动恢复后依旧在<code>削弱</code>β的值，导致网络恢复后迅速降低到正常水平，这是我们不愿意看到的，那么上面的函数需要做下变体，即让<code>Δt和k值成反比</code>即可：</p><p><img src="http://myblog.sharemer.com/2020/08/13/gs6-m.png" alt="img"></p><p>此时结论如下：</p><ol><li>网络抖动时，假设<code>Δt</code>非常大，即便<code>k值</code>起到中和作用，β值较之前也会明显变小，这是符合我们预期的，我们需要的就是在网络抖动时，迅速感知</li><li>网络恢复时，即使<code>Δt</code>迅速降低，那么由于<code>k值</code>的中和（<code>Δt/k</code>的值大小和<code>k值</code>成反比），k越大，β越大，则均值计算受之前波动期的均值影响越大，曲线恢复越缓慢。</li></ol><p>这点可以通过下方的验证得到证实，调整衰减系数k，的确可以控制在遇到波动时恢复到正常水平时的速度，衰减系数设置越大，波幅越大（恢复越慢），反之越小（恢复越快）。</p><h4 id="2-4-5：衰减系数验证"><a href="#2-4-5：衰减系数验证" class="headerlink" title="2.4.5：衰减系数验证"></a>2.4.5：衰减系数验证</h4><p>第一组：随机次数的网络抖动，衰减系数分别为<code>600</code>和<code>50</code></p><p><img src="http://myblog.sharemer.com/2020/08/13/20200813-1-16.png?imageView2/0/w/900" alt="衰减系数为600时的走势图，可以看出，网络恢复后均值变化衰减速度很慢"></p><p><img src="http://myblog.sharemer.com/2020/08/13/20200813-1-17.png?imageView2/0/w/900" alt="衰减系数为50时的走势图，可以看出，网络恢复后均值变化衰减速度很快"></p><p>第二组：第<code>100~200次</code>请求响应时间<code>扩大5倍</code>，衰减系数仍然是<code>600</code>和<code>50</code></p><p><img src="http://myblog.sharemer.com/2020/08/13/20200813-1-18.png?imageView2/0/w/900" alt="衰减系数为600时的走势图，可以看出在抖动发生时，仍然可以迅速感知，后续恢复时的衰减速度跟上面结果一样慢"></p><p><img src="http://myblog.sharemer.com/2020/08/13/20200813-1-19.png?imageView2/0/w/900" alt="衰减系数为50时的走势图，可以看出在抖动发生时，可以非常迅速的感知，后续恢复时的衰减速度跟上面结果一样快"></p><h2 id="三、利用JAVA实现P2C算法"><a href="#三、利用JAVA实现P2C算法" class="headerlink" title="三、利用JAVA实现P2C算法"></a>三、利用JAVA实现P2C算法</h2><p>首先定义Node类：</p><figure class="highlight java"><figcaption><span>代码块1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//惩罚值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">penalty</span> <span class="operator">=</span> <span class="number">250_000_000_000L</span>; <span class="comment">//单位：纳秒（250s）</span></span><br><span class="line">    <span class="comment">//衰减系数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">tau</span> <span class="operator">=</span> <span class="number">600_000_000L</span>; <span class="comment">//单位：纳秒（600ms）</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String host;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> weight; <span class="comment">//权重</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// client统计数据</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">lag</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(); <span class="comment">//加权移动平均算法计算出的请求延迟度</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">success</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">1000</span>); <span class="comment">// 加权移动平均算法计算出的请求成功率（只记录grpc内部错误，比如context deadline）</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">inflight</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">1</span>); <span class="comment">// 当前客户端正在发送并等待response的请求数（pending request）</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">svrCPU</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">500</span>); <span class="comment">//对应服务端的CPU使用率</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 最近一次resp时间戳</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">stamp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>();</span><br><span class="line">    <span class="comment">// 最近被pick的时间戳，利用该值可以统计被选中后，一次请求的耗时</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">pick</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(String host, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.host = host;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">valid</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> health() &gt; <span class="number">500</span> &amp;&amp; svrCPU.get() &lt; <span class="number">900</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">health</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> success.get(); <span class="comment">//成功率</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">load</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">lag</span> <span class="operator">=</span> (<span class="type">long</span>) (Math.sqrt((<span class="type">double</span>) <span class="built_in">this</span>.lag.get()) + <span class="number">1</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">load</span> <span class="operator">=</span> <span class="built_in">this</span>.svrCPU.get() * lag * <span class="built_in">this</span>.inflight.get(); <span class="comment">//根据cpu使用率、延迟率、拥塞度计算出负载率</span></span><br><span class="line">        <span class="keyword">if</span> (load == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// penalty是初始化没有数据时的惩罚值，默认为1e9 * 250</span></span><br><span class="line">            load = penalty;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> load;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//被pick后，完成请求后触发逻辑</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">responseTrigger</span><span class="params">(<span class="type">long</span> pickTime, <span class="type">long</span> cpu, <span class="type">boolean</span> error)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.inflight.decrementAndGet();</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> <span class="built_in">this</span>.stamp.getAndSet(now);</span><br><span class="line">        <span class="type">long</span> <span class="variable">td</span> <span class="operator">=</span> now - stamp; <span class="comment">//计算距离上次response的时间差，节点本身闲置越久，这个值越大</span></span><br><span class="line">        <span class="keyword">if</span> (td &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            td = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//实时计算β值，利用衰减函数计算，公式为：β = e^(-t/k)，相比前文给出的衰减公式这里是按照k值的反比计算的，即k值和β值成正比</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">w</span> <span class="operator">=</span> Math.exp((<span class="type">double</span>) -td / (<span class="type">double</span>) tau);</span><br><span class="line"> </span><br><span class="line">        <span class="type">long</span> <span class="variable">lag</span> <span class="operator">=</span> now - pickTime; <span class="comment">//实际耗时</span></span><br><span class="line">        <span class="keyword">if</span> (lag &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            lag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">oldLag</span> <span class="operator">=</span> <span class="built_in">this</span>.lag.get();</span><br><span class="line">        <span class="keyword">if</span> (oldLag == <span class="number">0</span>) &#123;</span><br><span class="line">            w = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//计算指数加权移动平均响应时间</span></span><br><span class="line">        lag = (<span class="type">int</span>) ((<span class="type">double</span>) oldLag * w + (<span class="type">double</span>) lag * (<span class="number">1.0</span> - w));</span><br><span class="line">        <span class="built_in">this</span>.lag.set(lag); <span class="comment">//更新</span></span><br><span class="line"> </span><br><span class="line">        <span class="type">int</span> <span class="variable">success</span> <span class="operator">=</span> error ? <span class="number">0</span> : <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">//计算指数加权移动平均成功率</span></span><br><span class="line">        success = (<span class="type">int</span>) ((<span class="type">double</span>) <span class="built_in">this</span>.success.get() * w + (<span class="type">double</span>) success * (<span class="number">1.0</span> - w));</span><br><span class="line">        <span class="built_in">this</span>.success.set(success); <span class="comment">//更新</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//更新本次请求服务端返回的cpu使用率</span></span><br><span class="line">        <span class="keyword">if</span> (cpu &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.svrCPU.set(cpu);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来定义LoadBalancer：</p><figure class="highlight java"><figcaption><span>代码块2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">P2CLoadBalancer</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//闲置时间的最大容忍值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">forceGap</span> <span class="operator">=</span> <span class="number">3000_000_000L</span>; <span class="comment">//单位：纳秒（3s）</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Node&gt; nodes; <span class="comment">//保存了参与lb的节点集合</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">P2CLoadBalancer</span><span class="params">(List&lt;Node&gt; nodes)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nodes = nodes;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">pick</span><span class="params">(<span class="type">long</span> start)</span> &#123; <span class="comment">//外界给入start，值为当前时间，resp后应给recycle传同样的值</span></span><br><span class="line">        Node pc, upc;</span><br><span class="line">        <span class="keyword">if</span> (nodes == <span class="literal">null</span> || nodes.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;no node!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nodes.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        Node[] randomPair = prePick();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里根据各自当前指标，计算出谁更合适被pick</span></span><br><span class="line"><span class="comment">         * 计算方式：</span></span><br><span class="line"><span class="comment">         *        nodeA.load                           nodeB.load</span></span><br><span class="line"><span class="comment">         * ----------------------------   :   ----------------------------</span></span><br><span class="line"><span class="comment">         * nodeA.health * nodeA.weight        nodeB.health * nodeB.weight</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * health和weight都是提权用的，而load是降权用的，所以用load除以heal和weight的乘积，计算出的值越大，越不容易被pick</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (randomPair[<span class="number">0</span>].load() * randomPair[<span class="number">1</span>].health() * randomPair[<span class="number">1</span>].weight &gt;</span><br><span class="line">                randomPair[<span class="number">1</span>].load() * randomPair[<span class="number">0</span>].health() * randomPair[<span class="number">0</span>].weight) &#123;</span><br><span class="line">            pc = randomPair[<span class="number">1</span>];</span><br><span class="line">            upc = randomPair[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pc = randomPair[<span class="number">0</span>];</span><br><span class="line">            upc = randomPair[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 如果落选的节点，在forceGap期间内没有被选中一次，那么强制选中一次，利用强制的机会，来触发成功率、延迟的衰减</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">pick</span> <span class="operator">=</span> upc.pick.get();</span><br><span class="line">        <span class="keyword">if</span> ((start - pick) &gt; forceGap &amp;&amp; upc.pick.compareAndSet(pick, start)) &#123;</span><br><span class="line">            pc = upc; <span class="comment">//强制选中</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 节点未发生切换才更新pick时间</span></span><br><span class="line">        <span class="keyword">if</span> (pc != upc) &#123;</span><br><span class="line">            pc.pick.set(start);</span><br><span class="line">        &#125;</span><br><span class="line">        pc.inflight.incrementAndGet();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> pc;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//pick出去后，等来了response后，应触发该方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recycle</span><span class="params">(Node node, <span class="type">long</span> pickTime, <span class="type">long</span> cpu, <span class="type">boolean</span> error)</span> &#123;</span><br><span class="line">        node.responseTrigger(pickTime, cpu, error);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 随机选择俩节点</span></span><br><span class="line">    <span class="keyword">public</span> Node[] prePick() &#123;</span><br><span class="line">        Node[] randomPair = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> r.nextInt(nodes.size());</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> r.nextInt(nodes.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (b &gt;= a) &#123;</span><br><span class="line">                b += <span class="number">1</span>; <span class="comment">//防止随机出的节点相同</span></span><br><span class="line">            &#125;</span><br><span class="line">            randomPair[<span class="number">0</span>] = nodes.get(a);</span><br><span class="line">            randomPair[<span class="number">1</span>] = nodes.get(b);</span><br><span class="line">            <span class="keyword">if</span> (randomPair[<span class="number">0</span>].valid() || randomPair[<span class="number">1</span>].valid()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> randomPair;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、算法验证"><a href="#四、算法验证" class="headerlink" title="四、算法验证"></a>四、算法验证</h2><p>算法的验证会以实际压测的方式来进行，请前往：<a href="https://exceting.github.io/2020/08/25/P2C%E7%AE%97%E6%B3%95%E9%AA%8C%E8%AF%81%E5%AE%9E%E9%AA%8C/">P2C算法验证实验</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;P2C&lt;/code&gt;算法全称&lt;code&gt;Pick of 2 choices&lt;/code&gt;，相比&lt;code&gt;WRR&lt;/code&gt;，P2C有着更科学的LB策略，它通过随机选择两个节点后在这俩节点里选择优胜者来避免&lt;code&gt;羊群效应&lt;/code&gt;，并通过&lt;code&gt;指数加权移动平均算法&lt;/code&gt;统计服务端的实时状态，从而做出最优选择。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="服务治理" scheme="http://example.com/categories/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    
    
    <category term="负载均衡" scheme="http://example.com/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
    <category term="服务治理" scheme="http://example.com/tags/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡-WRR算法</title>
    <link href="http://example.com/2020/08/07/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-WRR%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2020/08/07/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-WRR%E7%AE%97%E6%B3%95/</id>
    <published>2020-08-06T22:27:00.000Z</published>
    <updated>2023-12-04T02:37:15.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、工作流程"><a href="#一、工作流程" class="headerlink" title="一、工作流程"></a>一、工作流程</h2><h3 id="1-1：实现加权轮询的方式"><a href="#1-1：实现加权轮询的方式" class="headerlink" title="1.1：实现加权轮询的方式"></a>1.1：实现加权轮询的方式</h3><p>WRR叫做加权轮询算法，相比普通的轮询算法，它支持给每个节点配置权重，权重越大，越容易被访问，且符合轮询的特点。</p><span id="more"></span><p>一般情况下，我们会按照下方逻辑设计算法的实现：</p><p><img src="http://myblog.sharemer.com/2020/08/07/20200807-1-1.png?imageView2/0/w/900" alt="图1"></p><p>如<code>图1</code>中流程执行完毕，接下来就跟普通RR算法一样做轮询即可，保证每个虚拟节点都被均匀访问到，而被访问概率也与权重值成正比。</p><p>但正如上图所说，乱序那一步是比较容易出问题的，可能会出现下面这样的情况：</p><p><img src="http://myblog.sharemer.com/2020/08/07/20200807-1-2.png?imageView2/0/w/500" alt="图2"></p><h3 id="1-2：SWRR算法"><a href="#1-2：SWRR算法" class="headerlink" title="1.2：SWRR算法"></a>1.2：SWRR算法</h3><p>如果不足够散列，意味着轮询窗口内访问不足够均匀，基于此，便有了<code>SWRR算法</code>，它是一种可以平滑访问的、nginx默认的加权轮询算法，相比普通加权轮询，它在轮询访问节点时表现的更加散列。</p><p>在该算法中，每个节点有如下基本属性：</p><p><img src="http://myblog.sharemer.com/2020/08/07/20200807-1-3.png?imageView2/0/w/900" alt="图3"></p><p>结合上面几个属性，来看下SWRR算法下，选举流程是怎样的：</p><p>首先是Node信息的初始化，按照<code>图3</code>的描述，每个Node在初始化的那一刻，<code>effective_weight</code>跟它的<code>weight</code>值相等，<code>current_weight</code>都为0：</p><p><img src="http://myblog.sharemer.com/2020/08/07/20200807-1-4.png?imageView2/0/w/300" alt="图4"></p><p>然后开始pick，来看下pick的流程：</p><p><img src="http://myblog.sharemer.com/2020/08/07/20200807-1-5.png?imageView2/0/w/550" alt="图5"></p><p>每次pick，都会经历上面的流程，这样来模拟一下这个轮询过程，假设现在有三个节点，节点名为a、b、c，对应权重值为：<code>4:2:1</code>，结合上面的pick流程，它的轮询流程如下：</p><p><img src="http://myblog.sharemer.com/2020/08/07/20200807-table.png?imageView2/0/w/1024" alt="表1"></p><p>上表为<code>SWRR</code>两次轮询的执行效果，可以看到pick出来的节点<code>非常散列</code>，而且每一次轮询得到的顺序是<code>一致</code>的，且每次轮询完成后，各项指标会还原为初始状态，以此类推，它的数学推导&amp;证明请参考：<a href="http://claude-ray.com/2019/08/10/nginx-swrr/">Nginx SWRR 算法解读</a></p><h3 id="1-3：SWRR存在的问题"><a href="#1-3：SWRR存在的问题" class="headerlink" title="1.3：SWRR存在的问题"></a>1.3：SWRR存在的问题</h3><p>上面的按照SWRR模拟的pick过程很完美，但该算法依然有一些漏洞，请参考：<a href="https://www.infoq.cn/article/SEbuh0K6jI*yTfqzcihB">QPS 比 Nginx 提升 60%，阿里 Tengine 负载均衡算法揭秘</a></p><p>简单来理解，SWRR有以下缺陷：</p><ol><li>算法复杂度为<code>O(N)</code>，而且在pick节点时为了保证准确性，需要加<code>锁</code></li><li>如果<code>刷新</code>某节点的权重值，会导致该节点流量值瞬间<code>暴增</code></li></ol><p>第一点很好理解，因为每次都要选出<code>current_weight</code>最大的那个节点，必然要循环一次所有的节点。<code>第二点存疑</code>，参考上方文章评论区：</p><p><img src="http://myblog.sharemer.com/2020/08/07/20200807-1-6.png?imageView2/0/w/875" alt="图6"></p><p>我在自测过程中，在算法启动后动态调整<code>weight</code>和<code>effective_weight</code>的值是不存在这个问题的，访问依旧均匀，并不会出现大规模pick到加权节点上的情况，个人猜测他们可能是在探听到<code>weight</code>变化后，把对应节点的<code>current_weight</code>也给改掉了才可能出现这个问题。</p><h3 id="1-4：优化SWRR"><a href="#1-4：优化SWRR" class="headerlink" title="1.4：优化SWRR"></a>1.4：优化SWRR</h3><p>按照上方文章里描述，我们现在需要将<code>O(N)</code>的算法变成<code>O(1)</code>，这样不仅仅性能迅速提升，pick时也<code>无需加锁</code>，对于使用SWRR算法来说是个不错的选择，那如何实现O(1)呢？<code>表1</code>告诉我们，按照算法pick出的节点是有规律性的，以权重和为模来界定一次轮询，而每个轮询窗口内的节点散列顺序完全一致，那么这样优化起来就简单多了：</p><p><img src="http://myblog.sharemer.com/2020/08/07/20200807-1-7.png?imageView2/0/w/1024" alt="图7"></p><p>经过上图里展示的方法，做一层转换，即可达成<code>O(1)</code>成就，这样在高QPS时的效率会显著提升，后续如果有节点信息变更，只需要以同样的方式，刷新虚拟节点有序集合即可。</p><h2 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h2><p>这里采用JAVA语言来实现：</p><figure class="highlight java"><figcaption><span>代码块1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WrrLoadBalancer</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> effectiveWeightSum; <span class="comment">//总权重值</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Node[] virtualNodes; <span class="comment">//虚拟节点有序集</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> AtomicLong pointer; <span class="comment">//pick次数</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WrrLoadBalancer</span><span class="params">(Node... nodes)</span> &#123;</span><br><span class="line">        refreshVirtual(nodes);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//刷新虚拟节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refreshVirtual</span><span class="params">(Node... nodes)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node node : nodes) &#123;</span><br><span class="line">            total += node.getEffectiveWeight(); <span class="comment">//累加total</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newEffectiveWeightSum</span> <span class="operator">=</span> total;</span><br><span class="line">        Node[] newVirtualNodes = <span class="keyword">new</span> <span class="title class_">Node</span>[newEffectiveWeightSum];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; newEffectiveWeightSum; i++) &#123;</span><br><span class="line">            newVirtualNodes[i] = pickInit(newEffectiveWeightSum, nodes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.virtualNodes = newVirtualNodes;</span><br><span class="line">        <span class="built_in">this</span>.effectiveWeightSum = newEffectiveWeightSum;</span><br><span class="line">        pointer = <span class="keyword">new</span> <span class="title class_">AtomicLong</span>((<span class="type">long</span>) (Math.random() * effectiveWeightSum)); <span class="comment">//随机开始位置</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">pickInit</span><span class="params">(<span class="type">int</span> effectiveWeightSum, Node... nodes)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">picked</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node node : nodes) &#123;</span><br><span class="line">            node.refreshCurrentWeight();</span><br><span class="line">            <span class="keyword">if</span> (picked == <span class="literal">null</span>) &#123;</span><br><span class="line">                picked = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (picked.getCurrentWeight() &lt; node.getCurrentWeight()) &#123;</span><br><span class="line">                    picked = node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (picked == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;wrr pick error!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> picked.pick(effectiveWeightSum);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">pick</span><span class="params">()</span> &#123; <span class="comment">//注：更新节点时，可能下标溢出</span></span><br><span class="line">        <span class="keyword">return</span> virtualNodes[(<span class="type">int</span>) (pointer.incrementAndGet() % effectiveWeightSum)];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String host;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 用户所配的权重</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">weight</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 有效权重，正常情况下，该值等于weight，但是当node本身发生错误时，</span></span><br><span class="line">        <span class="comment">// 会适当降低该值，后面被选中一次，若不报错，则累加该值，顺利的话最后会再次恢复到weight</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">effectiveWeight</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//后端目前的权重，一开始为0，后期动态调整，选节点的依据，谁这个值最大就选谁</span></span><br><span class="line">        <span class="comment">//计算方式，每次被选中，</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">currentWeight</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(String host, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.host = host;</span><br><span class="line">            <span class="built_in">this</span>.weight.set(weight);</span><br><span class="line">            <span class="built_in">this</span>.effectiveWeight.set(weight);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> Node <span class="title function_">pick</span><span class="params">(<span class="type">int</span> total)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//节点被选中后，需要&quot;降权&quot;，即减去Sum(effective_weight)</span></span><br><span class="line">                <span class="built_in">this</span>.currentWeight.addAndGet(total * -<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//刷新currentWeight值，使其累加当前的effectiveWeight值</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refreshCurrentWeight</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.currentWeight.getAndAdd(<span class="built_in">this</span>.effectiveWeight.get());</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//刷新effectiveWeight值</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getEffectiveWeight</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.effectiveWeight.get();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCurrentWeight</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.currentWeight.get();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getHost</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> host;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、算法验证"><a href="#四、算法验证" class="headerlink" title="四、算法验证"></a>四、算法验证</h2><p>算法的验证会以实际压测的方式来进行，请前往：<a href="https://exceting.github.io/2020/08/28/WRR%E7%AE%97%E6%B3%95%E9%AA%8C%E8%AF%81%E5%AE%9E%E9%AA%8C/">WRR算法验证实验</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、工作流程&quot;&gt;&lt;a href=&quot;#一、工作流程&quot; class=&quot;headerlink&quot; title=&quot;一、工作流程&quot;&gt;&lt;/a&gt;一、工作流程&lt;/h2&gt;&lt;h3 id=&quot;1-1：实现加权轮询的方式&quot;&gt;&lt;a href=&quot;#1-1：实现加权轮询的方式&quot; class=&quot;headerlink&quot; title=&quot;1.1：实现加权轮询的方式&quot;&gt;&lt;/a&gt;1.1：实现加权轮询的方式&lt;/h3&gt;&lt;p&gt;WRR叫做加权轮询算法，相比普通的轮询算法，它支持给每个节点配置权重，权重越大，越容易被访问，且符合轮询的特点。&lt;/p&gt;</summary>
    
    
    
    <category term="服务治理" scheme="http://example.com/categories/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    
    
    <category term="负载均衡" scheme="http://example.com/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
    <category term="服务治理" scheme="http://example.com/tags/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>定制grpc负载均衡器</title>
    <link href="http://example.com/2020/08/06/%E5%AE%9A%E5%88%B6grpc%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8/"/>
    <id>http://example.com/2020/08/06/%E5%AE%9A%E5%88%B6grpc%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8/</id>
    <published>2020-08-06T13:46:00.000Z</published>
    <updated>2023-12-04T02:40:38.083Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、负载均衡器是如何被grpc加载的"><a href="#一、负载均衡器是如何被grpc加载的" class="headerlink" title="一、负载均衡器是如何被grpc加载的"></a>一、负载均衡器是如何被grpc加载的</h2><h3 id="1-1：提供provider类"><a href="#1-1：提供provider类" class="headerlink" title="1.1：提供provider类"></a>1.1：提供provider类</h3><p>每个<code>LoadBalancer</code>对象都是通过一个对象来实例化的，不同的<code>LoadBalancerProvider</code>对象会实例化出不同的<code>LoadBalancer</code>对象，而<code>LoadBalancerProvider</code>对象会通过<code>SPI机制</code>载入到grpc的客户端中，比如在<code>grpc-core</code>里的<code>MATE-INF</code>下：</p><span id="more"></span><p><img src="http://myblog.sharemer.com/2020/08/06/20200806-1-1.png?imageView2/0/w/1024" alt="图1"></p><p>由此可知，grpc原生共提供了两种LoadBalancerProvider，那看看它有关核心方法的实现：</p><p>首先是<code>PickFirstLoadBalancerProvider</code>：</p><figure class="highlight java"><figcaption><span>代码块1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">PickFirstLoadBalancerProvider</span> <span class="keyword">extends</span> <span class="title class_">LoadBalancerProvider</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NO_CONFIG</span> <span class="operator">=</span> <span class="string">&quot;no service config&quot;</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAvailable</span><span class="params">()</span> &#123; <span class="comment">//是否有效（若置为false，即便你在grpc client指定了该lb算法，那么它也不会生效）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPriority</span><span class="params">()</span> &#123; <span class="comment">//优先级</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getPolicyName</span><span class="params">()</span> &#123; <span class="comment">//lb算法的名称</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;pick_first&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> LoadBalancer <span class="title function_">newLoadBalancer</span><span class="params">(LoadBalancer.Helper helper)</span> &#123; <span class="comment">//提供对应的LoadBalancer对象，可以看到，这个实现类为PickFirstLoadBalancer</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PickFirstLoadBalancer</span>(helper);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> ConfigOrError <span class="title function_">parseLoadBalancingPolicyConfig</span><span class="params">(Map&lt;String, ?&gt; rawLoadBalancingPolicyConfig)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ConfigOrError.fromConfig(NO_CONFIG);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次是<code>SecretRoundRobinLoadBalancerProvider.Provider</code>：</p><figure class="highlight java"><figcaption><span>代码块2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SecretRoundRobinLoadBalancerProvider</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">SecretRoundRobinLoadBalancerProvider</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Provider</span> <span class="keyword">extends</span> <span class="title class_">LoadBalancerProvider</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NO_CONFIG</span> <span class="operator">=</span> <span class="string">&quot;no service config&quot;</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAvailable</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPriority</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPolicyName</span><span class="params">()</span> &#123; <span class="comment">//这里则是返回round robin的lb算法名称</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;round_robin&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> LoadBalancer <span class="title function_">newLoadBalancer</span><span class="params">(LoadBalancer.Helper helper)</span> &#123; <span class="comment">//提供对应的LoadBalancer对象，可以看到，这个实现类为RoundRobinLoadBalancer</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RoundRobinLoadBalancer</span>(helper);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ConfigOrError <span class="title function_">parseLoadBalancingPolicyConfig</span><span class="params">(</span></span><br><span class="line"><span class="params">        Map&lt;String, ?&gt; rawLoadBalancingPolicyConfig)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ConfigOrError.fromConfig(NO_CONFIG);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了不同的LoadBalancerProvider类去实例化不同的LB算法，就可以扩展并指定不同的LB算法了，我们也可以效仿这种做法，来搞一套我们自己的LB算法做替换。</p><h3 id="1-2：提供LoadBalancer的实现"><a href="#1-2：提供LoadBalancer的实现" class="headerlink" title="1.2：提供LoadBalancer的实现"></a>1.2：提供LoadBalancer的实现</h3><p>上面是LB算法的实例提供方，那必定存在LB算法的实现方，上面两个Provider分别提供了一个对应的LB算法实现类，即：<code>RoundRobinLoadBalancer</code> &amp; <code>PickFirstLoadBalancer</code></p><p>因为我们使用的是轮询，因此只说明下RoundRobinLoadBalancer即可。</p><p>因为源代码过于复杂，这里仅展示出关键步骤（感兴趣可以直接查看<code>io.grpc.util.RoundRobinLoadBalancer</code>，嫌看代码麻烦，可以调到下方<code>图2</code>，快速浏览其过程）：</p><figure class="highlight java"><figcaption><span>代码块3</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoundRobinLoadBalancer</span> <span class="keyword">extends</span> <span class="title class_">LoadBalancer</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@VisibleForTesting</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Attributes.Key&lt;Ref&lt;ConnectivityStateInfo&gt;&gt; STATE_INFO = Attributes.Key.create(<span class="string">&quot;state-info&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Status</span> <span class="variable">EMPTY_OK</span> <span class="operator">=</span> Status.OK.withDescription(<span class="string">&quot;no subchannels ready&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Helper helper; <span class="comment">//负责创建channel、将picker传出去</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;EquivalentAddressGroup, Subchannel&gt; subchannels = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">//保存channel用的</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> ConnectivityState currentState; <span class="comment">//最近一次建连的连接状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">WeightRoundRobinPicker</span> <span class="variable">currentPicker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmptyPicker</span>(EMPTY_OK); <span class="comment">//最近一次建连后的picker对象，正常情况下会被刷成ReadyPicker</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeightRoundRobinLoadBalancer</span><span class="params">(Helper helper)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.helper = checkNotNull(helper, <span class="string">&quot;helper&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 刷新节点，每当服务发现更新了节点，都会通知到该方法，用来更新现有参与LB的节点信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resolvedAddresses 新节点集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleResolvedAddresses</span><span class="params">(ResolvedAddresses resolvedAddresses)</span> &#123;</span><br><span class="line">        List&lt;EquivalentAddressGroup&gt; servers = resolvedAddresses.getAddresses();</span><br><span class="line">        Set&lt;EquivalentAddressGroup&gt; currentAddrs = subchannels.keySet(); <span class="comment">//当前节点集合</span></span><br><span class="line">        Map&lt;EquivalentAddressGroup, EquivalentAddressGroup&gt; latestAddrs = stripAttrs(servers); <span class="comment">//最新节点集合</span></span><br><span class="line">        <span class="comment">//因为是更新address，所以这里需要过滤出来旧版需要被移除的部分</span></span><br><span class="line">        Set&lt;EquivalentAddressGroup&gt; removedAddrs = setsDifference(currentAddrs, latestAddrs.keySet());</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//遍历新节点</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;EquivalentAddressGroup, EquivalentAddressGroup&gt; latestEntry : latestAddrs.entrySet()) &#123;</span><br><span class="line">            <span class="type">EquivalentAddressGroup</span> <span class="variable">strippedAddressGroup</span> <span class="operator">=</span> latestEntry.getKey(); <span class="comment">//新节点的节点信息（参考stripAttrs方法）</span></span><br><span class="line">            <span class="type">EquivalentAddressGroup</span> <span class="variable">originalAddressGroup</span> <span class="operator">=</span> latestEntry.getValue(); <span class="comment">//新节点的完整信息</span></span><br><span class="line">            <span class="type">Subchannel</span> <span class="variable">existingSubchannel</span> <span class="operator">=</span> subchannels.get(strippedAddressGroup); <span class="comment">//尝试在老节点查找新入的节点</span></span><br><span class="line">            <span class="keyword">if</span> (existingSubchannel != <span class="literal">null</span>) &#123; <span class="comment">//若老节点原本就存在该节点，则触发下方逻辑</span></span><br><span class="line">                <span class="comment">// 新拉取到的节点，它的Attributes可能被改变（附带信息，比如服务发现上节点的权重值前后发生变化），这里需要刷新</span></span><br><span class="line">                existingSubchannel.updateAddresses(Collections.singletonList(originalAddressGroup));</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若老节点不存在，则说明需要new一个新的subchannel</span></span><br><span class="line">            Attributes.<span class="type">Builder</span> <span class="variable">subchannelAttrs</span> <span class="operator">=</span> Attributes.newBuilder().set(STATE_INFO,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Ref</span>&lt;&gt;(ConnectivityStateInfo.forNonError(IDLE))); <span class="comment">//设置节点初始状态，通过Ref可以修改状态引用</span></span><br><span class="line"> </span><br><span class="line">            <span class="keyword">final</span> <span class="type">Subchannel</span> <span class="variable">subchannel</span> <span class="operator">=</span> checkNotNull(</span><br><span class="line">                helper.createSubchannel(CreateSubchannelArgs.newBuilder()</span><br><span class="line">                    .setAddresses(originalAddressGroup)</span><br><span class="line">                    .setAttributes(subchannelAttrs.build())</span><br><span class="line">                    .build()),</span><br><span class="line">                <span class="string">&quot;subchannel&quot;</span>);</span><br><span class="line">            subchannel.start(<span class="keyword">new</span> <span class="title class_">SubchannelStateListener</span>() &#123; <span class="comment">//异步建连，收到建连成功的通知后，触发onSubchannelState</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSubchannelState</span><span class="params">(ConnectivityStateInfo state)</span> &#123;</span><br><span class="line">                    processSubchannelState(subchannel, state); <span class="comment">//建连完成，更新连接状态为可用（若建连没问题，则state应为READY，即就绪状态）</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            subchannels.put(strippedAddressGroup, subchannel); <span class="comment">//将连接放进集合里</span></span><br><span class="line">            subchannel.requestConnection(); <span class="comment">//触发建连的动作（建连动作处理完毕后，会通知上方onSubchannelState）</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        ArrayList&lt;Subchannel&gt; removedSubchannels = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (EquivalentAddressGroup addressGroup : removedAddrs) &#123;</span><br><span class="line">            <span class="comment">//去除掉需要摘除的节点</span></span><br><span class="line">            removedSubchannels.add(subchannels.remove(addressGroup));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 更新loadbalance状态</span></span><br><span class="line">        updateBalancingState();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (Subchannel removedSubchannel : removedSubchannels) &#123;</span><br><span class="line">            <span class="comment">//将需要摘除掉的节点逐个shutdown</span></span><br><span class="line">            shutdownSubchannel(removedSubchannel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleNameResolutionError</span><span class="params">(Status error)</span> &#123;</span><br><span class="line">        updateBalancingState(TRANSIENT_FAILURE, currentPicker <span class="keyword">instanceof</span> ReadyPicker ? currentPicker : <span class="keyword">new</span> <span class="title class_">EmptyPicker</span>(error));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Subchannel subchannel : getSubchannels()) &#123;</span><br><span class="line">            shutdownSubchannel(subchannel); <span class="comment">//逐个关闭所持有的连接</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//这里传入的是服务发现推给的节点集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;EquivalentAddressGroup, EquivalentAddressGroup&gt; <span class="title function_">stripAttrs</span><span class="params">(List&lt;EquivalentAddressGroup&gt; groupList)</span> &#123;</span><br><span class="line">        Map&lt;EquivalentAddressGroup, EquivalentAddressGroup&gt; addrs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(groupList.size() * <span class="number">2</span>); <span class="comment">//为什么要扩2倍？</span></span><br><span class="line">        <span class="keyword">for</span> (EquivalentAddressGroup group : groupList) &#123;</span><br><span class="line">            <span class="comment">//一个map，k是包含了相同address的一个全新EquivalentAddressGroup对象，v是原始的EquivalentAddressGroup对象</span></span><br><span class="line">            addrs.put(stripAttrs(group), group);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> addrs;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EquivalentAddressGroup <span class="title function_">stripAttrs</span><span class="params">(EquivalentAddressGroup eag)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EquivalentAddressGroup</span>(eag.getAddresses());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//用来更新连接状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processSubchannelState</span><span class="params">(Subchannel subchannel, ConnectivityStateInfo stateInfo)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (subchannels.get(stripAttrs(subchannel.getAddresses())) != subchannel) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stateInfo.getState() == IDLE) &#123;</span><br><span class="line">            subchannel.requestConnection(); <span class="comment">//如果是闲置状态，则触发建连操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拿到当前channel的state</span></span><br><span class="line">        Ref&lt;ConnectivityStateInfo&gt; subchannelStateRef = getSubchannelStateInfoRef(subchannel);</span><br><span class="line">        <span class="keyword">if</span> (subchannelStateRef.value.getState().equals(TRANSIENT_FAILURE)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stateInfo.getState().equals(CONNECTING) || stateInfo.getState().equals(IDLE)) &#123;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">//若连接处于故障状态，则不允许改成&quot;连接中&quot;和&quot;闲置&quot;状态</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        subchannelStateRef.value = stateInfo; <span class="comment">//修改状态</span></span><br><span class="line">        updateBalancingState(); <span class="comment">//更新loadbalance状态</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//每次建连事件被异步触发后，都会触发一次该方法，用来刷新picker</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateBalancingState</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Subchannel&gt; activeList = filterNonFailingSubchannels(getSubchannels()); <span class="comment">//将当前就绪状态的channel过滤出来</span></span><br><span class="line">        <span class="keyword">if</span> (activeList.isEmpty()) &#123; <span class="comment">//建连触发才会走到这里，因此只要建连没出问题，一般情况下都不为空，除非这批节点没一个可用的</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isConnecting</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">Status</span> <span class="variable">aggStatus</span> <span class="operator">=</span> EMPTY_OK;</span><br><span class="line">            <span class="keyword">for</span> (Subchannel subchannel : getSubchannels()) &#123;</span><br><span class="line">                <span class="type">ConnectivityStateInfo</span> <span class="variable">stateInfo</span> <span class="operator">=</span> getSubchannelStateInfoRef(subchannel).value;</span><br><span class="line">                <span class="keyword">if</span> (stateInfo.getState() == CONNECTING || stateInfo.getState() == IDLE) &#123;</span><br><span class="line">                    isConnecting = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (aggStatus == EMPTY_OK || !aggStatus.isOk()) &#123;</span><br><span class="line">                    aggStatus = stateInfo.getStatus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            updateBalancingState(isConnecting ? CONNECTING : TRANSIENT_FAILURE, <span class="keyword">new</span> <span class="title class_">EmptyPicker</span>(aggStatus));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            updateBalancingState(READY, <span class="keyword">new</span> <span class="title class_">ReadyPicker</span>(activeList)); <span class="comment">//可以看到，最后会将建连成功的节点丢到ReadyPicker里，用来做lb</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//更新picker的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateBalancingState</span><span class="params">(ConnectivityState state, WeightRoundRobinPicker picker)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (state != currentState || !picker.isEquivalentTo(currentPicker)) &#123;</span><br><span class="line">            helper.updateBalancingState(state, picker); <span class="comment">//非常重要的一步，负责将当前的picker送出去，给ManagedChannelImpl使用，client请求时会触发picker的pickSubchannel方法</span></span><br><span class="line">            currentState = state; <span class="comment">//刷新连接状态</span></span><br><span class="line">            currentPicker = picker; <span class="comment">//刷新picker对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程简图（不同方法已用不同颜色标出）：</p><p><img src="http://myblog.sharemer.com/2020/08/06/20200806-1-2.png?imageView2/0/w/1024" alt="图2"></p><h3 id="1-3：提供LoadBalancer-SubchannelPicker实现"><a href="#1-3：提供LoadBalancer-SubchannelPicker实现" class="headerlink" title="1.3：提供LoadBalancer.SubchannelPicker实现"></a>1.3：提供LoadBalancer.SubchannelPicker实现</h3><p>上面说了那么多，都只是在为真正的LB做准备，实际的LB算法保存在Picker类里，我们来看下上文中出现的<code>ReadyPicker</code>的主要方法实现：</p><figure class="highlight java"><figcaption><span>代码块4</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ReadyPicker</span> <span class="keyword">extends</span> <span class="title class_">RoundRobinPicker</span> &#123; <span class="comment">//RoundRobinPicker继承了LoadBalancer.SubchannelPicker</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicIntegerFieldUpdater&lt;ReadyPicker&gt; indexUpdater =</span><br><span class="line">            AtomicIntegerFieldUpdater.newUpdater(ReadyPicker.class, <span class="string">&quot;index&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Subchannel&gt; list; <span class="comment">// 这里保存的就是当前已就绪的channel（结合图2里ReadyPicker的初始化理解）</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> index;</span><br><span class="line"> </span><br><span class="line">    ReadyPicker(List&lt;Subchannel&gt; list, <span class="type">int</span> startIndex) &#123;</span><br><span class="line">        Preconditions.checkArgument(!list.isEmpty(), <span class="string">&quot;empty list&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">        <span class="built_in">this</span>.index = startIndex - <span class="number">1</span>; <span class="comment">//轮询算法开始的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PickResult <span class="title function_">pickSubchannel</span><span class="params">(PickSubchannelArgs args)</span> &#123; <span class="comment">//实现了pickSubchannel方法，该方法就是对外pick节点的核心方法</span></span><br><span class="line">        <span class="keyword">return</span> PickResult.withSubchannel(nextSubchannel()); <span class="comment">//nextSubchannel里放的就是轮询算法的核心代码了</span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> Subchannel <span class="title function_">nextSubchannel</span><span class="params">()</span> &#123; <span class="comment">//轮询算法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexUpdater.incrementAndGet(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">oldi</span> <span class="operator">=</span> i;</span><br><span class="line">            i %= size;</span><br><span class="line">            indexUpdater.compareAndSet(<span class="built_in">this</span>, oldi, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isEquivalentTo</span><span class="params">(RoundRobinPicker picker)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(picker <span class="keyword">instanceof</span> ReadyPicker)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ReadyPicker</span> <span class="variable">other</span> <span class="operator">=</span> (ReadyPicker) picker;</span><br><span class="line">        <span class="keyword">return</span> other == <span class="built_in">this</span></span><br><span class="line">                || (list.size() == other.list.size() &amp;&amp; <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(list).containsAll(other.list));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是LB的核心算法，重点是pickSubchannel方法，它是LB算法的触发类。</p><h3 id="1-4：grpc-client指定LB算法"><a href="#1-4：grpc-client指定LB算法" class="headerlink" title="1.4：grpc client指定LB算法"></a>1.4：grpc client指定LB算法</h3><p>正常一个client channel的创建方式如下：</p><figure class="highlight java"><figcaption><span>代码块5</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ChannelBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> ChannelBuilder.forTarget(<span class="string">&quot;这里填服务的discovery_id&quot;</span>)</span><br><span class="line">            <span class="comment">//这个方法用来设置一个继承了io.grpc.NameResolverProvider的服务发现，可以定制</span></span><br><span class="line">            .nameResolverFactory(<span class="keyword">new</span> <span class="title class_">RPCNamingClientNameResolverFactory</span>(zone, resolver, cluster))</span><br><span class="line">            .disableRetry() <span class="comment">//禁止重试</span></span><br><span class="line">            <span class="comment">//这里就是用来启用对应的LB模块了，还记得xxxProvider里的getPolicyName方法吗？这里跟那里面返回的名称匹配，匹配后即可启用对应的LB服务</span></span><br><span class="line">            .defaultLoadBalancingPolicy(<span class="string">&quot;round_robin&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="type">ManagedChannel</span> <span class="variable">channel</span> <span class="operator">=</span> builder.build(); <span class="comment">//这样一个grpc的channel client就被创建出来了</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到grpc client通过<code>defaultLoadBalancingPolicy</code>方法利用LB的名称指定了一个默认负载均衡器。</p><h2 id="二、在grpc里定制自己的LB算法"><a href="#二、在grpc里定制自己的LB算法" class="headerlink" title="二、在grpc里定制自己的LB算法"></a>二、在grpc里定制自己的LB算法</h2><p>经过对第一部分的理解，想要在grpc里定制自己的LB算法就变得简单多了，只需要以下几步：</p><ol><li>定义一个继承了<code>LoadBalancer.SubchannelPicker</code>类的XXXPicker，然后通过实现<code>pickSubchannel方法</code>实现自己的LB逻辑</li><li>定义一个继承了<code>LoadBalancer</code>的XXXLoadBalancer，用来管理连接以及提供对应的<code>Picker对象</code></li><li>定义一个继承了<code>LoadBalancerProvider</code>的Provider，然后将其按照<code>SPI规范</code>放到自己项目的<code>META-INF</code>下，通过<code>newLoadBalancer方法</code>提供对应的LoadBalancer对象</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、负载均衡器是如何被grpc加载的&quot;&gt;&lt;a href=&quot;#一、负载均衡器是如何被grpc加载的&quot; class=&quot;headerlink&quot; title=&quot;一、负载均衡器是如何被grpc加载的&quot;&gt;&lt;/a&gt;一、负载均衡器是如何被grpc加载的&lt;/h2&gt;&lt;h3 id=&quot;1-1：提供provider类&quot;&gt;&lt;a href=&quot;#1-1：提供provider类&quot; class=&quot;headerlink&quot; title=&quot;1.1：提供provider类&quot;&gt;&lt;/a&gt;1.1：提供provider类&lt;/h3&gt;&lt;p&gt;每个&lt;code&gt;LoadBalancer&lt;/code&gt;对象都是通过一个对象来实例化的，不同的&lt;code&gt;LoadBalancerProvider&lt;/code&gt;对象会实例化出不同的&lt;code&gt;LoadBalancer&lt;/code&gt;对象，而&lt;code&gt;LoadBalancerProvider&lt;/code&gt;对象会通过&lt;code&gt;SPI机制&lt;/code&gt;载入到grpc的客户端中，比如在&lt;code&gt;grpc-core&lt;/code&gt;里的&lt;code&gt;MATE-INF&lt;/code&gt;下：&lt;/p&gt;</summary>
    
    
    
    <category term="gRPC" scheme="http://example.com/categories/gRPC/"/>
    
    
    <category term="微服务" scheme="http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="gRPC" scheme="http://example.com/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>【旅行】济源游记-20200517</title>
    <link href="http://example.com/2020/06/08/%E3%80%90%E6%97%85%E8%A1%8C%E3%80%91%E6%B5%8E%E6%BA%90%E6%B8%B8%E8%AE%B0-20200517/"/>
    <id>http://example.com/2020/06/08/%E3%80%90%E6%97%85%E8%A1%8C%E3%80%91%E6%B5%8E%E6%BA%90%E6%B8%B8%E8%AE%B0-20200517/</id>
    <published>2020-06-08T12:24:00.000Z</published>
    <updated>2023-12-05T02:42:27.563Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>⏱ 旅行时间线：2020-05-15 ~ 2020-05-17</p><p>🌏 地点：河南省 · 济源市</p><p>🌿 景点：黄河三峡、王屋山</p><p>⚜️ 级别：AAAA</p></blockquote><span id="more"></span><h2 id="出发（2020-05-15）"><a href="#出发（2020-05-15）" class="headerlink" title="出发（2020.05.15）"></a>出发（2020.05.15）</h2><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-1.jpg" alt="高铁沿途1"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-2.jpg" alt="高铁沿途2"></p><h2 id="留宿（2020-05-15）"><a href="#留宿（2020-05-15）" class="headerlink" title="留宿（2020.05.15）"></a>留宿（2020.05.15）</h2><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-3.jpg" alt="到站"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-4.jpg" alt="焦作农家乐，已是傍晚"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-5.jpg" alt="第二天清早，前往济源"></p><h2 id="黄河三峡（2020-05-16）"><a href="#黄河三峡（2020-05-16）" class="headerlink" title="黄河三峡（2020.05.16）"></a>黄河三峡（2020.05.16）</h2><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-6.jpg" alt="索道"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-7.jpg" alt="导游说这是个展翅的凤凰😂"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-8.jpg" alt="远处的亭子"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-9.jpg" alt="岩壁"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-10.jpg" alt="溶洞1"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-11.jpg" alt="溶洞2"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-12.jpg" alt="古人类の骨"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-13.jpg" alt="水库远眺"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-14.jpg" alt="悬崖"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-15.jpg" alt="玻璃桥"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-16.jpg" alt="即将到达玻璃桥"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-17.jpg" alt="黄河三峡1"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-18.jpg" alt="黄河三峡2"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-19.jpg" alt="玻璃桥上看整座山"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-20.jpg" alt="黄河三峡3"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-21.jpg" alt="远观玻璃桥"></p><h2 id="老街（2020-05-16）"><a href="#老街（2020-05-16）" class="headerlink" title="老街（2020.05.16）"></a>老街（2020.05.16）</h2><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-22.jpg" alt="傍晚，即将前往古城"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-23.jpg" alt="+1s"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-24.jpg" alt="道德经"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-25.jpg" alt="老街的塔"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-26.jpg" alt="老街一角"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-27.jpg" alt="楝树"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-28.jpg" alt="楝树花"></p><h2 id="王屋山（2020-05-17）"><a href="#王屋山（2020-05-17）" class="headerlink" title="王屋山（2020.05.17）"></a>王屋山（2020.05.17）</h2><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-29.jpg" alt="次日上午，前往王屋山"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-30.jpg" alt="爬山中..."></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-31.jpg" alt="爬山中..."></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-32.jpg" alt="爬山中..."></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-33.jpg" alt="快到山顶了~"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-34.jpg" alt="山顶！！"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-35.jpg" alt="顶部观景台"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-36.jpg" alt="天坛极顶"></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;⏱ 旅行时间线：2020-05-15 ~ 2020-05-17&lt;/p&gt;
&lt;p&gt;🌏 地点：河南省 · 济源市&lt;/p&gt;
&lt;p&gt;🌿 景点：黄河三峡、王屋山&lt;/p&gt;
&lt;p&gt;⚜️ 级别：AAAA&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="旅行" scheme="http://example.com/tags/%E6%97%85%E8%A1%8C/"/>
    
    <category term="摄影" scheme="http://example.com/tags/%E6%91%84%E5%BD%B1/"/>
    
    <category term="日常" scheme="http://example.com/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>详解JDBC的Loadbalance模式</title>
    <link href="http://example.com/2020/06/02/%E8%AF%A6%E8%A7%A3JDBC%E7%9A%84Loadbalance%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2020/06/02/%E8%AF%A6%E8%A7%A3JDBC%E7%9A%84Loadbalance%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-02T12:21:00.000Z</published>
    <updated>2023-12-04T02:49:27.898Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基于依赖程序的版本信息：<img src="https://img.shields.io/badge/mysql--connector--java-v8.0.17-green"/></p></blockquote><h2 id="一、认识loadbalance模式"><a href="#一、认识loadbalance模式" class="headerlink" title="一、认识loadbalance模式"></a>一、认识loadbalance模式</h2><p>首先回忆下jdbc协议头都有哪些，下面总结下：</p><p><img src="http://myblog.sharemer.com/2020/06/02/20200602-1-1.png" alt="表1"></p><span id="more"></span><p>通过<code>表1</code>，可以知道在loadblance模式下允许配置多个mysql节点信息，而我们每次建连时，驱动程序就会按照配置的节点，选中一个，然后完成连接的创建，下面我们来探索下它的实现。</p><h2 id="二、基本使用"><a href="#二、基本使用" class="headerlink" title="二、基本使用"></a>二、基本使用</h2><p>它的基本用法跟其他模式没有区别：</p><figure class="highlight java"><figcaption><span>代码块1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql:loadbalance://127.0.0.1:3306,127.0.0.2:3306,127.0.0.3:3306/mydb&quot;</span>;</span><br><span class="line">    <span class="type">LoadBalancedConnection</span> <span class="variable">connection</span> <span class="operator">=</span> (LoadBalancedConnection) DriverManager.getConnection(url, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (statement.execute(<span class="string">&quot;select * from t_season&quot;</span>)) &#123;</span><br><span class="line">            rs = statement.getResultSet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rs != <span class="literal">null</span>) &#123;</span><br><span class="line">            rs.close();</span><br><span class="line">        &#125;</span><br><span class="line">        statement.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、驱动加载流程"><a href="#三、驱动加载流程" class="headerlink" title="三、驱动加载流程"></a>三、驱动加载流程</h2><p>jdbc是如何知道我们启用了loadbalance模式的？先来了解下<code>DriverManager</code>的<code>getConnection</code>方法，注意这里的DriverManager在java.sql包内，它属于jdk自带的类，目的是扫描所有实现了java.sql.Driver的类，而我们所使用的<code>mysql-connector-java</code>程序就实现了Driver接口，所以很容易被DriverManager载入，下面来看它是如何完成驱动程序扫描与加载的：</p><figure class="highlight java"><figcaption><span>代码块2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">(String url,</span></span><br><span class="line"><span class="params">                                       String user, String password)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    java.util.<span class="type">Properties</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.util.Properties();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">        info.put(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (password != <span class="literal">null</span>) &#123;</span><br><span class="line">        info.put(<span class="string">&quot;password&quot;</span>, password);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//说明：Reflection.getCallerClass()是个本地方法，会返回调用当前这个方法的那个类的名字（后续我们称其为callerClass）</span></span><br><span class="line">    <span class="keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">(</span></span><br><span class="line"><span class="params">        String url, java.util.Properties info, Class&lt;?&gt; caller)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//获取callerClass的类加载器</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">callerCL</span> <span class="operator">=</span> caller != <span class="literal">null</span> ? caller.getClassLoader() : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (callerCL == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//若找不到对应的类加载器，则默认为当前线程的类加载器</span></span><br><span class="line">        callerCL = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (url == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(<span class="string">&quot;The url cannot be null&quot;</span>, <span class="string">&quot;08001&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    println(<span class="string">&quot;DriverManager.getConnection(\&quot;&quot;</span> + url + <span class="string">&quot;\&quot;)&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//这个方法会通过SPI机制加载可以加载的实现了JDBC协议的驱动程序，我们通常用的是mysql-connector-java里的驱动类，某些连接池技术也会搞一个自己的驱动类（比如Druid的DruidDriver）</span></span><br><span class="line">    <span class="comment">//在里面会完成Driver实现类的类加载，而驱动程序只需要在静态块里将自己的实例new出来，注册到DriverManager里即可（可以去mysql-connector-java的Driver类里确认是否有该逻辑）</span></span><br><span class="line">    <span class="comment">//所以现在我们根本不需要跟以前写jdbc程序那样写一次Class.forName的代码，这个方法已经帮我们做了（参考图1，驱动程序已经满足SPI加载配置的条件）</span></span><br><span class="line">    ensureDriversInitialized();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Walk through the loaded registeredDrivers attempting to make a connection.</span></span><br><span class="line">    <span class="comment">// Remember the first exception that gets raised so we can reraise it.</span></span><br><span class="line">    <span class="type">SQLException</span> <span class="variable">reason</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (DriverInfo aDriver : registeredDrivers) &#123; <span class="comment">//循环已经成功加载到的驱动实现</span></span><br><span class="line">        <span class="comment">// If the caller does not have permission to load the driver then</span></span><br><span class="line">        <span class="comment">// skip it.</span></span><br><span class="line">        <span class="keyword">if</span> (isDriverAllowed(aDriver.driver, callerCL)) &#123; <span class="comment">//这个解释在下面对应的方法里，还是挺有意思的一个方法</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                println(<span class="string">&quot;    trying &quot;</span> + aDriver.driver.getClass().getName());</span><br><span class="line">                <span class="comment">//这里是利用驱动程序获取到一个Connection对象，后面会详细讲</span></span><br><span class="line">                <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> aDriver.driver.connect(url, info);</span><br><span class="line">                <span class="keyword">if</span> (con != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Success!</span></span><br><span class="line">                    println(<span class="string">&quot;getConnection returning &quot;</span> + aDriver.driver.getClass().getName());</span><br><span class="line">                    <span class="keyword">return</span> (con);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (reason == <span class="literal">null</span>) &#123;</span><br><span class="line">                    reason = ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            println(<span class="string">&quot;    skipping: &quot;</span> + aDriver.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// if we got here nobody could connect.</span></span><br><span class="line">    <span class="keyword">if</span> (reason != <span class="literal">null</span>)    &#123;</span><br><span class="line">        println(<span class="string">&quot;getConnection failed: &quot;</span> + reason);</span><br><span class="line">        <span class="keyword">throw</span> reason;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    println(<span class="string">&quot;getConnection: no suitable driver found for &quot;</span>+ url);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(<span class="string">&quot;No suitable driver found for &quot;</span>+ url, <span class="string">&quot;08001&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isDriverAllowed</span><span class="params">(Driver driver, Class&lt;?&gt; caller)</span> &#123;</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">callerCL</span> <span class="operator">=</span> caller != <span class="literal">null</span> ? caller.getClassLoader() : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> isDriverAllowed(driver, callerCL);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//该方法主要用来做驱动加载，以及判断加载了驱动Driver对象的类加载器跟callerClass的类加载器是否一致，若一致才返回true，反之为false</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isDriverAllowed</span><span class="params">(Driver driver, ClassLoader classLoader)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (driver != <span class="literal">null</span>) &#123;</span><br><span class="line">        Class&lt;?&gt; aClass = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//这里算是给驱动类调整了类加载器，将第一次进行类加载时加载到的Class对象里的类加载器统一成callerClass的</span></span><br><span class="line">            aClass =  Class.forName(driver.getClass().getName(), <span class="literal">true</span>, classLoader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            result = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里会再确认一次driver对象此时对应的Class是否跟被调整了类加载器的Class一致（如果不出意外，这里应该是一致的）</span></span><br><span class="line">        result = ( aClass == driver.getClass() ) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>驱动程序的<code>SPI</code>支持：</p><p><img src="http://myblog.sharemer.com/2020/06/02/20200602-1-2.png" alt="图1"></p><p>通过上述代码，可以确认最终是通过<code>驱动程序Driver实现类</code>的<code>connect方法</code>产生的<code>Connection对象</code>，下面来看下驱动程序Driver里的实现：</p><figure class="highlight java"><figcaption><span>代码块3</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码所属类：com.mysql.cj.jdbc.NonRegisteringDriver</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> java.sql.Connection <span class="title function_">connect</span><span class="params">(String url, Properties info)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//验证传入的url是否符合jdbc连接规范</span></span><br><span class="line">        <span class="keyword">if</span> (!ConnectionUrl.acceptsUrl(url)) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * According to JDBC spec:</span></span><br><span class="line"><span class="comment">             * The driver should return &quot;null&quot; if it realizes it is the wrong kind of driver to connect to the given URL. This will be common, as when the</span></span><br><span class="line"><span class="comment">             * JDBC driver manager is asked to connect to a given URL it passes the URL to each loaded driver in turn.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//根据传入的信息，获得一个包装了连接信息的对象</span></span><br><span class="line">        <span class="type">ConnectionUrl</span> <span class="variable">conStr</span> <span class="operator">=</span> ConnectionUrl.getConnectionUrlInstance(url, info);</span><br><span class="line">        <span class="keyword">switch</span> (conStr.getType()) &#123; <span class="comment">//这个Type是根据jdbc协议头分析出来的，应该给一个对应协议头类型的Connection实例</span></span><br><span class="line">            <span class="keyword">case</span> SINGLE_CONNECTION: <span class="comment">//jdbc:mysql:开头的url会命中下方逻辑</span></span><br><span class="line">                <span class="keyword">return</span> com.mysql.cj.jdbc.ConnectionImpl.getInstance(conStr.getMainHost());</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">case</span> LOADBALANCE_CONNECTION: <span class="comment">//jdbc:mysql:loadbalance:开头的url会命中下方逻辑（负载均衡），也是本节要讲的重点</span></span><br><span class="line">                <span class="keyword">return</span> LoadBalancedConnectionProxy.createProxyInstance((LoadbalanceConnectionUrl) conStr);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">case</span> FAILOVER_CONNECTION: <span class="comment">//jdbc:mysql:开头且配置了多个节点的情况会命中下方逻辑（故障转移）</span></span><br><span class="line">                <span class="keyword">return</span> FailoverConnectionProxy.createProxyInstance(conStr);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">case</span> REPLICATION_CONNECTION: <span class="comment">//jdbc:mysql:replication:开头的url会命中下方逻辑（主从）</span></span><br><span class="line">                <span class="keyword">return</span> ReplicationConnectionProxy.createProxyInstance((ReplicationConnectionUrl) conStr);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedConnectionStringException e) &#123;</span><br><span class="line">        <span class="comment">// when Connector/J can&#x27;t handle this connection string the Driver must return null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">catch</span> (CJException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionFactory.createException(UnableToConnectException.class,</span><br><span class="line">                Messages.getString(<span class="string">&quot;NonRegisteringDriver.17&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; ex.toString() &#125;), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，可以看到驱动程序之所以会知道我们启用了loadbalance模式，是因为我们所配置的<code>jdbc连接协议头</code>，根据协议头的不同，会被路由进不同的Connection实现，然后最终将Connection对象返回给用户。</p><h2 id="四、驱动程序对LoadBalance的支持"><a href="#四、驱动程序对LoadBalance的支持" class="headerlink" title="四、驱动程序对LoadBalance的支持"></a>四、驱动程序对LoadBalance的支持</h2><p>下面重点看下命中<code>LOADBALANCE_CONNECTION</code>条件的<code>LoadBalancedConnectionProxy.createProxyInstance</code>的内部逻辑：</p><figure class="highlight java"><figcaption><span>代码块4</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建LoadBalancedConnection对象，并为其加上动态代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LoadBalancedConnection <span class="title function_">createProxyInstance</span><span class="params">(LoadbalanceConnectionUrl connectionUrl)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="type">LoadBalancedConnectionProxy</span> <span class="variable">connProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoadBalancedConnectionProxy</span>(connectionUrl);</span><br><span class="line">    <span class="comment">//返回的是一个被LoadBalancedConnectionProxy代理了的LoadBalancedConnection对象</span></span><br><span class="line">    <span class="keyword">return</span> (LoadBalancedConnection) java.lang.reflect.Proxy.newProxyInstance(LoadBalancedConnection.class.getClassLoader(), INTERFACES_TO_PROXY, connProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1：LoadBalance模式相关的类关系图"><a href="#4-1：LoadBalance模式相关的类关系图" class="headerlink" title="4.1：LoadBalance模式相关的类关系图"></a>4.1：LoadBalance模式相关的类关系图</h3><p>到这里为止，我们已经进入了loadblance模式内部，这里返回的是一个被代理了的<code>LoadBalancedConnection</code>对象，下面来梳理下它们的继承和代理关系（之后重点分析的字段和方法字体均已<code>标红</code>）：</p><p><img src="http://myblog.sharemer.com/2020/06/02/20200602-1-3-fix.png?imageView2/0/w/1100" alt="图2"></p><p>理清关系后，来看下最主要的几个属性和方法的实现。</p><p><code>代码块4</code>里直接new出了LoadBalancedConnectionProxy类，并且代理的目标类为LoadBalancedConnection，通过上图，可以知道就是最终返回给用户的那个Connection对象，意味着用户拿着这个Connection做任何操作都会触发LoadBalancedConnectionProxy的invokeMore方法（通过图中展示，其父类实现了<code>InvocationHandler接口</code>，其<code>invoke</code>会触发<code>invokeMore</code>方法，而<code>invokeMore方法的实现在LoadBalancedConnectionProxy里</code>）</p><h3 id="4-2：LoadBalancedConnectionProxy-balancer属性"><a href="#4-2：LoadBalancedConnectionProxy-balancer属性" class="headerlink" title="4.2：LoadBalancedConnectionProxy.balancer属性"></a>4.2：LoadBalancedConnectionProxy.balancer属性</h3><p>这是个属性，它包装了一个<code>Balancer</code>对象，内部有自己的<code>LB算法</code>，它的初始化如下：</p><figure class="highlight java"><figcaption><span>代码块4</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拿到指定的LB算法，不配置的话默认是random，如果你想要指定，可以在jdbc连接后面追加haLoadBalanceStrategy参数，让其等于你指定的LB算法类型即可</span></span><br><span class="line"><span class="comment">//LB算法类型可选值在下面的switch内部，当然，你也可以自定义，自定义的话就需要传实现类的路径给这个参数了</span></span><br><span class="line"><span class="type">String</span> <span class="variable">strategy</span> <span class="operator">=</span> props.getProperty(PropertyKey.ha_loadBalanceStrategy.getKeyName(), <span class="string">&quot;random&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (strategy) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;random&quot;</span>:</span><br><span class="line">            <span class="built_in">this</span>.balancer = <span class="keyword">new</span> <span class="title class_">RandomBalanceStrategy</span>(); <span class="comment">//random算法的实现类，默认算法</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;bestResponseTime&quot;</span>:</span><br><span class="line">            <span class="built_in">this</span>.balancer = <span class="keyword">new</span> <span class="title class_">BestResponseTimeBalanceStrategy</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;serverAffinity&quot;</span>:</span><br><span class="line">            <span class="built_in">this</span>.balancer = <span class="keyword">new</span> <span class="title class_">ServerAffinityStrategy</span>(props.getProperty(PropertyKey.serverAffinityOrder.getKeyName(), <span class="literal">null</span>));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">//你可以按需自定义LB算法，这里是通过反射的方式初始化你给定的LB算法类的</span></span><br><span class="line">            <span class="built_in">this</span>.balancer = (BalanceStrategy) Class.forName(strategy).newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="keyword">throw</span> SQLError.createSQLException(Messages.getString(<span class="string">&quot;InvalidLoadBalanceStrategy&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; strategy &#125;),</span><br><span class="line">            MysqlErrorNumbers.SQL_STATE_ILLEGAL_ARGUMENT, t, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只关注<code>Random</code>即可，它的内部实现就是简单的从<code>LoadBalancedConnectionProxy.liveConnections</code>里随机选一个节点，然后返回出去，为了更加清晰，不再贴代码，大致流程如下（绿色框逻辑都属于<code>RandomBalancer</code>本身的逻辑，除此之外，图中标注了<code>hostList</code>属性的数据来源）：</p><p><img src="http://myblog.sharemer.com/2020/06/02/20200602-1-4.png?imageView2/0/w/900" alt="图3"></p><p>它的触发点就是在<code>LoadBalancedConnectionProxy.pickNewConnection</code>方法（参考下方<code>4.3</code>），即发生在选取节点时。</p><h3 id="4-3：LoadBalancedConnectionProxy-pickNewConnection方法"><a href="#4-3：LoadBalancedConnectionProxy-pickNewConnection方法" class="headerlink" title="4.3：LoadBalancedConnectionProxy.pickNewConnection方法"></a>4.3：LoadBalancedConnectionProxy.pickNewConnection方法</h3><p>这个方法是非常核心的功能，每次变换节点时都会触发的一个方法，下面来看下其内部逻辑：</p><figure class="highlight java"><figcaption><span>代码块5</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pick节点核心方法，利用balancer对象刷新currentConnection的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">pickNewConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isClosed &amp;&amp; <span class="built_in">this</span>.closedExplicitly) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    List&lt;String&gt; hostPortList = Collections.unmodifiableList(<span class="built_in">this</span>.hostsList.stream().map(hi -&gt; hi.getHostPortPair()).collect(Collectors.toList()));</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.currentConnection == <span class="literal">null</span>) &#123; <span class="comment">// startup</span></span><br><span class="line">        <span class="comment">//如果currentConnection为空，则开始利用balancer选取节点</span></span><br><span class="line">        <span class="built_in">this</span>.currentConnection = <span class="built_in">this</span>.balancer.pickConnection(<span class="built_in">this</span>, hostPortList, Collections.unmodifiableMap(<span class="built_in">this</span>.liveConnections),</span><br><span class="line">                <span class="built_in">this</span>.responseTimes.clone(), <span class="built_in">this</span>.retriesAllDown);</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//终止</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.currentConnection.isClosed()) &#123;</span><br><span class="line">        invalidateCurrentConnection(); <span class="comment">//若发现当前连接已经被关闭了，则抛弃这个连接</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> <span class="variable">pingTimeout</span> <span class="operator">=</span> <span class="built_in">this</span>.currentConnection.getPropertySet().getIntegerProperty(PropertyKey.loadBalancePingTimeout).getValue();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">pingBeforeReturn</span> <span class="operator">=</span> <span class="built_in">this</span>.currentConnection.getPropertySet().getBooleanProperty(PropertyKey.loadBalanceValidateConnectionOnSwapServer).getValue();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//重试逻辑，若pick不成功，则在有限的次数内重试（这个次数就是hostsList的size）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">hostsTried</span> <span class="operator">=</span> <span class="number">0</span>, hostsToTry = <span class="built_in">this</span>.hostsList.size(); hostsTried &lt; hostsToTry; hostsTried++) &#123;</span><br><span class="line">        <span class="type">ConnectionImpl</span> <span class="variable">newConn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//pick节点</span></span><br><span class="line">            newConn = (ConnectionImpl) <span class="built_in">this</span>.balancer.pickConnection(<span class="built_in">this</span>, hostPortList, Collections.unmodifiableMap(<span class="built_in">this</span>.liveConnections),</span><br><span class="line">                    <span class="built_in">this</span>.responseTimes.clone(), <span class="built_in">this</span>.retriesAllDown);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.currentConnection != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pingBeforeReturn) &#123; <span class="comment">//ping检查，检查失败会抛SQLException，下方异常处理里会把它抛弃掉</span></span><br><span class="line">                    newConn.pingInternal(<span class="literal">true</span>, pingTimeout);</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="comment">//同步旧currentConnection节点的属性给这个新pick出来的节点，比如read-only、auto-commit什么的</span></span><br><span class="line">                syncSessionState(<span class="built_in">this</span>.currentConnection, newConn);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//刷新currentConnection的值为新pick出来的这个连接</span></span><br><span class="line">            <span class="built_in">this</span>.currentConnection = newConn;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//终止</span></span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (shouldExceptionTriggerConnectionSwitch(e) &amp;&amp; newConn != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// connection error, close up shop on current connection</span></span><br><span class="line">                invalidateConnection(newConn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// no hosts available to swap connection to, close up.</span></span><br><span class="line">    <span class="built_in">this</span>.isClosed = <span class="literal">true</span>; <span class="comment">//如果将hostsList集合pick了一遍都没有找到可用的连接，则认为pick失败，标记isClosed为true</span></span><br><span class="line">    <span class="built_in">this</span>.closedReason = <span class="string">&quot;Connection closed after inability to pick valid new connection during load-balance.&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4：MultiHostConnectionProxy-invoke方法"><a href="#4-4：MultiHostConnectionProxy-invoke方法" class="headerlink" title="4.4：MultiHostConnectionProxy.invoke方法"></a>4.4：MultiHostConnectionProxy.invoke方法</h3><p>这是<code>MultiHostConnectionProxy</code>对<code>InvocationHandler</code>接口的实现，通过<code>图2</code>可以知道，它的子类<code>LoadBalancedConnectionProxy</code>是返回给用户的<code>LoadBalancedConnection</code>的代理类，意味着用户利用Connection做的每一步操作，都会命中这个<code>invoke</code>方法的调用，下面来看下这个方法的实现：</p><figure class="highlight java"><figcaption><span>代码块6</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getName();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//若被调用的方法是getMultiHostSafeProxy，则直接返回代理对象本身（也即是用户正在使用的那个Connection对象）</span></span><br><span class="line">    <span class="keyword">if</span> (METHOD_GET_MULTI_HOST_SAFE_PROXY.equals(methodName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.thisAsConnection;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//被调用的方法是equals所执行的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (METHOD_EQUALS.equals(methodName)) &#123;</span><br><span class="line">        <span class="comment">// Let args[0] &quot;unwrap&quot; to its InvocationHandler if it is a proxy.</span></span><br><span class="line">        <span class="keyword">return</span> args[<span class="number">0</span>].equals(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//被调用的方法是hashCode所执行的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (METHOD_HASH_CODE.equals(methodName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//若被调用的方法是close，则关闭并清理掉所有的连接（liveConnections.clear）</span></span><br><span class="line">    <span class="keyword">if</span> (METHOD_CLOSE.equals(methodName)) &#123;</span><br><span class="line">        doClose();</span><br><span class="line">        <span class="built_in">this</span>.isClosed = <span class="literal">true</span>; <span class="comment">//标记isClosed为true</span></span><br><span class="line">        <span class="built_in">this</span>.closedReason = <span class="string">&quot;Connection explicitly closed.&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.closedExplicitly = <span class="literal">true</span>; <span class="comment">//标记closedExplicitly为true，意思是说这是由用户&quot;显式关闭&quot;的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//被调用的方法是abortInternal所执行的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (METHOD_ABORT_INTERNAL.equals(methodName)) &#123;</span><br><span class="line">        doAbortInternal();</span><br><span class="line">        <span class="built_in">this</span>.currentConnection.abortInternal();</span><br><span class="line">        <span class="built_in">this</span>.isClosed = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">this</span>.closedReason = <span class="string">&quot;Connection explicitly closed.&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//被调用的方法是abort所执行的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (METHOD_ABORT.equals(methodName) &amp;&amp; args.length == <span class="number">1</span>) &#123;</span><br><span class="line">        doAbort((Executor) args[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">this</span>.isClosed = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">this</span>.closedReason = <span class="string">&quot;Connection explicitly closed.&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//被调用的方法是isClosed所执行的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (METHOD_IS_CLOSED.equals(methodName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.isClosed;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//若调用的方法不是上面的任意一种，则直接触发其子类的invokeMore方法（下面分析）</span></span><br><span class="line">        <span class="keyword">return</span> invokeMore(proxy, method, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.getCause() != <span class="literal">null</span> ? e.getCause() : e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// Check if the captured exception must be wrapped by an unchecked exception.</span></span><br><span class="line">        Class&lt;?&gt;[] declaredException = method.getExceptionTypes();</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; declEx : declaredException) &#123;</span><br><span class="line">            <span class="keyword">if</span> (declEx.isAssignableFrom(e.getClass())) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5：LoadBalancedConnectionProxy-invokeMore方法"><a href="#4-5：LoadBalancedConnectionProxy-invokeMore方法" class="headerlink" title="4.5：LoadBalancedConnectionProxy.invokeMore方法"></a>4.5：LoadBalancedConnectionProxy.invokeMore方法</h3><p>紧接着上面的代码来看，了解下<code>invokMore</code>方法（根据<code>图2</code>可知，此方法为抽象方法，由子类实现，所以它的<code>实现逻辑</code>在<code>LoadBalancedConnectionProxy</code>里）</p><figure class="highlight java"><figcaption><span>代码块7</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title function_">invokeMore</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getName();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//重连机制判断，如果当前连接状态已被关闭，这里的关闭是指currentConnection的isClosed为true，而使isClosed为true的地方为：</span></span><br><span class="line">    <span class="comment">//① 用户手动调用Connection.close，这种被称为&quot;显式关闭&quot;，这种关闭方式连同closedExplicitly也会被置为true</span></span><br><span class="line">    <span class="comment">//② abort连接、ping检查失败、pickNewConnection时pick不出可用节点，都会使isClosed为true，但closedExplicitly依然为false</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isClosed &amp;&amp; !allowedOnClosedConnection(method) &amp;&amp; method.getExceptionTypes().length &gt; <span class="number">0</span>) &#123; <span class="comment">// TODO remove method.getExceptionTypes().length ?</span></span><br><span class="line">        <span class="comment">//结合上方说的②，如果你设置了autoReconnect机制（自动重连），那么就可以在任意&quot;非显式&quot;close的情况下，刷新currentConnection的值，使其可用</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.autoReconnect &amp;&amp; !<span class="built_in">this</span>.closedExplicitly) &#123;</span><br><span class="line">            <span class="built_in">this</span>.currentConnection = <span class="literal">null</span>;</span><br><span class="line">            pickNewConnection(); <span class="comment">//在自动重连开启的情况下，当你的连接被非正常关闭后，会尝试重新pick节点，确保其可用</span></span><br><span class="line">            <span class="built_in">this</span>.isClosed = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.closedReason = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果没有开启重连模式，那么在isClose为true时，就直接抛出错误</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">reason</span> <span class="operator">=</span> <span class="string">&quot;No operations allowed after connection closed.&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.closedReason != <span class="literal">null</span>) &#123;</span><br><span class="line">                reason += <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.closedReason;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; excls : method.getExceptionTypes()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (SQLException.class.isAssignableFrom(excls)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> SQLError.createSQLException(reason, MysqlErrorNumbers.SQL_STATE_CONNECTION_NOT_OPEN,</span><br><span class="line">                            <span class="literal">null</span> <span class="comment">/* no access to an interceptor here... */</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> ExceptionFactory.createException(CJCommunicationsException.class, reason);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.inTransaction) &#123;</span><br><span class="line">        <span class="built_in">this</span>.inTransaction = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">this</span>.transactionStartTime = System.nanoTime();</span><br><span class="line">        <span class="built_in">this</span>.transactionCount++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//触发实际的方法逻辑</span></span><br><span class="line">        result = method.invoke(<span class="built_in">this</span>.thisAsConnection, args);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (result <span class="keyword">instanceof</span> com.mysql.cj.jdbc.JdbcStatement) &#123;</span><br><span class="line">                ((com.mysql.cj.jdbc.JdbcStatement) result).setPingTarget(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里是给方法返回的对象加一层代理（跟本次重点无关，不再详述）</span></span><br><span class="line">            result = proxyIfReturnTypeIsJdbcInterface(method.getReturnType(), result);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        dealWithInvocationException(e);</span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//重点是，当发现触发的方法是commit或rollback时，会刷新一下currentConnection的值，重新pick出一个</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;commit&quot;</span>.equals(methodName) || <span class="string">&quot;rollback&quot;</span>.equals(methodName)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.inTransaction = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// Update stats</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> <span class="built_in">this</span>.connectionsToHostsMap.get(<span class="built_in">this</span>.currentConnection);</span><br><span class="line">            <span class="comment">// avoid NPE if the connection has already been removed from connectionsToHostsMap in invalidateCurrenctConnection()</span></span><br><span class="line">            <span class="keyword">if</span> (host != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>.responseTimes) &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">hostIndex</span> <span class="operator">=</span> (<span class="built_in">this</span>.hostsToListIndexMap.get(host));</span><br><span class="line"> </span><br><span class="line">                    <span class="keyword">if</span> (hostIndex != <span class="literal">null</span> &amp;&amp; hostIndex &lt; <span class="built_in">this</span>.responseTimes.length) &#123;</span><br><span class="line">                        <span class="comment">//更新对应节点执行事务所花费的时间</span></span><br><span class="line">                        <span class="built_in">this</span>.responseTimes[hostIndex] = System.nanoTime() - <span class="built_in">this</span>.transactionStartTime;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//刷新currentConnection的值</span></span><br><span class="line">            pickNewConnection();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这块代码可以知道，一个LoadBalance模式下的连接被创建出来后，除非是<code>commit</code>或<code>rollback</code>事务，否则该Connection对象里的<code>currentConnection</code>永远都<code>不会变</code>，当然，通过上述代码看，还有一种情况是会变的，那就是当前连接坏掉，然后<code>ping</code>检查失败<code>isClose</code>被标记为<code>true</code>，你的配置里恰好又<code>开启</code>了<code>autoReconnect</code>，这时才会<code>重新pick</code>新的节点。</p><h2 id="五、猜想"><a href="#五、猜想" class="headerlink" title="五、猜想"></a>五、猜想</h2><p>通过对其代码实现的分析，可以得出如下猜想：</p><ol><li><code>不配autoReconnect</code>的情况下，只有在利用该连接对象<code>提交</code>、<code>回滚</code>事务时才会<code>pick</code>新的节点。</li><li><code>配置autoReconnect</code>的情况下，在节点<code>坏掉</code>后，会<code>pick</code>一次节点，事务<code>提交</code>、<code>回滚</code>一样会<code>pick</code>节点。</li><li>综上，如果我要实现一个<code>select查询</code>也需要<code>pick</code>节点实现负载均衡的情况下，不可以用<code>单例Connection</code>，因为普通select<code>并不会</code>触发<code>pick</code>操作。</li><li>综合3，想要实现全部意义的LB，必须要使用<code>多实例模式</code>，这样虽然实现了我想要的LB效果，但代价是巨大的，因为每次都会<code>建连</code>。</li><li>利用<code>连接池</code>可以一定程度上解决这种问题，连接池可以预先建连一堆Connection对象，这些对象如果在创建时启用jdbc LoadBalance模式，那么意味着每个连接都是<code>随机节点</code>。</li></ol><h2 id="六、验证"><a href="#六、验证" class="headerlink" title="六、验证"></a>六、验证</h2><p>为了验证<code>第五节</code>的结论，我们简单做个试验验证下。</p><h3 id="6-1：单例模式下的Query操作"><a href="#6-1：单例模式下的Query操作" class="headerlink" title="6.1：单例模式下的Query操作"></a>6.1：单例模式下的Query操作</h3><figure class="highlight java"><figcaption><span>代码块8</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql:loadbalance://172.22.119.38:4000,172.22.119.8:4000,172.22.119.30:4000/tidb_test&quot;</span>;</span><br><span class="line">        <span class="type">LoadBalancedConnection</span> <span class="variable">connection</span> <span class="operator">=</span> (LoadBalancedConnection) DriverManager.getConnection(url, <span class="string">&quot;tidb_test&quot;</span>, <span class="string">&quot;lPoK3QMSWY1BhSa3WCT1IWOXYkMc3Aqd&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123; <span class="comment">//利用同一个connection对象执行100次查询操作</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                test.triggerQuery(connection);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//为了保证是单例模式，这里不再close</span></span><br><span class="line">                <span class="comment">//connection.close();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">triggerQuery</span><span class="params">(LoadBalancedConnection connection)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//这里打印下当前参与执行sql的连接host</span></span><br><span class="line">            System.out.println(<span class="string">&quot;current conn host: &quot;</span> + connection.getHost());</span><br><span class="line">            <span class="keyword">if</span> (statement.execute(<span class="string">&quot;select * from t_student where id = 1&quot;</span>)) &#123;</span><br><span class="line">                rs = statement.getResultSet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (rs != <span class="literal">null</span>) &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125;</span><br><span class="line">            statement.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码运行结果打印如下：</p><figure class="highlight shell"><figcaption><span>代码块9</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">current conn host: 172.22.119.30</span><br><span class="line">current conn host: 172.22.119.30</span><br><span class="line">current conn host: 172.22.119.30</span><br><span class="line">current conn host: 172.22.119.30</span><br><span class="line">current conn host: 172.22.119.30</span><br><span class="line">current conn host: 172.22.119.30</span><br><span class="line">current conn host: 172.22.119.30</span><br><span class="line">...省略，共100条...</span><br></pre></td></tr></table></figure><p>可以看到，如果一直用同一个Connection对象去createStatement，然后执行Query，那么节点始终是一开始pick好的那个，且<code>永远不会变</code>。</p><h3 id="6-2：多实例下的Query操作"><a href="#6-2：多实例下的Query操作" class="headerlink" title="6.2：多实例下的Query操作"></a>6.2：多实例下的Query操作</h3><p>这个其实根本没有测试的必要，多实例意味着每次Query前都会<code>新建一个连接</code>对象，新建一个意味着会<code>pick</code>一次，那肯定是<code>random</code>的，我们改下main方法的代码：</p><figure class="highlight java"><figcaption><span>代码块10</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql:loadbalance://172.22.119.38:4000,172.22.119.8:4000,172.22.119.30:4000/tidb_test&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//将创建connection连接放到循环体里面，使每次传给triggerQuery方法的都是不同的Connection对象</span></span><br><span class="line">        <span class="type">LoadBalancedConnection</span> <span class="variable">connection</span> <span class="operator">=</span> (LoadBalancedConnection) DriverManager.getConnection(url, <span class="string">&quot;tidb_test&quot;</span>, <span class="string">&quot;lPoK3QMSWY1BhSa3WCT1IWOXYkMc3Aqd&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test.triggerQuery(connection);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//别忘了close资源</span></span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次运行结果如下：</p><figure class="highlight shell"><figcaption><span>代码块11</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">current conn host: 172.22.119.8</span><br><span class="line">current conn host: 172.22.119.8</span><br><span class="line">current conn host: 172.22.119.8</span><br><span class="line">current conn host: 172.22.119.38</span><br><span class="line">current conn host: 172.22.119.30</span><br><span class="line">current conn host: 172.22.119.38</span><br><span class="line">current conn host: 172.22.119.8</span><br><span class="line">current conn host: 172.22.119.8</span><br><span class="line">current conn host: 172.22.119.38</span><br><span class="line">...省略，共100条...</span><br></pre></td></tr></table></figure><p>可以看到，已经触发了LB算法了（这是预料之中的）。</p><p>你可能会问，如果调用了<code>close</code>呢？会不会close不是真的close，而是<code>触发pick</code>呢？正常情况下肯定会这样实现的吧？其实并不会，close的逻辑是把里面<code>所有的liveConnections清空</code>，然后<code>close一遍</code>，所以下面的代码会报错：</p><figure class="highlight java"><figcaption><span>代码块12</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql:loadbalance://172.22.119.38:4000,172.22.119.8:4000,172.22.119.30:4000/tidb_test&quot;</span>;</span><br><span class="line">    <span class="comment">//仍然是单例的Connection对象</span></span><br><span class="line">    <span class="type">LoadBalancedConnection</span> <span class="variable">connection</span> <span class="operator">=</span> (LoadBalancedConnection) DriverManager.getConnection(url, <span class="string">&quot;tidb_test&quot;</span>, <span class="string">&quot;lPoK3QMSWY1BhSa3WCT1IWOXYkMc3Aqd&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test.triggerQuery(connection);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            connection.close(); <span class="comment">//这里close掉</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="http://myblog.sharemer.com/2020/06/02/20200602-1-5.png" alt="图4"></p><p>是的。。它直接报错了，也就是说，在select这种语句的执行下，要么你用<code>多实例</code>，每次都<code>建连</code>，实现你心目中的LB，要么你就用<code>单例</code>，然后<code>一个连接用到底</code>。。</p><p>但是它并非一无是处，比如，你可以结合<code>连接池</code>来用它，这样既可以保证<code>连接复用</code>，也可以保证池内每个连接对象的host在最大限度上不是同一个。</p><h3 id="6-3：单例模式下的事务操作"><a href="#6-3：单例模式下的事务操作" class="headerlink" title="6.3：单例模式下的事务操作"></a>6.3：单例模式下的事务操作</h3><p>按照源码上的理解，理论上即便是<code>单例</code>，<code>开启事务</code>并提交的时候也会<code>切换</code>一次host，现在将前面的测试代码改成下面这样：</p><figure class="highlight java"><figcaption><span>代码块13</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql:loadbalance://172.22.119.38:4000,172.22.119.8:4000,172.22.119.30:4000/tidb_test&quot;</span>;</span><br><span class="line">    <span class="comment">//仍然是单例的Connection对象</span></span><br><span class="line">    <span class="type">LoadBalancedConnection</span> <span class="variable">connection</span> <span class="operator">=</span> (LoadBalancedConnection) DriverManager.getConnection(url, <span class="string">&quot;tidb_test&quot;</span>, <span class="string">&quot;lPoK3QMSWY1BhSa3WCT1IWOXYkMc3Aqd&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test.triggerTransaction(connection);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//为了保证是单例模式，这里不再close</span></span><br><span class="line">            <span class="comment">//connection.close();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//开启事务的方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">triggerTransaction</span><span class="params">(LoadBalancedConnection connection)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    connection.setAutoCommit(<span class="literal">false</span>); <span class="comment">//关闭自动提交</span></span><br><span class="line">    <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//这里打印下当前参与执行sql的连接host</span></span><br><span class="line">        System.out.println(<span class="string">&quot;current conn host: &quot;</span> + connection.getHost());</span><br><span class="line">        <span class="keyword">if</span> (statement.execute(<span class="string">&quot;select * from t_student where id = 1&quot;</span>)) &#123;</span><br><span class="line">            rs = statement.getResultSet();</span><br><span class="line">        &#125;</span><br><span class="line">        connection.commit(); <span class="comment">//事务提交</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rs != <span class="literal">null</span>) &#123;</span><br><span class="line">            rs.close();</span><br><span class="line">        &#125;</span><br><span class="line">        statement.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight shell"><figcaption><span>代码块14</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">current conn host: 172.22.119.8</span><br><span class="line">current conn host: 172.22.119.30</span><br><span class="line">current conn host: 172.22.119.8</span><br><span class="line">current conn host: 172.22.119.30</span><br><span class="line">current conn host: 172.22.119.38</span><br><span class="line">current conn host: 172.22.119.30</span><br><span class="line">current conn host: 172.22.119.38</span><br><span class="line">current conn host: 172.22.119.30</span><br><span class="line">current conn host: 172.22.119.8</span><br><span class="line">current conn host: 172.22.119.30</span><br><span class="line">...省略，共100条...</span><br></pre></td></tr></table></figure><p>这是符合预期的，因为即便是单实例，每次处理事务的节点也发生了变换。</p><p>多实例就不再试了，没有必要。</p><h3 id="6-4：开启autoReconnect时，单例执行Query操作"><a href="#6-4：开启autoReconnect时，单例执行Query操作" class="headerlink" title="6.4：开启autoReconnect时，单例执行Query操作"></a>6.4：开启autoReconnect时，单例执行Query操作</h3><p>按照我们的结论，这个只有在节点坏掉时才会重新pick节点，以保证可用性，那么我们现在来开启它，然后依然用单例模式操作Query，代码改写如下：</p><figure class="highlight java"><figcaption><span>代码块15</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql:loadbalance://172.22.119.38:4000,172.22.119.8:4000,172.22.119.30:4000/tidb_test?autoReconnect=true&quot;</span>; <span class="comment">//带上autoReconnect参数，使其为true</span></span><br><span class="line">    <span class="comment">//仍然是单例的Connection对象</span></span><br><span class="line">    <span class="type">LoadBalancedConnection</span> <span class="variable">connection</span> <span class="operator">=</span> (LoadBalancedConnection) DriverManager.getConnection(url, <span class="string">&quot;tidb_test&quot;</span>, <span class="string">&quot;lPoK3QMSWY1BhSa3WCT1IWOXYkMc3Aqd&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test.triggerQuery(connection);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//为了保证是单例模式，这里不再close</span></span><br><span class="line">            <span class="comment">//connection.close();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果打印如下：</p><figure class="highlight shell"><figcaption><span>代码块16</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">current conn host: 172.22.119.8</span><br><span class="line">current conn host: 172.22.119.8</span><br><span class="line">current conn host: 172.22.119.8</span><br><span class="line">current conn host: 172.22.119.8</span><br><span class="line">current conn host: 172.22.119.8</span><br><span class="line">current conn host: 172.22.119.8</span><br><span class="line">current conn host: 172.22.119.8</span><br><span class="line">...省略，共100条...</span><br></pre></td></tr></table></figure><p>符合我们的预期，因为它的作用不是干这个的。</p><h2 id="七、结论"><a href="#七、结论" class="headerlink" title="七、结论"></a>七、结论</h2><p>JDBC驱动程序的LoadBalance模式，是针对<code>每一个</code>被新建出来的Connection对象的LB，它<code>并非</code>很多人第一眼看到它协议头时所理解的那种将jdbc连接里配置的所有节点视作一个整体，每次利用Connection对象做一些操作时都会pick出来一个节点使用，以达到某种意义上的负载均衡，<code>而是</code>每次新建Connection对象时，从那堆host里pick出来其中一个，创建对应的Connection对象，这跟我们第一眼看到它的感觉不太一样，但是实现上确实没什么太大的问题，因为单纯使用JDBC时本就不提倡Connection单例复用，若想要复用，需要结合各类连接池一起使用，通过对JDBC的LB模式的了解可以知道，结合某种连接池技术来支撑，就可以达到我们想象中的LB效果，因为池内每一个Connection对象在创建时，总会触发JDBC的LB策略。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;基于依赖程序的版本信息：&lt;img src=&quot;https://img.shields.io/badge/mysql--connector--java-v8.0.17-green&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、认识loadbalance模式&quot;&gt;&lt;a href=&quot;#一、认识loadbalance模式&quot; class=&quot;headerlink&quot; title=&quot;一、认识loadbalance模式&quot;&gt;&lt;/a&gt;一、认识loadbalance模式&lt;/h2&gt;&lt;p&gt;首先回忆下jdbc协议头都有哪些，下面总结下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://myblog.sharemer.com/2020/06/02/20200602-1-1.png&quot; alt=&quot;表1&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
    <category term="JDBC" scheme="http://example.com/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>JVM基础回顾记录（四）：类文件</title>
    <link href="http://example.com/2020/05/06/JVM%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE%E8%AE%B0%E5%BD%95%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%B1%BB%E6%96%87%E4%BB%B6/"/>
    <id>http://example.com/2020/05/06/JVM%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE%E8%AE%B0%E5%BD%95%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%B1%BB%E6%96%87%E4%BB%B6/</id>
    <published>2020-05-06T14:56:00.000Z</published>
    <updated>2023-12-04T10:54:23.151Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、JAVA的平台无关性"><a href="#一、JAVA的平台无关性" class="headerlink" title="一、JAVA的平台无关性"></a>一、JAVA的平台无关性</h2><p>我们最开始学习java的时候了解到java代码文件必须经过<code>javac</code>的编译，生成字节码文件才可以被JVM识别并运行，而JVM则拥有多种操作系统的版本：</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-1-fixed.png?imageView2/0/w/700" alt="图1"></p><p>正是因为这些不同操作系统下的JVM版本，使得我们被编译后的字节码文件可以被不同操作系统上的JVM识别并运行，继而实现跨平台。</p><span id="more"></span><h2 id="二、字节码文件组成"><a href="#二、字节码文件组成" class="headerlink" title="二、字节码文件组成"></a>二、字节码文件组成</h2><p>字节码文件是经过编译器编译后的class文件，所以也可以称为<code>Class类文件</code>，这个文件内的内容你是看不懂的，它是以某种顺序堆叠的<code>二进制流</code>组成的文件，以<code>字节（byte）</code>为基本单位，我们学习java基础时知道，单字节占有8个bit位，虽然你很难看懂，但对于JVM来说却可以很容易的解析这类文件，这里先不谈它如何解析，我们本次只说明这个文件里都放了些什么东西，接下来会结合实例来详细说明。</p><p>上面刚说过，文件内部的基本单位是字节（8bit），利用这些字节数据所处的先后顺序，来决定Class文件里不同的数据项，JVM在做字节码加载分析的时候也是按照这个顺序来进行的，这就像是一种序列化的方式，而JVM加载解析它的时候，相当于在做反序列化，这个在本节不做探讨，留到类加载章节会详细说明。</p><p>字节码文件里存储的数据类型分为两大类，一种是基本的<code>无符号数字</code>类型，另外一种则是类似C语言中<code>结构体</code>的一种东西，我们管它叫<code>表</code>，表可能包含无符号数字，也可能包含另外一个表，也可能由无符号数字和其他表共同组成（其实也很像java里的类对吧？可能只包含基本类型的属性，也可能包含另外一个类的对象属性，虽然它跟类完全不是一回事，但为了便于理解，可以这样想）</p><p>由于字节码文件的“反序列化”过程非常的单纯，就是从前往后读，那么Class文件中的无符号数和表的堆叠顺序就显得非常重要，这其实是一种java虚拟机约定好的协议，比如Class文件读进来的二进制流，前4个字节一定是某个具体的字段，紧接着往后2个字节一定是另外一个字段，就这样，这个二进制字节流被协议切分成了具体的组，每一个组都代表着不同含义的字段。</p><h2 id="三、前三个字节组：魔数、次版本号、主版本号"><a href="#三、前三个字节组：魔数、次版本号、主版本号" class="headerlink" title="三、前三个字节组：魔数、次版本号、主版本号"></a>三、前三个字节组：魔数、次版本号、主版本号</h2><p>通过<code>第二节</code>的了解，我们知道了Class文件就是字节与字节的顺序堆叠排列，然后按照字节码约定协议进行以字节为单位分组，每一组的数据代表着不同的含义，接下来让我们看下字节码文件的头部三个组都分别代表什么吧：</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-2.png?imageView2/0/w/1024" alt="图2"></p><p>上图展示的就是Class文件开头几个字节被约定分组的情况，其实后面更复杂的表也是按照类似的方式做的。</p><p>无符号数按照不同数量的字节分组，形成了不同的<code>数据类型</code>，需要占用4个字节才能存下的字段的类型被称为<code>u4</code>，而只需要占用2个字节的字段类型被称为<code>u2</code>，<code>图2</code>中“魔数”就可以被说成是一个u4类型的数字，而次版本号和主版本号则为<code>u2</code>。</p><p><strong>魔数（magic）：</strong>确定当前文件是否是一个可以被jvm加载的Class文件（像mp3、pdf等文件，开头一样也会有类似的魔数）</p><p><strong>主版本号（major_version）&amp;次版本号（minor_version）：</strong>用来记录当前Class文件的版本号，每个版本的jdk编译过的Class文件，会保有其版本号信息，学习java基础的时候都了解过，java是<code>自上向下兼容</code>的，比如jdk1.8编译出来的Class文件不可以被1.7版本的虚拟机加载运行，但jdk1.7编译出来的Class文件却可以被1.8版本的虚拟机加载运行，至于能不能被加载的第一道坎，就是按照这俩版本号进行判断的。</p><h2 id="四、常量池"><a href="#四、常量池" class="headerlink" title="四、常量池"></a>四、常量池</h2><p><code>图2</code>里我们至少已经知道了<code>魔数</code>、<code>次版本号</code>、<code>主版本号</code>这三个字段，往后的则被省略了。往后是什么呢？它是非常复杂且庞大的一个分组集合，被称为常量池（注意，这个常量池是指Class文件内的常量池，他们会被Class文件内一些索引项给索引到，准确的说并不是运行期的那个JVM方法区内的<code>运行时常量池</code>，但随着JVM的类加载，类里的这个常量池会被加载进运行时常量池，顺便说下，到了那个时候，很多<code>符号引用</code>也会转变为<code>直接引用</code>）它们位于主版本号后面，第一项是一个u2类型的数字，表示有几个常量表如图：</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-3-fixed.png?imageView2/0/w/1024" alt="图3"></p><h3 id="4-1：池里常量的分类"><a href="#4-1：池里常量的分类" class="headerlink" title="4.1：池里常量的分类"></a>4.1：池里常量的分类</h3><p>常量池里的常量按照类型被分为了两大类：字面量和符号引用，而符号引用又往下细分了几个分类，如图：</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-3-1.png?imageView2/0/w/600" alt="图4"></p><h4 id="4-1-1：字面量"><a href="#4-1-1：字面量" class="headerlink" title="4.1.1：字面量"></a>4.1.1：字面量</h4><p>很简单的概念，类似于常量，下面的分节将会详细介绍，主要是类似语言层面的基本类型，比如<code>int</code>、<code>float</code>、<code>double</code>这些，都有对应的字面量常量表：<code>CONSTANT_Integer_info</code>、<code>CONSTANT_Float_info</code>、<code>CONSTANT_Double_info</code></p><h4 id="4-1-2：符号引用"><a href="#4-1-2：符号引用" class="headerlink" title="4.1.2：符号引用"></a>4.1.2：符号引用</h4><p>符号引用都是以字符串的方式存储在常量池里的，它们通常用来描述类的全限定名、方法和字段的名称以及描述符，因此被分了三类.</p><h5 id="类和接口的全限定名"><a href="#类和接口的全限定名" class="headerlink" title="类和接口的全限定名"></a>类和接口的全限定名</h5><p>第一类叫全限定名，例如，一个类叫：<code>com.bilibili.test.Test</code>，则它的全限定名为：<code>com/bilibili/test/Test</code></p><h5 id="字段、方法的简单名称和描述符"><a href="#字段、方法的简单名称和描述符" class="headerlink" title="字段、方法的简单名称和描述符"></a>字段、方法的简单名称和描述符</h5><p>相对来说，字段和方法的描述符更为复杂，我们得通过实际的例子来说明问题。</p><p>我们知道，一个类里面有字段以及方法，字段有它自己声明的类型以及名称，而方法则更加复杂，它存在入参、返回、名称，因此要想用描述符这样的字符串来描述一个字段或者一个方法，往往需要一定的格式，让我们来看看其格式吧。</p><p>先说字段，假如我的类里有个字段是int型，名称为num，名称没什么好说的就是num，但它的类型描述符却是：<code>I</code></p><p>为什么int型的数据的类型描述符是<code>I</code>？那double呢？下面我们就列出所有类型对应的描述符的映射关系表，后面更复杂的方法描述符也可以用到这个表：</p><table><thead><tr><th align="left">类型</th><th align="left">描述符</th></tr></thead><tbody><tr><td align="left">byte</td><td align="left">B</td></tr><tr><td align="left">char</td><td align="left">C</td></tr><tr><td align="left">double</td><td align="left">D</td></tr><tr><td align="left">float</td><td align="left">F</td></tr><tr><td align="left">int</td><td align="left">I</td></tr><tr><td align="left">long</td><td align="left">J</td></tr><tr><td align="left">short</td><td align="left">S</td></tr><tr><td align="left">boolean</td><td align="left">Z</td></tr><tr><td align="left">reference（引用类型）</td><td align="left">L，格式为<code>L类型全限定名;</code>，例如Object类型的引用变量可表示为：<code>Ljava/lang/Object;</code></td></tr><tr><td align="left">array（数组）</td><td align="left">[，格式为：<code>[类型描述符</code>，比如<code>int[]</code>可以表示为<code>[I</code>，再比如<code>Object[]</code>可以表示为<code>[Ljava/lang/Object;</code>，高维数组，只需要多加一个<code>[</code>即可，比如<code>int[][]</code>可以表示为<code>[[I</code></td></tr><tr><td align="left">void（方法描述符独有，用于形容方法的无参数返回类型）</td><td align="left">V</td></tr></tbody></table><center>表1</center><p>ok，了解完各种类型的描述符规则，再来一遍开始那个字段描述符为<code>I</code>就可以很容易理解了，下面来继续了解下方法的描述符，这个就更为复杂，其格式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(参数1类型描述符 参数2类型描述符...)返回值类型描述符</span><br></pre></td></tr></table></figure><p>下面通过几个例子来说明方法描述符，希望可以帮助你理解：</p><table><thead><tr><th align="left">方法定义</th><th align="left">描述符</th></tr></thead><tbody><tr><td align="left">int getId()</td><td align="left">()I</td></tr><tr><td align="left">double getPrice(Object[] o, double price)</td><td align="left">([Ljava&#x2F;lang&#x2F;Object;D)D</td></tr><tr><td align="left">void setId()</td><td align="left">()V</td></tr><tr><td align="left">void setId(int id)</td><td align="left">(I)V</td></tr></tbody></table><center>表2</center><p>那么字段或方法的名称及描述符存在哪个地方呢？接下来要介绍的一个叫做<code>CONSTANT_NameAndType_info</code>的常量表就是专门存放这俩数据的，它的内部结构请参考&#96;&#96;里对它的介绍。</p><p>常量池里的每一项都是个表，下面，我们来深层次探讨下常量池里的每一个表的结构~</p><h3 id="4-2：CONSTANT-Utf8-info（UTF-8编码的字符串）"><a href="#4-2：CONSTANT-Utf8-info（UTF-8编码的字符串）" class="headerlink" title="4.2：CONSTANT_Utf8_info（UTF-8编码的字符串）"></a>4.2：CONSTANT_Utf8_info（UTF-8编码的字符串）</h3><p>这个表的详细结构如下：</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-4.png?imageView2/0/w/600" alt="图5"></p><p>即便是表，也是按照类似的方式堆叠的，后续几种类型也是类似。</p><p>基本上常量池里的表第一个字节都是<code>tag</code>，tag在<code>图4</code>中已经解释过了，它用来区分当前表属于什么类型的表，比如本节里tag&#x3D;1，规范里tag为1的表就是<code>CONSTANT_Utf8_info</code>，当虚拟机知道了表为CONSTANT_Utf8_info，那么很自然的后面两个字节肯定是<code>length</code>，至于其内容，肯定就是length后面的字节了，然后截取length长度的字节，就是这个CONSTANT_Utf8_info所存放的实际内容。</p><h3 id="4-3：CONSTANT-Integer-info（整型字面量）"><a href="#4-3：CONSTANT-Integer-info（整型字面量）" class="headerlink" title="4.3：CONSTANT_Integer_info（整型字面量）"></a>4.3：CONSTANT_Integer_info（整型字面量）</h3><p>直接上图：</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-5.png?imageView2/0/w/500" alt="图6"></p><p>我们都知道int型数据占4字节，32位，现在通过上图字节码的分配可以证实，下面的字面量也大体相同。</p><h3 id="4-4：CONSTANT-Float-info（浮点型字面量）"><a href="#4-4：CONSTANT-Float-info（浮点型字面量）" class="headerlink" title="4.4：CONSTANT_Float_info（浮点型字面量）"></a>4.4：CONSTANT_Float_info（浮点型字面量）</h3><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-6.png?imageView2/0/w/500" alt="图7"></p><h3 id="4-5：CONSTANT-Long-info（长整型字面量）"><a href="#4-5：CONSTANT-Long-info（长整型字面量）" class="headerlink" title="4.5：CONSTANT_Long_info（长整型字面量）"></a>4.5：CONSTANT_Long_info（长整型字面量）</h3><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-7.png?imageView2/0/w/800" alt="图8"></p><h3 id="4-6：CONSTANT-Double-info（双精浮点型字面量）"><a href="#4-6：CONSTANT-Double-info（双精浮点型字面量）" class="headerlink" title="4.6：CONSTANT_Double_info（双精浮点型字面量）"></a>4.6：CONSTANT_Double_info（双精浮点型字面量）</h3><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-8.png?imageView2/0/w/800" alt="图9"></p><blockquote><p>到这里，基本类型就介绍完了，通过对<code>2.3.2 ~ 2.3.5</code>的了解，可以发现，基本类型是很简单的类型，而且其实际内容符合java里基本类型所占位数。</p></blockquote><h3 id="4-7：CONSTANT-Class-info（类、接口的符号引用）"><a href="#4-7：CONSTANT-Class-info（类、接口的符号引用）" class="headerlink" title="4.7：CONSTANT_Class_info（类、接口的符号引用）"></a>4.7：CONSTANT_Class_info（类、接口的符号引用）</h3><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-9.png?imageView2/0/w/400" alt="图10"></p><p>这里要详细介绍下index这个属性，因为在后面的表中，这个字段出现的频率会非常高。</p><p>这个字段代表了一个内容的索引，它索的谁的引呢？答案还是常量池，举个例子吧，Class_info是一个用来描述类或者接口<code>全限定名</code>的表，既然是全限定名，那肯定是个字符串，那么index指向的肯定是常量池里一张<code>CONSTANT_Utf8_info</code>的表，现在让我们假设一个常量池，里面已经排列好了各种表数据，按照常量池索引值从1开始，因此按照规则，绘制出下图：</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-10.png?imageView2/0/w/1024" alt="图11"></p><p>当Class_info的index属性就是用来指向常量池中某一个表的，例如上图里index&#x3D;2，则意味着常量池里索引下标为2的表的内容，就是Class_info的内容，开头说过，就是类或接口的全限定名。</p><h3 id="4-8：CONSTANT-String-info（字符串类型字面量）"><a href="#4-8：CONSTANT-String-info（字符串类型字面量）" class="headerlink" title="4.8：CONSTANT_String_info（字符串类型字面量）"></a>4.8：CONSTANT_String_info（字符串类型字面量）</h3><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-11.png?imageView2/0/w/320" alt="图12"></p><h3 id="4-9：CONSTANT-NameAndType-info（字段、方法的部分符号引用）"><a href="#4-9：CONSTANT-NameAndType-info（字段、方法的部分符号引用）" class="headerlink" title="4.9：CONSTANT_NameAndType_info（字段、方法的部分符号引用）"></a>4.9：CONSTANT_NameAndType_info（字段、方法的部分符号引用）</h3><p>之前介绍了常量池里存放的字段、方法都是存在名称以及描述符的，本节介绍的这个结构就是用来存放这两项内容的（对字段或方法的名称及描述符不熟悉的话，建议加强理解下<code>图4</code>、<code>表1</code>、<code>表2</code>里的内容）</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-15.png?imageView2/0/w/550" alt="图13"></p><p>该结构存储了某个字段或方法的<code>名称索引</code>和<code>描述符索引</code>，那肯定有具体的某个字段或方法的表里会索引向它，接下来要介绍的<code>CONSTANT_Fieldref_info</code>和<code>CONSTANT_Methodref_info</code>，均有指向它的索引字段。</p><h3 id="4-10：CONSTANT-Fieldref-info（类中引用字段的符号引用）"><a href="#4-10：CONSTANT-Fieldref-info（类中引用字段的符号引用）" class="headerlink" title="4.10：CONSTANT_Fieldref_info（类中引用字段的符号引用）"></a>4.10：CONSTANT_Fieldref_info（类中引用字段的符号引用）</h3><p>这个常量专门用来描述<code>类内被引用到的属性</code>，包含你<code>自定义</code>的出现在该类的属性，也包含该类里方法调用时使用的<code>别的类的属性</code>。</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-12-fixed.png?imageView2/0/w/500" alt="图14"></p><p>字段的符号引用表，除了要描述声明自己的类或接口，还需要索引到具体的<code>CONSTANT_NameAndType_info</code>，这个表里上面介绍过，内含一个<code>名称</code>和具体的<code>描述符</code>，下方的方法符号引用也是同样的结构，即一个字段或方法的符号引用等于：<code>声明该字段或方法的类或接口的全限定名</code> + <code>该字段或方法的名称</code> + <code>该字段或方法的描述符</code></p><h3 id="4-11：CONSTANT-Methodref-info（类中引用方法的符号引用）"><a href="#4-11：CONSTANT-Methodref-info（类中引用方法的符号引用）" class="headerlink" title="4.11：CONSTANT_Methodref_info（类中引用方法的符号引用）"></a>4.11：CONSTANT_Methodref_info（类中引用方法的符号引用）</h3><p>这个常量专门用来描述<code>类内被引用到的方法</code>，比如你在<code>A类</code>里定义了一个叫<code>test()</code>的方法，这个test方法<code>并不会</code>在常量池存在一个<code>CONSTANT_Methodref_info</code>，如果你再定义一个方法<code>test2()</code>，让它调用test方法，这时test方法相当于被引用，这时就拥有了对应的Methodref_info.</p><p>再比如，你方法里经常会调用一些依赖包的类方法，比如最常用的<code>System.out.println</code>，这个过程相当于你使用了<code>out对象</code>的<code>println方法</code>，此时当前类的字节码常量池便会有一个<code>println</code>的Methodref_info出现，同时也会有一个叫<code>out</code>的Fieldref_info出现。（这些均会在<code>实战篇</code>讲解）</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-13-fixed.png?imageView2/0/w/500" alt="图15"></p><blockquote><p>纠错，图里第一个info块里的内容应该是“Methodref_info的tag值为10”</p></blockquote><h3 id="4-12：CONSTANT-InterfaceMethodref-info（接口中方法的符号引用）"><a href="#4-12：CONSTANT-InterfaceMethodref-info（接口中方法的符号引用）" class="headerlink" title="4.12：CONSTANT_InterfaceMethodref_info（接口中方法的符号引用）"></a>4.12：CONSTANT_InterfaceMethodref_info（接口中方法的符号引用）</h3><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-14.png?imageView2/0/w/500" alt="图16"></p><p>截止到目前，常见的11种常量已经介绍完了，下面再介绍3种<code>JDK1.7</code>引入的新常量。</p><h3 id="4-13：CONSTANT-MethodHandle-info（表示方法句柄）"><a href="#4-13：CONSTANT-MethodHandle-info（表示方法句柄）" class="headerlink" title="4.13：CONSTANT_MethodHandle_info（表示方法句柄）"></a>4.13：CONSTANT_MethodHandle_info（表示方法句柄）</h3><p>这个常量是<code>1.7</code>新增的特性，即方法句柄，可以和下方<code>MethodType</code>结合使用，用法这里暂时不说，你可以简单理解，它是类似<code>反射</code>的功能，可以指定调用哪个对象的哪个方法。但不同于反射，它可以在编译期就指定好方法调用，而不是运行期，这相比反射要安全的多。</p><h3 id="4-14：CONSTANT-MethodType-info（标识方法类型）"><a href="#4-14：CONSTANT-MethodType-info（标识方法类型）" class="headerlink" title="4.14：CONSTANT_MethodType_info（标识方法类型）"></a>4.14：CONSTANT_MethodType_info（标识方法类型）</h3><p>待补全…</p><h3 id="4-15：CONSTANT-InvokeDynamic-info（动态方法调用点）"><a href="#4-15：CONSTANT-InvokeDynamic-info（动态方法调用点）" class="headerlink" title="4.15：CONSTANT_InvokeDynamic_info（动态方法调用点）"></a>4.15：CONSTANT_InvokeDynamic_info（动态方法调用点）</h3><p>待补全…</p><h2 id="五、访问标志"><a href="#五、访问标志" class="headerlink" title="五、访问标志"></a>五、访问标志</h2><p>紧挨着常量池后面的两个字节，代表<code>访问标志</code>（<code>access_flags</code>），因为其具备2个字节，所以它有16个bit位可以利用，每个位置的0或1代表不同的含义，当前只定义了8个，如下：</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-16.png?imageView2/0/w/1100" alt="图17"></p><h2 id="六、继承关系"><a href="#六、继承关系" class="headerlink" title="六、继承关系"></a>六、继承关系</h2><p>接着access_flag后面，有描述本类继承关系的几个变量，分别如下：</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-17.png?imageView2/0/w/1024" alt="图18"></p><p>学过java的人都知道，java类允许<code>单继承</code>和<code>多实现</code>，因此图中<code>super_class</code>只有一个，<code>interface</code>却对应了一个集合，当然，它们都只是u2类型的索引而已，指向常量池里的<code>CONSTANT_Class_info</code>（参考<code>4.7</code>）</p><h2 id="七、字段表集合"><a href="#七、字段表集合" class="headerlink" title="七、字段表集合"></a>七、字段表集合</h2><p>我们离开了继承关系后，紧挨着的就是字段表集合。字段表，即类（或接口）里声明的变量，变量分为<code>静态变量</code>（类变量）以及<code>成员变量</code>（实例变量）。</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-18-fix2.png?imageView2/0/w/1024" alt="图19"></p><p>现在详细介绍下图中<code>虚线</code>部分，这四个u2类型的字段以及<code>属性表</code>（<code>attribute_info</code>）集合代表了一个<code>field_info</code>表，它的这些字段解释如下：</p><h3 id="7-1：access-flags"><a href="#7-1：access-flags" class="headerlink" title="7.1：access_flags"></a>7.1：access_flags</h3><p>这个字段也叫<code>access_flags</code>，跟之前Class本身的access_flags所具备的意义一样，它是用来描述<code>字段</code>的<code>访问标志</code>，让我们来看看它每一位代表什么意思吧：</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-19-fix.png?imageView2/0/w/1100" alt="图20"></p><h3 id="7-2：name-index-descriptor-index"><a href="#7-2：name-index-descriptor-index" class="headerlink" title="7.2：name_index &amp; descriptor_index"></a>7.2：name_index &amp; descriptor_index</h3><p><code>name_index</code>和<code>descriptor_index</code>都是索引值，前者指向<code>常量池</code>里一个<code>CONSTANT_Utf8_info</code>，用来表示该字段的<code>简单名称</code>，后者也是指向<code>常量池</code>里一个<code>CONSTANT_Utf8_info</code>，但它用来表示字段的<code>描述符</code>（什么是简单名称，什么是描述符？请参考<code>4.1.2</code>）</p><h3 id="7-3：attributes-count-attribute-infos"><a href="#7-3：attributes-count-attribute-infos" class="headerlink" title="7.3：attributes_count &amp; attribute_infos"></a>7.3：attributes_count &amp; attribute_infos</h3><p>这段信息很复杂，代表属性表，<code>attributes_count</code>代表后面跟几个属性表，<code>attribute_infos</code>代表<code>属性表集合</code>，属性表是很复杂的一块内容，Class文件、字段表、方法表，甚至Code属性表都可以携带自己的属性表集合，属性表的种类很繁多，在<code>9.1节</code>会列举一个与本节（方法表）相关的属性表<code>ConstantValue</code>的结构。</p><h2 id="八、方法表集合"><a href="#八、方法表集合" class="headerlink" title="八、方法表集合"></a>八、方法表集合</h2><p>离开字段表后，紧挨着的就是方法表集合，它几乎跟字段表结构一致。方法表，即类（或接口）里声明的方法，同样的，方法分为<code>静态方法</code>（类方法）以及<code>成员方法</code>（实例方法）。</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-20-fix2.png?imageView2/0/w/1024" alt="图21"></p><p>同样的，来介绍下图中虚线部分，这四个u2类型的字段以及<code>属性表</code>（<code>attribute_info</code>）集合代表了一个<code>method_info</code>表，它的这些字段解释如下：</p><h3 id="8-1：access-flags"><a href="#8-1：access-flags" class="headerlink" title="8.1：access_flags"></a>8.1：access_flags</h3><p>不多说了，前面遇到很多次了，它用来描述<code>方法</code>的<code>访问标志</code>，让我们来看看它每一位代表什么意思吧：</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-21.png?imageView2/0/w/1100" alt="图22"></p><h3 id="8-2：name-index-descriptor-index"><a href="#8-2：name-index-descriptor-index" class="headerlink" title="8.2：name_index &amp; descriptor_index"></a>8.2：name_index &amp; descriptor_index</h3><p>跟字段表对应的字段作用相同，<code>name_index</code>和<code>descriptor_index</code>都是索引值，前者指向<code>常量池</code>里一个<code>CONSTANT_Utf8_info</code>，用来表示该方法的<code>简单名称</code>，后者也是指向<code>常量池</code>里一个<code>CONSTANT_Utf8_info</code>，但它用来表示方法的<code>描述符</code>（什么是简单名称，什么是描述符？请参考<code>4.1.2</code>）</p><h3 id="8-3：attributes-count-attribute-infos"><a href="#8-3：attributes-count-attribute-infos" class="headerlink" title="8.3：attributes_count &amp; attribute_infos"></a>8.3：attributes_count &amp; attribute_infos</h3><p>属性表，在<code>7.3节</code>提到过，这里的俩属性跟字段表里的意思一样，但在本节你可能会好奇，方法表定义了方法的名称和描述符，那么方法的代码跑哪里去了？其实方法本身的代码会被编译成字节码指令，存放在每个方法后面的某个属性表里，而这个属性表就是<code>Code</code>，在后续的<code>9.2</code>里会详细介绍，这里只需要记住它是出现在本节（方法表）这个位置的即可。</p><h2 id="九、属性表"><a href="#九、属性表" class="headerlink" title="九、属性表"></a>九、属性表</h2><p>前面两节或多或少提到过属性表，这是很复杂也很重要的一个表结构，下面来看下它的基本组成：</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-22.png?imageView2/0/w/1024" alt="图23"></p><p>不管属性表多么复杂，它开始的两个属性总是<code>attribute_name_index</code>和<code>attribute_length</code>，具体含义如图所示。</p><p>本节只少量介绍几个很重要的属性表，更详细的属性表可以查阅<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.7">https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.7</a></p><h3 id="9-1：ConstantValue"><a href="#9-1：ConstantValue" class="headerlink" title="9.1：ConstantValue"></a>9.1：ConstantValue</h3><p>先回看下<code>7.3</code>，该属性表仅作用在<code>字段表</code>上，用来表示一个<code>static final</code>字段的初始值，且要求该字段必须是<code>基本类型</code>或<code>String类型</code>才可以用该表表示初始值，为什么？我们来看下该表的结构：</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-23.png?imageView2/0/w/800" alt="图24"></p><p>因为<code>constantvalue_index</code>指向的一定常量池里某字面量，因此它只能是<code>CONSTANT_Long_info</code>、<code>CONSTANT_Float_info</code>、<code>CONSTANT_Double_info</code>、<code>CONSTANT_Integer_info</code>、<code>CONSTANT_String_info</code>里的一种，所以只有被声明为static final的基本类型和String类型的字段，才可能存在此属性表，用来代表其初始化值。</p><h3 id="9-2：Code"><a href="#9-2：Code" class="headerlink" title="9.2：Code"></a>9.2：Code</h3><p>这绝对是最高能的一个属性表，我们详细来解析下，从它的名字就可以看出来，它代表的是一个方法的<code>代码</code>属性，属于<code>方法表</code>（这点请牢记），这在<code>8.3</code>里提到过，我们写的程序代码最终会被<code>javac</code>编译成<code>字节码指令</code>，而这些指令就存储在Code属性表内，它的结构是怎样的呢？看图：</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-24.png?imageView2/0/w/1024" alt="图25"></p><p>这里面有很多细节，我们来逐一介绍下，就从<code>max_stack</code>开始吧~</p><h4 id="9-2-1：max-stack"><a href="#9-2-1：max-stack" class="headerlink" title="9.2.1：max_stack"></a>9.2.1：max_stack</h4><p>这个值跟<code>操作数栈</code>有关系，代表它的<code>最大深度</code>，当jvm处于运行期的时候，会根据这个值来分配<code>栈帧</code>中<code>操作数栈</code>的深度。（<code>栈帧</code>是后续文章将会介绍的概念，运行期时每一个Code模块，都会与之对应一个栈帧结构，可通过<code>10.2.5.1</code>节了解其基本概念）</p><h4 id="9-2-2：max-locals"><a href="#9-2-2：max-locals" class="headerlink" title="9.2.2：max_locals"></a>9.2.2：max_locals</h4><p>这个值也是围绕着运行期<code>栈帧</code>来生效的，它代表栈帧里<code>局部变量表</code>所需的存储空间。什么是局部变量表？早期接触java时就知道，每个方法内产生的对象、变量我们都称之为<code>局部变量</code>，它们会在运行期被暂存入方法所属栈帧里的局部变量表中，方便操作数栈存取与操作，而它需要多少存储大小呢？就是靠这个值来决定的，结合<code>9.2.1</code>可以知道，一个java方法的<code>局部变量表大小</code>、<code>操作数栈最大深度</code>都是在<code>编译期</code>就已经确定了的。</p><p>那么，存储大小的单位又是什么呢？是字节（byte）吗？比如max_locals为5，代表的是5byte的存储空间吗？</p><p>并不是，它是一个叫做<code>Slot</code>的东西，max_locals&#x3D;5，代表需要分配5个Slot。下面来介绍下Slot。</p><p>Slot有<code>32个bit位</code>，意思就是说每个Slot占<code>4字节</code>，因此，如果你有一个局部变量是int型，那么它就占1个Slot空间，如果是float或者long之类的，那就需要两个Slot。</p><p>那现在我们就可以很容易推算出一个方法的局部变量表的容量到底需要多大了：<em>总Slot量 &#x3D; 所有局部变量所用的字节量 &#x2F; 4</em></p><p>但是，这样是不对的！因为根据每个局部变量的作用域不同，Slot是可以被<code>复用</code>的，这点很重要，让我们来看个例子：</p><figure class="highlight java"><figcaption><span>代码块1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">slot</span><span class="params">(<span class="type">int</span> a)</span> &#123; <span class="comment">//入参a，为a分配一个Slot</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">//为b分配一个Slot</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b; <span class="comment">//为c分配一个Slot，但是注意，c的作用域只有if域</span></span><br><span class="line">        b = c;</span><br><span class="line">    &#125; <span class="comment">//离开if域，为c分配那个Slot会被完全闲置出来，因为c在之后的逻辑中再也无法使用了</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> b; <span class="comment">//反正c的那个Slot闲着也是浪费，不如给接下来的变量用，这里d就可以复用c的Slot</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码一共有a、b、c、d四个int型变量，理论上需要分配<code>4个</code>Slot存储，但实际只分配了<code>3个</code>，具体原因请参考代码中的注释，这种利用java语法来节省Slot的做法还是相当聪明的。</p><h4 id="9-2-3：字节码指令"><a href="#9-2-3：字节码指令" class="headerlink" title="9.2.3：字节码指令"></a>9.2.3：字节码指令</h4><p>参考<code>图25</code>，离开了<code>max_stack</code>和<code>max_locals</code>，紧接着就进入了一个非常冗长的区域，那就是<code>code</code>区域，它是你写的java程序被翻译成的一个个<code>指令码</code>，是最重要的一部分，也是直接可以被java程序员操控的部分。</p><p>字节码指令大全：<a href="https://luisstruggle.github.io/blog/javaSE7-JVM.html">https://luisstruggle.github.io/blog/javaSE7-JVM.html</a></p><p>后续会以某个实例的字节码指令集来分析这些指令是如何在<code>栈帧</code>里运行的（虽然是运行期的东西，但还是想在这一节做下简单的说明）</p><h2 id="十、实战"><a href="#十、实战" class="headerlink" title="十、实战"></a>十、实战</h2><h3 id="10-1：快速回顾"><a href="#10-1：快速回顾" class="headerlink" title="10.1：快速回顾"></a>10.1：快速回顾</h3><p>终于把字节码的详细内容讲完了，太多太长，上面是详细介绍，下面就通过一张图简单回顾一下字节码文件的堆叠顺序和内容种类：</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-25.png?imageView2/0/w/1024" alt="图26"></p><h3 id="10-2：字节码分析实战"><a href="#10-2：字节码分析实战" class="headerlink" title="10.2：字节码分析实战"></a>10.2：字节码分析实战</h3><h4 id="10-2-1：源代码"><a href="#10-2-1：源代码" class="headerlink" title="10.2.1：源代码"></a>10.2.1：源代码</h4><p>本篇会通过以下实例来具体解析字节码组成：</p><figure class="highlight java"><figcaption><span>代码块2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sun.juwin.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> j; <span class="comment">//声明一个类变量j，其在静态块里进行初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">5</span>; <span class="comment">//再声明一个类变量k，并直接初始化为5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> i; <span class="comment">//包含一个成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123; <span class="comment">//静态块，相当于类本身的构造器</span></span><br><span class="line">        j = <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span> &#123; <span class="comment">//包含两个重载构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Test init !&quot;</span>); <span class="comment">//注意，这里调用了out对象的println方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(); <span class="comment">//在这里主动触发一次无参构造器</span></span><br><span class="line">        <span class="built_in">this</span>.i = i; <span class="comment">//给i属性赋值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getK</span><span class="params">()</span> &#123; <span class="comment">//类方法，返回类属性k的值（静态方法的入参不会隐式传入this作为参数）</span></span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum_i</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="comment">//成员方法，这个方法传俩值，返回i和这俩值之和的和（成员方法的入参会隐式传入this作为参数）</span></span><br><span class="line">        <span class="keyword">return</span> i + sum(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; <span class="comment">//成员方法，计算两个数的和</span></span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; <span class="comment">//成员方法，作用跟上面的sum一样，但这个方法会多出一个Slot来存result这个局部变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> x + y;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-2-2：字节码信息"><a href="#10-2-2：字节码信息" class="headerlink" title="10.2.2：字节码信息"></a>10.2.2：字节码信息</h4><p>首先我们利用<code>javac</code>将其编译成字节码文件（我这里使用<code>jdk11</code>版本做的编译），然后利用<code>javap</code>指令，输出其字节码信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javac&amp;javap指令</span><br><span class="line"></span><br><span class="line">javac -g Test.java   //编译(-g会帮忙把调试信息也编译进去，为了说明Slot，我们需要这个)</span><br><span class="line">javap -v -p Test //输出字节码详细信息，-v表示输出详细信息，-p表示输出所有的字段和方法(不加这个的话public以下的字段方法无法展示)</span><br></pre></td></tr></table></figure><p>javap这个指令是干嘛的呢？它实际上是将编译好的字节码文件<code>反编译</code>，然后输出字节码文件里各数据项的详细信息，相比直接去读二进制的字节码文件，javap输出的字节码详细信息更加通俗易读。</p><p>现在来看下<code>代码块2</code>的字节码详细信息（太冗长了，后面会拆解说明）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">&quot;Test.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">sun</span>.juwin.test.Test</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">55</span></span><br><span class="line">  flags: (<span class="number">0x0021</span>) ACC_PUBLIC, ACC_SUPER</span><br><span class="line">  this_class: #<span class="number">7</span>                          <span class="comment">// sun/juwin/test/Test</span></span><br><span class="line">  super_class: #<span class="number">10</span>                        <span class="comment">// java/lang/Object</span></span><br><span class="line">  interfaces: <span class="number">0</span>, fields: <span class="number">3</span>, methods: <span class="number">7</span>, attributes: <span class="number">1</span></span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">10.</span>#<span class="number">39</span>        <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">40.</span>#<span class="number">41</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">3</span> = String             #<span class="number">42</span>            <span class="comment">// Test init !</span></span><br><span class="line">   #<span class="number">4</span> = Methodref          #<span class="number">43.</span>#<span class="number">44</span>        <span class="comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">   #<span class="number">5</span> = Methodref          #<span class="number">7.</span>#<span class="number">39</span>         <span class="comment">// sun/juwin/test/Test.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">6</span> = Fieldref           #<span class="number">7.</span>#<span class="number">45</span>         <span class="comment">// sun/juwin/test/Test.i:I</span></span><br><span class="line">   #<span class="number">7</span> = Class              #<span class="number">46</span>            <span class="comment">// sun/juwin/test/Test</span></span><br><span class="line">   #<span class="number">8</span> = Methodref          #<span class="number">7.</span>#<span class="number">47</span>         <span class="comment">// sun/juwin/test/Test.sum:(II)I</span></span><br><span class="line">   #<span class="number">9</span> = Fieldref           #<span class="number">7.</span>#<span class="number">48</span>         <span class="comment">// sun/juwin/test/Test.j:I</span></span><br><span class="line">  #<span class="number">10</span> = Class              #<span class="number">49</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">  #<span class="number">11</span> = Utf8               j</span><br><span class="line">  #<span class="number">12</span> = Utf8               I</span><br><span class="line">  #<span class="number">13</span> = Utf8               k</span><br><span class="line">  #<span class="number">14</span> = Utf8               ConstantValue</span><br><span class="line">  #<span class="number">15</span> = Integer            <span class="number">5</span></span><br><span class="line">  #<span class="number">16</span> = Utf8               i</span><br><span class="line">  #<span class="number">17</span> = Utf8               &lt;init&gt;</span><br><span class="line">  #<span class="number">18</span> = <span class="built_in">Utf8</span>               ()V</span><br><span class="line">  #<span class="number">19</span> = Utf8               Code</span><br><span class="line">  #<span class="number">20</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">21</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">22</span> = Utf8               <span class="keyword">this</span></span><br><span class="line">  #<span class="number">23</span> = Utf8               Lsun/juwin/test/Test;</span><br><span class="line">  #<span class="number">24</span> = <span class="built_in">Utf8</span>               (I)V</span><br><span class="line">  #<span class="number">25</span> = Utf8               getK</span><br><span class="line">  #<span class="number">26</span> = <span class="built_in">Utf8</span>               ()I</span><br><span class="line">  #<span class="number">27</span> = Utf8               sum_i</span><br><span class="line">  #<span class="number">28</span> = <span class="built_in">Utf8</span>               (II)I</span><br><span class="line">  #<span class="number">29</span> = Utf8               a</span><br><span class="line">  #<span class="number">30</span> = Utf8               b</span><br><span class="line">  #<span class="number">31</span> = Utf8               sum</span><br><span class="line">  #<span class="number">32</span> = Utf8               x</span><br><span class="line">  #<span class="number">33</span> = Utf8               y</span><br><span class="line">  #<span class="number">34</span> = Utf8               sum2</span><br><span class="line">  #<span class="number">35</span> = Utf8               result</span><br><span class="line">  #<span class="number">36</span> = Utf8               &lt;clinit&gt;</span><br><span class="line">  #<span class="number">37</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">38</span> = Utf8               Test.java</span><br><span class="line">  #<span class="number">39</span> = NameAndType        #<span class="number">17</span>:#<span class="number">18</span>        <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">40</span> = Class              #<span class="number">50</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">41</span> = NameAndType        #<span class="number">51</span>:#<span class="number">52</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">42</span> = Utf8               Test init !</span><br><span class="line">  #<span class="number">43</span> = Class              #<span class="number">53</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">44</span> = NameAndType        #<span class="number">54</span>:#<span class="number">55</span>        <span class="comment">// println:(Ljava/lang/String;)V</span></span><br><span class="line">  #<span class="number">45</span> = NameAndType        #<span class="number">16</span>:#<span class="number">12</span>        <span class="comment">// i:I</span></span><br><span class="line">  #<span class="number">46</span> = Utf8               sun/juwin/test/Test</span><br><span class="line">  #<span class="number">47</span> = NameAndType        #<span class="number">31</span>:#<span class="number">28</span>        <span class="comment">// sum:(II)I</span></span><br><span class="line">  #<span class="number">48</span> = NameAndType        #<span class="number">11</span>:#<span class="number">12</span>        <span class="comment">// j:I</span></span><br><span class="line">  #<span class="number">49</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">50</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">51</span> = Utf8               out</span><br><span class="line">  #<span class="number">52</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">53</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">54</span> = Utf8               println</span><br><span class="line">  #<span class="number">55</span> = <span class="built_in">Utf8</span>               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">static</span> <span class="keyword">final</span> <span class="type">int</span> j;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: (<span class="number">0x0019</span>) ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">static</span> <span class="keyword">final</span> <span class="type">int</span> k;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: (<span class="number">0x0019</span>) ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line">    ConstantValue: <span class="type">int</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: (<span class="number">0x0002</span>) ACC_PRIVATE</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> sun.juwin.test.<span class="built_in">Test</span>();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (<span class="number">0x0001</span>) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">7</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String Test init !</span></span><br><span class="line">         <span class="number">9</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">        <span class="number">12</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">15</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">16</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">17</span>: <span class="number">12</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">13</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lsun/juwin/test/Test;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> sun.juwin.test.<span class="built_in">Test</span>(<span class="type">int</span>);</span><br><span class="line">    descriptor: (I)V</span><br><span class="line">    flags: (<span class="number">0x0001</span>) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">5</span>                  <span class="comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: iload_1</span><br><span class="line">         <span class="number">6</span>: putfield      #<span class="number">6</span>                  <span class="comment">// Field i:I</span></span><br><span class="line">         <span class="number">9</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">20</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">21</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">22</span>: <span class="number">9</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">10</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lsun/juwin/test/Test;</span><br><span class="line">            <span class="number">0</span>      <span class="number">10</span>     <span class="number">1</span>     <span class="function">i   I</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="type">static</span> <span class="type">int</span> <span class="title">getK</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: (<span class="number">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="number">0</span>: iconst_5</span><br><span class="line">         <span class="number">1</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">25</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="built_in">sum_i</span>(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">    descriptor: (II)I</span><br><span class="line">    flags: (<span class="number">0x0001</span>) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">4</span>, locals=<span class="number">3</span>, args_size=<span class="number">3</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: getfield      #<span class="number">6</span>                  <span class="comment">// Field i:I</span></span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: iload_1</span><br><span class="line">         <span class="number">6</span>: iload_2</span><br><span class="line">         <span class="number">7</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method sum:(II)I</span></span><br><span class="line">        <span class="number">10</span>: iadd</span><br><span class="line">        <span class="number">11</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">29</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">12</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lsun/juwin/test/Test;</span><br><span class="line">            <span class="number">0</span>      <span class="number">12</span>     <span class="number">1</span>     a   I</span><br><span class="line">            <span class="number">0</span>      <span class="number">12</span>     <span class="number">2</span>     <span class="function">b   I</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">    descriptor: (II)I</span><br><span class="line">    flags: (<span class="number">0x0001</span>) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">3</span></span><br><span class="line">         <span class="number">0</span>: iload_1</span><br><span class="line">         <span class="number">1</span>: iload_2</span><br><span class="line">         <span class="number">2</span>: iadd</span><br><span class="line">         <span class="number">3</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">33</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">4</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lsun/juwin/test/Test;</span><br><span class="line">            <span class="number">0</span>       <span class="number">4</span>     <span class="number">1</span>     x   I</span><br><span class="line">            <span class="number">0</span>       <span class="number">4</span>     <span class="number">2</span>     <span class="function">y   I</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="type">int</span> <span class="title">sum2</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">    descriptor: (II)I</span><br><span class="line">    flags: (<span class="number">0x0001</span>) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">3</span></span><br><span class="line">         <span class="number">0</span>: iload_1</span><br><span class="line">         <span class="number">1</span>: iload_2</span><br><span class="line">         <span class="number">2</span>: iadd</span><br><span class="line">         <span class="number">3</span>: istore_3</span><br><span class="line">         <span class="number">4</span>: iload_3</span><br><span class="line">         <span class="number">5</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">37</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">38</span>: <span class="number">4</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">6</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lsun/juwin/test/Test;</span><br><span class="line">            <span class="number">0</span>       <span class="number">6</span>     <span class="number">1</span>     x   I</span><br><span class="line">            <span class="number">0</span>       <span class="number">6</span>     <span class="number">2</span>     y   I</span><br><span class="line">            <span class="number">4</span>       <span class="number">2</span>     <span class="number">3</span> result   I</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (<span class="number">0x0008</span>) ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">6</span></span><br><span class="line">         <span class="number">2</span>: putstatic     #<span class="number">9</span>                  <span class="comment">// Field j:I</span></span><br><span class="line">         <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;Test.java&quot;</span></span><br></pre></td></tr></table></figure><p>太长了，我们来将上面的字节码信息拆解一下进行详细分析。</p><h4 id="10-2-3：字节码-头部"><a href="#10-2-3：字节码-头部" class="headerlink" title="10.2.3：字节码-头部"></a>10.2.3：字节码-头部</h4><figure class="highlight c++"><figcaption><span>代码块4 头部</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">&quot;Test.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">sun</span>.juwin.test.Test</span><br><span class="line">  minor version: <span class="number">0</span>  <span class="comment">//这是次版本号</span></span><br><span class="line">  major version: <span class="number">55</span> <span class="comment">//这是主版本号</span></span><br><span class="line">  flags: (<span class="number">0x0021</span>) ACC_PUBLIC, ACC_SUPER <span class="comment">//这是访问标志，将0x0021转换成二进制，再跟图17一一对应，就可以得出ACC_PUBLIC和ACC_SUPER的结论</span></span><br><span class="line">  this_class: #<span class="number">7</span> <span class="comment">//#7是个常量池索引，其值为sun/juwin/test/Test，代表该类的全限定名</span></span><br><span class="line">  super_class: #<span class="number">10</span> <span class="comment">//#10也是个常量池索引，其值为java/lang/Object，代表该类的父类全限定名，默认为Object，如果真的继承了其他父类，则该值为对应父类的全限定名</span></span><br><span class="line">  interfaces: <span class="number">0</span>, fields: <span class="number">3</span>, methods: <span class="number">7</span>, attributes: <span class="number">1</span> <span class="comment">//该类实现了0个接口，共有3个字段（i、j、k），7个方法（静态块、Test()、Test(int i)、getK、sum_i、sum、sum2），1个attributes？？这个我自己没搞懂，如果指代属性表，那远不止1个，如果不是指属性表，那是什么意思呢？</span></span><br></pre></td></tr></table></figure><h4 id="10-2-3：字节码-常量池"><a href="#10-2-3：字节码-常量池" class="headerlink" title="10.2.3：字节码-常量池"></a>10.2.3：字节码-常量池</h4><figure class="highlight c++"><figcaption><span>代码块5 常量池</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">Constant pool: <span class="comment">//下面就是大杂烩的常量池了，#xx代表一个索引，所以看得时候需要找序号的按照这个值找就行了。</span></span><br><span class="line"><span class="comment">//这里说一下XXXref，在4.10和4.11介绍过，它们是指在该类内被引用到的字段或方法，因此像System.out就是一个FieldRef，而println就是一个MethodRef，同样的在sum_i方法里有对sum方法的调用，因此sum方法也是一个MethodRef</span></span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">10.</span>#<span class="number">39</span> <span class="comment">//由于该类构造器被调用时会触发其父类构造器的调用，因此父类构造器是一个MethodRef，其值为：java/lang/Object.&quot;&lt;init&gt;&quot;:()V（前面为该方法所属类的全限定名，后面为该方法的名称和描述符，#39可以往下找，是个NameAndType）</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">40.</span>#<span class="number">41</span> <span class="comment">//一个被该类引用的属性，这个找法类似上面的MethodRef，其值为：java/lang/System.out:Ljava/io/PrintStream;即：Test()方法里的System.out属性</span></span><br><span class="line">   #<span class="number">3</span> = String             #<span class="number">42</span> <span class="comment">//String字面量，指向内容为&quot;Test init !&quot;的Utf8_info</span></span><br><span class="line">   #<span class="number">4</span> = Methodref          #<span class="number">43.</span>#<span class="number">44</span> <span class="comment">//值为java/io/PrintStream.println:(Ljava/lang/String;)V，因为println被我们所引用，所以它也成为了该类的一个MethodRef</span></span><br><span class="line">   #<span class="number">5</span> = Methodref          #<span class="number">7.</span>#<span class="number">39</span> <span class="comment">//该类的一个无参构造器，值为sun/juwin/test/Test.&quot;&lt;init&gt;&quot;:()V，因为我们的有参构造器引用了它，所以它也是MethodRef，下面的各类Ref以此类推</span></span><br><span class="line">   #<span class="number">6</span> = Fieldref           #<span class="number">7.</span>#<span class="number">45</span> <span class="comment">//值为sun/juwin/test/Test.i:I</span></span><br><span class="line">   #<span class="number">7</span> = Class              #<span class="number">46</span> <span class="comment">//该类的全限定名，指向的值为sun/juwin/test/Test</span></span><br><span class="line">   #<span class="number">8</span> = Methodref          #<span class="number">7.</span>#<span class="number">47</span> <span class="comment">//值为sun/juwin/test/Test.sum:(II)I</span></span><br><span class="line">   #<span class="number">9</span> = Fieldref           #<span class="number">7.</span>#<span class="number">48</span> <span class="comment">//值为sun/juwin/test/Test.j:I</span></span><br><span class="line">  #<span class="number">10</span> = Class              #<span class="number">49</span> <span class="comment">//父类的全限定名，它已经被#1引用过一次了，值为java/lang/Object</span></span><br><span class="line">  #<span class="number">11</span> = Utf8               j <span class="comment">//字段j的简单名称文本值，应被某个字段表索引，参考7.2</span></span><br><span class="line">  #<span class="number">12</span> = Utf8               I <span class="comment">//字段的描述符文本值，同样应被某个字段表索引，参考7.2，只需要一个I即可，因为本类所定义的属性只有int一个类型</span></span><br><span class="line">  #<span class="number">13</span> = Utf8               k <span class="comment">//字段k的简单名称文本值</span></span><br><span class="line">  #<span class="number">14</span> = Utf8               ConstantValue <span class="comment">//属性表名称文本值，应被某个属性表索引，参考9.1</span></span><br><span class="line">  #<span class="number">15</span> = Integer            <span class="number">5</span> <span class="comment">//某Integer字面量的值，本例中被属性k的ConstantValue索引，参考9.1</span></span><br><span class="line">  #<span class="number">16</span> = Utf8               i <span class="comment">//字段i的简单名称文本值</span></span><br><span class="line">  #<span class="number">17</span> = Utf8               &lt;init&gt; <span class="comment">//该类构造方法的简单名称文本值，应被某个方法表索引，参考8.2</span></span><br><span class="line">  #<span class="number">18</span> = <span class="built_in">Utf8</span>               ()V <span class="comment">//某方法的描述符文本值，()V代表无参无返回值（描述符规则参考4.1.2），应被某个方法表索引，参考8.2</span></span><br><span class="line">  #<span class="number">19</span> = Utf8               Code <span class="comment">//属性表名称文本值，应被某个属性表索引，参考9.2</span></span><br><span class="line">  #<span class="number">20</span> = Utf8               LineNumberTable <span class="comment">//属性表名称文本值，应被某个属性表索引，LineNumberTable是Code属性表的一部分，参考9.2</span></span><br><span class="line">  #<span class="number">21</span> = Utf8               LocalVariableTable <span class="comment">//属性表名称文本值，应被某个属性表索引，LocalVariableTable是Code属性表的一部分，参考9.2</span></span><br><span class="line">  #<span class="number">22</span> = Utf8               <span class="keyword">this</span> <span class="comment">//字段this的简单名称（this属于隐式字段）</span></span><br><span class="line">  #<span class="number">23</span> = Utf8               Lsun/juwin/test/Test; <span class="comment">//字段描述符文本值，所有类型为sun/juwin/test/Test类型的字段，都可以使用该值作为自己的描述符</span></span><br><span class="line">  #<span class="number">24</span> = <span class="built_in">Utf8</span>               (I)V <span class="comment">//某个入参为一个int型无返回值的方法描述符文本值，本例子指Test(int i)方法</span></span><br><span class="line">  #<span class="number">25</span> = Utf8               getK <span class="comment">//getK方法的简单名称文本值</span></span><br><span class="line">  #<span class="number">26</span> = <span class="built_in">Utf8</span>               ()I <span class="comment">//某个无参返回int数据的方法的描述符文本值，本例可以指代getK()方法</span></span><br><span class="line">  #<span class="number">27</span> = Utf8               sum_i <span class="comment">//sum_i方法的简单名称文本值</span></span><br><span class="line">  #<span class="number">28</span> = <span class="built_in">Utf8</span>               (II)I <span class="comment">//某个入参为两个int型，返回一个int型值的方法的描述符文本值，在本例中，可以用来作sum_i、sum、sum2的描述符</span></span><br><span class="line">  #<span class="number">29</span> = Utf8               a <span class="comment">//这种位于局部变量表的变量名，都是在开启调试模式时（javac -g）编译的class文件才有，普通javac是没有的，下方b、x、y、result同理</span></span><br><span class="line">  #<span class="number">30</span> = Utf8               b</span><br><span class="line">  #<span class="number">31</span> = Utf8               sum <span class="comment">//sum方法的简单名称文本值</span></span><br><span class="line">  #<span class="number">32</span> = Utf8               x</span><br><span class="line">  #<span class="number">33</span> = Utf8               y</span><br><span class="line">  #<span class="number">34</span> = Utf8               sum2 <span class="comment">//sum2方法的简单名称文本值</span></span><br><span class="line">  #<span class="number">35</span> = Utf8               result</span><br><span class="line">  #<span class="number">36</span> = Utf8               &lt;clinit&gt; <span class="comment">//类初始化方法的简单名称，就是静态块，静态块被认为是类本身的&quot;构造器&quot;，如果没有静态块，那么也不会有这个方法</span></span><br><span class="line">  #<span class="number">37</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">38</span> = Utf8               Test.java <span class="comment">//本类源文件名称</span></span><br><span class="line">  #<span class="number">39</span> = NameAndType        #<span class="number">17</span>:#<span class="number">18</span> <span class="comment">//已经被#1和#5的MethodRef引用，其值为：&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">40</span> = Class              #<span class="number">50</span> <span class="comment">//类限定名：java/lang/System，被#2引用</span></span><br><span class="line">  #<span class="number">41</span> = NameAndType        #<span class="number">51</span>:#<span class="number">52</span> <span class="comment">//被#2引用，其值为：out:Ljava/io/PrintStream;即：System.out这个属性的名称和描述符</span></span><br><span class="line">  #<span class="number">42</span> = Utf8               Test init ! <span class="comment">//Test()方法里的字符串文本值，被#3引用</span></span><br><span class="line">  #<span class="number">43</span> = Class              #<span class="number">53</span> <span class="comment">//类限定名：java/io/PrintStream，被#4引用</span></span><br><span class="line">  #<span class="number">44</span> = NameAndType        #<span class="number">54</span>:#<span class="number">55</span> <span class="comment">//被#4引用，其值为：println:(Ljava/lang/String;)V，即：out.println这个方法的名称和描述符</span></span><br><span class="line">  #<span class="number">45</span> = NameAndType        #<span class="number">16</span>:#<span class="number">12</span> <span class="comment">//被#6引用，其值为：i:I，即该实例中i这个成员变量的名称和描述符</span></span><br><span class="line">  #<span class="number">46</span> = Utf8               sun/juwin/test/Test <span class="comment">//类全限定名的文本值，被#7引用</span></span><br><span class="line">  #<span class="number">47</span> = NameAndType        #<span class="number">31</span>:#<span class="number">28</span> <span class="comment">//被#8引用，其值为：sum:(II)I，即该实例中sum方法的简单名称和描述符</span></span><br><span class="line">  #<span class="number">48</span> = NameAndType        #<span class="number">11</span>:#<span class="number">12</span> <span class="comment">//被#9引用，其值为：j:I，即该实例中j这个类变量的名称和描述符</span></span><br><span class="line">  #<span class="number">49</span> = Utf8               java/lang/Object <span class="comment">//类全限定名的文本值，被#10引用</span></span><br><span class="line">  #<span class="number">50</span> = Utf8               java/lang/System <span class="comment">//类全限定名文本值，被#40引用</span></span><br><span class="line">  #<span class="number">51</span> = Utf8               out <span class="comment">//属性简单名称文本值，被#41引用</span></span><br><span class="line">  #<span class="number">52</span> = Utf8               Ljava/io/PrintStream; <span class="comment">//属性的描述符文本值，被#41引用</span></span><br><span class="line">  #<span class="number">53</span> = Utf8               java/io/PrintStream <span class="comment">//类全限定名的文本值，被#43引用</span></span><br><span class="line">  #<span class="number">54</span> = Utf8               println <span class="comment">//方法简单名称文本值，被#44引用</span></span><br><span class="line">  #<span class="number">55</span> = <span class="built_in">Utf8</span>               (Ljava/lang/String;)V <span class="comment">//方法描述符的文本值，被#44引用</span></span><br></pre></td></tr></table></figure><h4 id="10-2-4：字节码-字段表"><a href="#10-2-4：字节码-字段表" class="headerlink" title="10.2.4：字节码-字段表"></a>10.2.4：字节码-字段表</h4><p>看完了最为复杂的常量池，下面来看下字段表部分，这部分简单许多：</p><figure class="highlight c++"><figcaption><span>代码块6 字段表</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">static</span> <span class="keyword">final</span> <span class="type">int</span> j; <span class="comment">//类变量j</span></span><br><span class="line">  descriptor: I <span class="comment">//描述符，指向#12</span></span><br><span class="line">  flags: (<span class="number">0x0019</span>) ACC_PUBLIC, ACC_STATIC, ACC_FINAL <span class="comment">//参考7.1,将十六进制的0x0019转成二进制后看看哪些bit位是1哪些就是它的修饰符，显然是ACC_PUBLIC、ACC_STATIC、ACC_FINAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">static</span> <span class="keyword">final</span> <span class="type">int</span> k; <span class="comment">//类变量k</span></span><br><span class="line">  descriptor: I</span><br><span class="line">  flags: (<span class="number">0x0019</span>) ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line">  ConstantValue: <span class="type">int</span> <span class="number">5</span> <span class="comment">//参考9.1，如果一个static final的常量有直接的初始值，那么必定跟一个ConstantValue的属性表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> i; <span class="comment">//成员变量i</span></span><br><span class="line">  descriptor: I</span><br><span class="line">  flags: (<span class="number">0x0002</span>) ACC_PRIVATE</span><br></pre></td></tr></table></figure><h4 id="10-2-5：字节码-方法表"><a href="#10-2-5：字节码-方法表" class="headerlink" title="10.2.5：字节码-方法表"></a>10.2.5：字节码-方法表</h4><blockquote><p>ps：想用更加简洁的方式看方法指令的话，建议使用<code>javap -c</code>。本节只挑选<code>代码块2</code>实例中的几个具有代表性的方法来说明。</p></blockquote><p>下面就是我们的方法表了，内部会包含Code这个涵盖方法主要逻辑的指令码，我们这节会一点点分析这些指令是如何在<code>操作数栈</code>里运行的（<code>操作数栈</code>是运行期要学的一个结构，先做个了解，它位于<code>栈帧</code>内，主要负责执行Code指令码），这里要注意：栈是一种<code>先进后出</code>的数据结构，既然操作数栈是栈，那么必然满足这一点特性。</p><h5 id="10-2-5-1：无参构造器-Test"><a href="#10-2-5-1：无参构造器-Test" class="headerlink" title="10.2.5.1：无参构造器-Test()"></a>10.2.5.1：无参构造器-Test()</h5><p>javap输出的详细信息：</p><figure class="highlight c++"><figcaption><span>代码块7 方法表-Test()</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> sun.juwin.test.<span class="built_in">Test</span>(); <span class="comment">//Test方法，Code区域的指令集是如何在操作数栈运行的？请看图27</span></span><br><span class="line">  descriptor: ()V <span class="comment">//方法描述符，指向#18</span></span><br><span class="line">  flags: (<span class="number">0x0001</span>) ACC_PUBLIC <span class="comment">//参考8.1</span></span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span> <span class="comment">//依次为：最大栈深、逻辑Slot数量（实际上可能少于这个，因为Slot可复用）、参数size，成员方法默认传入this，所以即便Test()里没有参数，这里args_size也是1</span></span><br><span class="line">       <span class="number">0</span>: aload_0 <span class="comment">//取this</span></span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span> <span class="comment">//调用方法：java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: getstatic     #<span class="number">2</span> <span class="comment">//获取类属性：java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">7</span>: ldc           #<span class="number">3</span> <span class="comment">//ldc是指从常量池中取值，放入操作数栈，值为：Test init !</span></span><br><span class="line">       <span class="number">9</span>: invokevirtual #<span class="number">4</span> <span class="comment">//调用方法：java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">12</span>: <span class="keyword">return</span> <span class="comment">//返回指令，用于终止程序</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">15</span>: <span class="number">0</span> <span class="comment">//源代码15行对应指令码第0行，剩下的类推即可（这里源代码以代码块2为准）</span></span><br><span class="line">      line <span class="number">16</span>: <span class="number">4</span></span><br><span class="line">      line <span class="number">17</span>: <span class="number">12</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature <span class="comment">//这里只有一个Slot，它的下标为0</span></span><br><span class="line">          <span class="number">0</span>      <span class="number">13</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lsun/juwin/test/Test;</span><br></pre></td></tr></table></figure><p>先来看下其源代码：</p><figure class="highlight java"><figcaption><span>代码块8</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span> &#123; <span class="comment">//隐式传入this作参数</span></span><br><span class="line">  <span class="built_in">super</span>(); <span class="comment">//隐式调了父类构造器</span></span><br><span class="line">System.out.println(<span class="string">&quot;Test init !&quot;</span>); <span class="comment">//输出一段话</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它对应的指令码参考<code>代码块7-Code部分</code></p><p>当一个线程运行到此方法，会为其创建一个<code>栈帧</code>。</p><blockquote><p><strong>栈帧的基本概念</strong></p><p>栈帧是用于支持jvm进行<code>方法调用</code>和<code>方法执行</code>的<code>数据结构</code>，它是运行期保存在<code>虚拟机栈</code>中的栈元素，是线程运行的基本单元，由<code>执行引擎</code>触发执行其内部保存的字节码指令（这里执行引擎在执行代码时还分为<code>解释执行</code>和<code>编译执行</code>）。栈帧由<code>局部变量表</code>、<code>操作数栈</code>、<code>动态连接</code>、<code>方法返回地址</code>、<code>附加信息</code>组成</p></blockquote><p>Test()方法栈帧结构如图：</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-26.png?imageView2/0/w/1024" alt="图27"></p><p>现在，让我们看一下这个方法在运行时，栈帧内部是如何变化的：</p><p>栈帧初始状态：入参首先填充进局部变量表</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-27-fix.png?imageView2/0/w/600" alt="图28"></p><blockquote><p>解释：首先Test方法是一个非静态方法，其方法第一个入参就是<code>this</code>这个reference类型的变量，因此aload_0就是将该变量推向操作数栈的栈顶。</p></blockquote><p>第一步：<code>aload_0</code>，代表将局部变量表内第0个Slot内保存的变量入栈</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-28-fix.png?imageView2/0/w/600" alt="图29"></p><p>第二步：<code>invokespecial</code>，代表一次构造方法的调用，根据<code>代码块7</code>可知这里调用的是其父类的构造方法</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-29-fix2.png?imageView2/0/w/650" alt="图30"></p><p>随着Object构造方法触发，随之又产生了一个Object构造器的栈帧，用来执行父类构造器逻辑，传入的是<code>子类对象指针this</code>，这点要记住。为了优化内存，jvm开发者们经常会将新开栈帧的<code>局部变量表</code>和上一栈帧的<code>操作数栈</code>共享一些数据，共享是完全按照下一栈帧接收的参数个数来的，比如下一栈帧需要5个参数，那么当前栈帧操作数栈从栈顶开始往下数5个，全部会共享进下一栈帧的局部变量表里。</p><p>还有一点需要说明一下，我们知道在一个对象的构造器被触发时，它的父类构造器首先会被触发，此时很多人认为父类跟子类一样，肯定也是被<code>new</code>了一次，其实不然，集合<code>图29</code>和<code>图30</code>可知，在Test类的构造器被触发之前，就已经存在<code>this指针</code>了，那意味着类对象已经产生了，因此构造器是在对象产生后主动触发的，而父类也没有被new，仅仅是触发了一下它的构造器而已，你可以理解，一个子类对象，其实就是包含了其父类公共方法的类，不存在对象嵌套的情况（即一个子类的对象是不会包含一个父类对象的），这个在<code>第六节</code>会详细讲，本节做个预热即可。</p><p>最后随着新开栈帧运行结束，线程又会再次回到当前栈帧，并将当前栈帧内的操作数栈<code>共享部分</code>清空，若下一栈帧有<code>返回值</code>，则将该值存入当前栈帧的<code>栈顶</code>，否则不进行其他操作。说到这里也知道为什么栈帧也是栈了，先进入的栈帧最后才会执行完，越是新开的栈帧越先结束，这似乎也是栈的特性。</p><p>第三步：<code>getstatic</code>，用来获取某个类的静态属性，由<code>代码块7</code>可知，这里是从类常量池里获取到的<code>PrintStream</code>类型的<code>System</code>类的<code>out</code>静态属性，即<code>System.out</code>。</p><blockquote><p>提示：<code>getstatic</code>的执行流程应为：从常量池获取常量的<code>描述符</code>，然后根据描述符里指示的类和属性名，去对应的类里拿到该属性的值。</p></blockquote><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-30-fix.png?imageView2/0/w/600" alt="图31"></p><p>第四步：<code>ldc</code>，由<code>代码块7</code>可知，这是从常量池里加载String类型字面量“Test init !”入栈</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-31.png?imageView2/0/w/600" alt="图32"></p><p>第五步：<code>invokevirtual</code>，代表了一次虚方法的调用，本例指的是对out对象的<code>println</code>方法的调用</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-32-fix2.png?imageView2/0/w/650" alt="图33"></p><p>结合上图来思考下println的两个参数，首先我们需要明确一点，println不是静态方法，因此它传入的第一个参数一定是“this”，即对象引用，其实任何非静态方法的访问都是如此，需要知道自己的对象是哪位，否则没意义，那么针对println这个方法的“this”，又是谁呢？答案是out，我们是用out对象调用的它，所以这里第一个入参一定是out对象，第二个入参则是“Test init !”，所以上图中共享给下游栈帧的一共有俩，已用<code>红框</code>标出。</p><p>第六步：<code>return</code>，方法执行结束，栈帧出让，就不画图了。</p><p>到这里，我们已经完成了一组指令码的执行过程解析。</p><h5 id="10-2-5-2：sum-i-int-a-int-b"><a href="#10-2-5-2：sum-i-int-a-int-b" class="headerlink" title="10.2.5.2：sum_i(int a, int b)"></a>10.2.5.2：sum_i(int a, int b)</h5><p>再来分析一个方法的执行流程，我们把javap的信息丢出来（这里就不加注释了）：</p><figure class="highlight c++"><figcaption><span>代码块9</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">sum_i</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">  descriptor: (II)I</span><br><span class="line">  flags: (<span class="number">0x0001</span>) ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">4</span>, locals=<span class="number">3</span>, args_size=<span class="number">3</span></span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: getfield      #<span class="number">6</span>                  <span class="comment">// Field i:I</span></span><br><span class="line">       <span class="number">4</span>: aload_0</span><br><span class="line">       <span class="number">5</span>: iload_1</span><br><span class="line">       <span class="number">6</span>: iload_2</span><br><span class="line">       <span class="number">7</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method sum:(II)I</span></span><br><span class="line">      <span class="number">10</span>: iadd</span><br><span class="line">      <span class="number">11</span>: ireturn</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">29</span>: <span class="number">0</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">0</span>      <span class="number">12</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lsun/juwin/test/Test;</span><br><span class="line">          <span class="number">0</span>      <span class="number">12</span>     <span class="number">1</span>     a   I</span><br><span class="line">          <span class="number">0</span>      <span class="number">12</span>     <span class="number">2</span>     b   I</span><br></pre></td></tr></table></figure><p>它的源代码如下：</p><figure class="highlight java"><figcaption><span>代码块10</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum_i</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> i + sum(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它有3个参数，还发生过一次方法调用，最后还要将方法返回的值再加上i属性，然后将结果返回出去，我们来看下这个方法的运行过程。</p><p>老样子，来看下栈帧初始状态：入参首先填充进局部变量表</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-33-fix.png?imageView2/0/w/600" alt="图34"></p><p>这是个非静态方法，第一个参数依然是该方法对应类的某个对象的引用指针（即this），剩下两个参数就是源代码里的a和b。</p><p>第一步：<code>aload_0</code>，代表将局部变量表内第0个Slot内保存的变量入栈，即this入栈，因为接下来的<code>getfield</code>指令要用到，这跟非静态方法需要this的道理一样，获取某个非静态的属性，也需要知道是哪个对象，才能取到对应的值，这就是非静态属性和方法与静态属性方法最大的区别。</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-34-fix.png?imageView2/0/w/600" alt="图35"></p><p>第二步：<code>getfield</code>，这个指令用来获取某对象的某个属性值，本例中为<code>i</code></p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-35-fix.png?imageView2/0/w/600" alt="图36"></p><blockquote><p>提示：<code>getfield</code>执行流程：从常量池获取属性的<code>描述符</code>，然后根据描述符里指示的类和属性名，去对应的<code>类对象</code>里拿到该属性的值。（图中第2步就是利用当前栈顶的this，来打入其内部，将其对应<code>属性i</code>的值取出，并设置入栈顶，替换掉原来的this）</p></blockquote><p>第三步：<code>aload_0</code>，再次将局部变量表内第0个Slot内保存的变量入栈</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-36.png?imageView2/0/w/600" alt="图37"></p><p>第四步：将入参a和b入栈</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-37.png?imageView2/0/w/600" alt="图38"></p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-38.png?imageView2/0/w/600" alt="图39"></p><p>第五步：<code>invokevirtual</code>，虚方法调用，本例指的是对<code>sum方法</code>的调用，通过实例代码可知，sum方法拥有三个参数，即<code>this</code>、<code>a</code>、<code>b</code>，因此开栈帧时需要共享当前栈帧自栈顶往下数3个栈位作为新栈帧的入参</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-39.png?imageView2/0/w/790" alt="图40"></p><p>注意，<code>sum方法</code>是有返回值的，返回值为a和b相加的结果，最终sum栈帧执行完毕再次回到sum_i栈帧时，会将其返回结果入栈，最终sum执行完毕后的情况如下：</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-40.png?imageView2/0/w/600" alt="图41"></p><p>第六步：<code>iadd</code>，将栈顶两int型数值相加，并且其运算结果入栈</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-41.png?imageView2/0/w/600" alt="图42"></p><p>第七步：<code>ireturn</code>，将现在位于栈顶的数据返回出去给上游的栈帧，就不画图了。</p><p>到目前，sum_i方法的执行流程就剖析完毕。</p><h2 id="十一、小结"><a href="#十一、小结" class="headerlink" title="十一、小结"></a>十一、小结</h2><p>本章介绍了Class文件本身的<code>组成</code>以及它内部数据的<code>堆叠</code>方式，还介绍了运行期指令码是怎么被<code>执行引擎</code>所运行的，可以尝试利用这些知识，分析日常中较为复杂的类的字节码文件，熟悉字节码指令对于我们理解日常java代码的一些“特殊性质”有一定的积极作用。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、JAVA的平台无关性&quot;&gt;&lt;a href=&quot;#一、JAVA的平台无关性&quot; class=&quot;headerlink&quot; title=&quot;一、JAVA的平台无关性&quot;&gt;&lt;/a&gt;一、JAVA的平台无关性&lt;/h2&gt;&lt;p&gt;我们最开始学习java的时候了解到java代码文件必须经过&lt;code&gt;javac&lt;/code&gt;的编译，生成字节码文件才可以被JVM识别并运行，而JVM则拥有多种操作系统的版本：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://myblog.sharemer.com/2020/05/06/20200506-1-1-fixed.png?imageView2/0/w/700&quot; alt=&quot;图1&quot;&gt;&lt;/p&gt;
&lt;p&gt;正是因为这些不同操作系统下的JVM版本，使得我们被编译后的字节码文件可以被不同操作系统上的JVM识别并运行，继而实现跨平台。&lt;/p&gt;</summary>
    
    
    
    <category term="JVM" scheme="http://example.com/categories/JVM/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>【JAVA进化论】LV5-6：java并发包-juc的简单介绍</title>
    <link href="http://example.com/2020/04/02/%E3%80%90JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA%E3%80%91LV5-6%EF%BC%9Ajava%E5%B9%B6%E5%8F%91%E5%8C%85-juc%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
    <id>http://example.com/2020/04/02/%E3%80%90JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA%E3%80%91LV5-6%EF%BC%9Ajava%E5%B9%B6%E5%8F%91%E5%8C%85-juc%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</id>
    <published>2020-04-02T10:15:00.000Z</published>
    <updated>2023-12-06T10:30:56.107Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、线程池"><a href="#一、线程池" class="headerlink" title="一、线程池"></a>一、线程池</h2><h3 id="1-1：简单介绍"><a href="#1-1：简单介绍" class="headerlink" title="1.1：简单介绍"></a>1.1：简单介绍</h3><p>前面简单提了一嘴线程池，回想下我们前几节内容提到的线程创建：</p><figure class="highlight java"><figcaption><span>代码块1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>();</span><br><span class="line">t1.start(); <span class="comment">//毫无意义的一个线程被创建并触发了，这个线程不会执行任何逻辑</span></span><br></pre></td></tr></table></figure><span id="more"></span><p>这段简单的代码，会在运行的时候向操作系统申请开启一个线程，当我们利用这个线程把我们的业务代码运行完，线程就会被销毁，再次会议一下线程的生命周期那张图。</p><p>但是线程是稀缺资源，当我们的程序里存在大量开启-关闭线程这种操作时，对于系统本身是一种浪费，其次，开启线程是有性能开销的，所以有没有一种方法，可以让线程创建之后，就不再死亡，而是用的时候直接去一个地方拿，用完了也不再销毁它，而是重新放回去，等待别的地方使用呢？</p><p>线程池诞生了！</p><p>跟它的名字一样，它是个用来存放线程对象的池子，最开始就会往里面放一定量的线程，别人需要使用线程的时候，它便从池子里取到一个闲置的线程用来给别人使用，别人用完了，就回收这个线程，接下来给别人用。</p><h3 id="1-2：初始化线程池"><a href="#1-2：初始化线程池" class="headerlink" title="1.2：初始化线程池"></a>1.2：初始化线程池</h3><p>简单记一下，有下面三种快速初始化线程池对象的方法：</p><ul><li><strong>Executors.newCachedThreadPool()：</strong>无限线程池。</li><li><strong>Executors.newFixedThreadPool(nThreads)：</strong>创建固定大小的线程池。</li><li><strong>Executors.newSingleThreadExecutor()：</strong>创建单个线程的线程池。</li></ul><p>我们目前用newCachedThreadPool的情况比较多，它可以无限创建线程，每个线程被创建后都可以活60s的时间，期间可以被反复使用。</p><p>例子：</p><figure class="highlight java"><figcaption><span>代码块2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//全局声明一个线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//直接启动一个线程来运行async方法</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(Test::async);</span><br><span class="line">        t.start();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//使用线程池提供的线程运行async方法</span></span><br><span class="line">        threadPool.execute(Test::async); <span class="comment">//利用execute方法触发线程运行</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">async</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程名为&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;正在运行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、ReentrantLock"><a href="#二、ReentrantLock" class="headerlink" title="二、ReentrantLock"></a>二、ReentrantLock</h2><h3 id="2-1：简介"><a href="#2-1：简介" class="headerlink" title="2.1：简介"></a>2.1：简介</h3><p>前面讲了使用<code>synchronized</code>同步块来解决多线程下操作同一块资源的安全性问题，现在，来认识<code>juc</code>下同样可以实现同步控制的锁：<code>ReentrantLock</code></p><p>ReentrantLock实现了Lock接口，除此之外，相比synchronized只支持非公平锁的特性，它支持灵活配置锁竞争的<code>公平</code>和<code>非公平</code>模式，什么是锁竞争的公平与非公平呢？我们继续来拿之前的流程图举例：</p><p><img src="http://myblog.sharemer.com/2020/04/02/20200402-2-1.png?imageView2/0/w/1200" alt="图1"></p><h3 id="2-2：用法"><a href="#2-2：用法" class="headerlink" title="2.2：用法"></a>2.2：用法</h3><figure class="highlight java"><figcaption><span>代码块3</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Word</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//全局声明一个重入锁作为成员变量，这样，使用这个变量控制的同步块就跟原先的对象锁功能相同，只在同一个对象下生效</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">false</span>); <span class="comment">//参数代表启用公平或者非公平的锁竞争模式，我们这里设置为非公平</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//声明为static的情况下，跟之前的类锁相似，只要属于这个类，这个锁则全生效</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lockAll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">false</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//对象锁，相同对象被多个线程访问才会生效</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;A方法被调用&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">//释放锁，为了保证锁释放一定会被执行，一般放到finally块里</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//类锁，只要是Word对象，被多个线程访问时都会上锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">B</span><span class="params">()</span> &#123;</span><br><span class="line">        lockAll.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;B方法被调用&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3：await、signal、signalAll"><a href="#2-3：await、signal、signalAll" class="headerlink" title="2.3：await、signal、signalAll"></a>2.3：await、signal、signalAll</h3><p>同样的ReentrantLock也支持线程通信，我们可以利用ReentrantLock来改写下前面的那个阻塞队列：</p><figure class="highlight java"><figcaption><span>代码块4</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//阻塞队列类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockQueue</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; msgs = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//不同于synchronized可以利用对象里的wait和notify，想要利用ReentrantLock实现线程通信，需要使用lock对象生成一个condition对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        lock.lock(); <span class="comment">//将synchronized同步块换成lock的方式进行</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msgs.add(msg); <span class="comment">//存放进</span></span><br><span class="line">            condition.signalAll(); <span class="comment">//效果等于notifyAll</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (msgs.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    condition.await(); <span class="comment">//效果等于wait</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> msgs.remove(msgs.size() - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果跟之前是一样的。</p><h2 id="三、利用线程池的Future模式做到跟join一样的效果"><a href="#三、利用线程池的Future模式做到跟join一样的效果" class="headerlink" title="三、利用线程池的Future模式做到跟join一样的效果"></a>三、利用线程池的Future模式做到跟join一样的效果</h2><p>还是前面优化大首页的例子，我们不在将Dao层的代码列出来，我们仅看service层的异步实现，对比下不同：</p><figure class="highlight java"><figcaption><span>代码块5</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步获取，通过多线程优化性能</span></span><br><span class="line"><span class="keyword">public</span> WebModule <span class="title function_">getWebModuleMsgSimpleAsync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">WebModule</span> <span class="variable">webModule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebModule</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">topTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; webModule.setTop(moduleDao.getTop()));</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">leftTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; webModule.setLeft(moduleDao.getLeft()));</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">rightTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; webModule.setRight(moduleDao.getRight()));</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">userTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; webModule.setUser(moduleDao.getUser()));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//触发各个异步任务</span></span><br><span class="line">    topTask.start();</span><br><span class="line">    leftTask.start();</span><br><span class="line">    rightTask.start();</span><br><span class="line">    userTask.start();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//等待所有的任务均执行完毕</span></span><br><span class="line">    topTask.join();</span><br><span class="line">    leftTask.join();</span><br><span class="line">    rightTask.join();</span><br><span class="line">    userTask.join();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> webModule;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我们使用普通方式创建线程，然后使用join来完成的异步任务调度，结合最开始说的有关线程池的优点来看这个流程，会发现我们一下子就创建了4个线程，这是有开销的，那么线程池是否也能完成类似这种操作呢？</p><figure class="highlight java"><figcaption><span>代码块6</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程池Future模式完成异步操作</span></span><br><span class="line"><span class="keyword">public</span> WebModule <span class="title function_">getWebModuleMsgAsync</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    Future&lt;String&gt; top = threadPool.submit(moduleDao::getTop);</span><br><span class="line">    Future&lt;String&gt; left = threadPool.submit(moduleDao::getLeft);</span><br><span class="line">    Future&lt;String&gt; right = threadPool.submit(moduleDao::getRight);</span><br><span class="line">    Future&lt;String&gt; user = threadPool.submit(moduleDao::getUser);</span><br><span class="line">    <span class="type">WebModule</span> <span class="variable">webModule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebModule</span>();</span><br><span class="line">    webModule.setTop(top.get());</span><br><span class="line">    webModule.setLeft(left.get());</span><br><span class="line">    webModule.setRight(right.get());</span><br><span class="line">    webModule.setUser(user.get());</span><br><span class="line">    <span class="keyword">return</span> webModule;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就是我们利用线程池改造后的<code>代码块5</code>，它的运行效果是和<code>代码块5</code>一致的。</p><h2 id="四、异步任务编排：CompletableFuture"><a href="#四、异步任务编排：CompletableFuture" class="headerlink" title="四、异步任务编排：CompletableFuture"></a>四、异步任务编排：CompletableFuture</h2><p>有时候，我们需要拿到某个方法的结果后再去拿着这个结果去调用别的方法，这时就不能盲目使用<code>join</code>或者线程池来做异步，juc提供了更高级的类：<code>CompletableFuture</code></p><p>详细用法请查看附件：<a href="/2019/03/14/%E5%88%A9%E7%94%A8CompletableFuture%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87/">利用CompletableFuture优化程序的执行效率</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、线程池&quot;&gt;&lt;a href=&quot;#一、线程池&quot; class=&quot;headerlink&quot; title=&quot;一、线程池&quot;&gt;&lt;/a&gt;一、线程池&lt;/h2&gt;&lt;h3 id=&quot;1-1：简单介绍&quot;&gt;&lt;a href=&quot;#1-1：简单介绍&quot; class=&quot;headerlink&quot; title=&quot;1.1：简单介绍&quot;&gt;&lt;/a&gt;1.1：简单介绍&lt;/h3&gt;&lt;p&gt;前面简单提了一嘴线程池，回想下我们前几节内容提到的线程创建：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;figcaption&gt;&lt;span&gt;代码块1&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;t1&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;Thread&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;t1.start(); &lt;span class=&quot;comment&quot;&gt;//毫无意义的一个线程被创建并触发了，这个线程不会执行任何逻辑&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="JAVA进化论" scheme="http://example.com/categories/JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA/"/>
    
    
    <category term="JAVA进化论" scheme="http://example.com/tags/JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>【JAVA进化论】LV5-5：线程调度：join、yield、sleep、interrupt</title>
    <link href="http://example.com/2020/04/02/%E3%80%90JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA%E3%80%91LV5-5%EF%BC%9A%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%EF%BC%9Ajoin%E3%80%81yield%E3%80%81sleep%E3%80%81interrupt/"/>
    <id>http://example.com/2020/04/02/%E3%80%90JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA%E3%80%91LV5-5%EF%BC%9A%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%EF%BC%9Ajoin%E3%80%81yield%E3%80%81sleep%E3%80%81interrupt/</id>
    <published>2020-04-02T07:51:00.000Z</published>
    <updated>2023-12-06T10:25:20.477Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>这些方法属于线程对象里的方法，属于线程本身的操作。</p><p><strong>join：</strong>用于等待一个线程的终止，等待期间将会进入阻塞状态，直到被等待的线程终止结束。</p><p><strong>yield：</strong>用于线程让步，触发了此方法的线程会进入就绪状态，也就是说会让出CPU的调度一下，让CPU转去其他线程。</p><p><strong>sleep：</strong>强制当前正在运行的线程进入阻塞状态，直到休眠期结束，才会再次进入运行状态。</p><p><strong>interrupt：</strong>终止当前正在运行的线程。</p><span id="more"></span><h2 id="二、用法"><a href="#二、用法" class="headerlink" title="二、用法"></a>二、用法</h2><h3 id="2-1：join"><a href="#2-1：join" class="headerlink" title="2.1：join"></a>2.1：join</h3><p>前面说过它简单的用法，来看个例子：</p><figure class="highlight java"><figcaption><span>代码块1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;main线程开始运行&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000L</span>); <span class="comment">//让当前线程阻塞1s</span></span><br><span class="line">            System.out.println(<span class="string">&quot;线程1运行结束&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000L</span>); <span class="comment">//让当前线程阻塞5s</span></span><br><span class="line">            System.out.println(<span class="string">&quot;线程2运行结束&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//线程1和2启动</span></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//利用join，可以让main线程必须等到它们俩线程运行完毕后才会继续往下执行</span></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;main线程运行结束&quot;</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="http://myblog.sharemer.com/2020/04/02/20200402-1-1.png?imageView2/0/w/700" alt="图1"></p><p>最终运行结果告诉我们，由于<code>t1</code>和<code>t2</code>在<code>main线程</code>里<code>join</code>，因此main线程在join处必须要等到t1和t2都运行结束后才会继续往下运行。</p><p>它的流程像是下面这样：</p><p><img src="http://myblog.sharemer.com/2020/04/02/20200402-1-2.png?imageView2/0/w/900" alt="图2"></p><p>此时main方法总耗时约等于5s。</p><p>基于这种流程理解，我们让t1和t2调用join前，让main线程<code>阻塞6s</code>（超过t1和t2并发运行的总耗时），此时join便不再阻塞main线程了，因为t1和t2已经执行结束了：</p><p><img src="http://myblog.sharemer.com/2020/04/02/20200402-1-3.png?imageView2/0/w/900" alt="图3"></p><p>相比<code>图2</code>，main线程阻塞的时间甚至还多出了一截，此时总运行时间约为6s。</p><h3 id="2-2：【实例】利用join优化一个大首页接口的效率"><a href="#2-2：【实例】利用join优化一个大首页接口的效率" class="headerlink" title="2.2：【实例】利用join优化一个大首页接口的效率"></a>2.2：【实例】利用join优化一个大首页接口的效率</h3><p>假设现在有一个网站，首页有顶部Banner位、左边栏、右边栏、用户信息几大模块需要加载，现在出一个接口，要求包装并吐出这几大模块的内容。</p><p>先来抽象一个首页接口对象：</p><figure class="highlight java"><figcaption><span>代码块2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebModule</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String top; <span class="comment">//顶部Banner位</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String left; <span class="comment">//左边栏</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String right; <span class="comment">//右边栏</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String user; <span class="comment">//用户信息</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//...get...set...</span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;top: %s;  left: %s;  right: %s;  user: %s&quot;</span>, top, left, right, user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义我们的dao层，我们利用sleep来模拟实际的方法耗时：</p><figure class="highlight java"><figcaption><span>代码块3</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ModuleDao</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTop</span><span class="params">()</span> &#123; <span class="comment">// 这里假设getTop需要执行200ms</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;顶部banner位&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getLeft</span><span class="params">()</span> &#123; <span class="comment">// 这里假设getLeft需要执行50ms</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">50L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;左边栏&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getRight</span><span class="params">()</span> &#123; <span class="comment">// 这里假设getRight需要执行80ms</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">80L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;右边栏&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUser</span><span class="params">()</span> &#123; <span class="comment">// 这里假设getUser需要执行100ms</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;用户信息&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再定义一个service层，提供两个方法，它们的目的都是通过dao层提供的数据，封装成WebModule对象返回给网关层（controller层）：</p><figure class="highlight java"><figcaption><span>代码块4</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ModuleService</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="type">ModuleDao</span> <span class="variable">moduleDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModuleDao</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 同步获取</span></span><br><span class="line">    <span class="keyword">public</span> WebModule <span class="title function_">getWebModuleMsgSync</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">WebModule</span> <span class="variable">webModule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebModule</span>();</span><br><span class="line">        webModule.setTop(moduleDao.getTop());</span><br><span class="line">        webModule.setLeft(moduleDao.getLeft());</span><br><span class="line">        webModule.setRight(moduleDao.getRight());</span><br><span class="line">        webModule.setUser(moduleDao.getUser());</span><br><span class="line">        <span class="keyword">return</span> webModule;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 同步获取，通过多线程优化性能</span></span><br><span class="line">    <span class="keyword">public</span> WebModule <span class="title function_">getWebModuleMsgSimpleAsync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="type">WebModule</span> <span class="variable">webModule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebModule</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">topTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; webModule.setTop(moduleDao.getTop()));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">leftTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; webModule.setLeft(moduleDao.getLeft()));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">rightTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; webModule.setRight(moduleDao.getRight()));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">userTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; webModule.setUser(moduleDao.getUser()));</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//触发各个异步任务</span></span><br><span class="line">        topTask.start();</span><br><span class="line">        leftTask.start();</span><br><span class="line">        rightTask.start();</span><br><span class="line">        userTask.start();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//等待所有的任务均执行完毕</span></span><br><span class="line">        topTask.join();</span><br><span class="line">        leftTask.join();</span><br><span class="line">        rightTask.join();</span><br><span class="line">        userTask.join();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> webModule;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用controller层来测试下：</p><figure class="highlight java"><figcaption><span>代码块5</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只是模拟，其实网关层应该是servlet或者spring boot的controller（后续会认识到）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ModuleController</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="type">ModuleService</span> <span class="variable">moduleService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModuleService</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> WebModule <span class="title function_">getWebModuleMsgSync</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> moduleService.getWebModuleMsgSync();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> WebModule <span class="title function_">getWebModuleMsgSimpleAsync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">return</span> moduleService.getWebModuleMsgSimpleAsync();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="type">ModuleController</span> <span class="variable">moduleController</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModuleController</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">//获取系统当前时间戳，ms</span></span><br><span class="line">        moduleController.getWebModuleMsgSync(); <span class="comment">//同步获取各个模块的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;同步获取各个模块，所需时间为：&quot;</span> + (System.currentTimeMillis() - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="type">long</span> <span class="variable">start2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        moduleController.getWebModuleMsgSimpleAsync(); <span class="comment">//异步获取各个模块的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;异步获取各个模块，所需时间为：&quot;</span> + (System.currentTimeMillis() - start2) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><figcaption><span>代码块6</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">同步获取各个模块，所需时间为：442ms</span><br><span class="line">异步获取各个模块，所需时间为：207ms</span><br></pre></td></tr></table></figure><p>我们利用多线程异步+join的方式，将代码性能优化了足足1倍多。</p><p>我们再使用执行流程图来说明下它们的运行流程：</p><p>同步方法<code>getWebModuleMsgSync</code>的运行流程</p><p><img src="http://myblog.sharemer.com/2020/04/02/20200402-1-4.png?imageView2/0/w/1024" alt="图4"></p><p>异步方法<code>getWebModuleMsgSimpleAsync</code>的运行流程</p><p><img src="http://myblog.sharemer.com/2020/04/02/20200402-1-5.png?imageView2/0/w/600" alt="图5"></p><blockquote><p>请结合代码和流程图，仔细理解下join。截止到目前，你已经会用多线程优化一个慢接口了~</p></blockquote><h3 id="2-3：sleep"><a href="#2-3：sleep" class="headerlink" title="2.3：sleep"></a>2.3：sleep</h3><p>我们前面的例子在不断的用这个方法，只需要知道，你在任何地方写上Thread.sleep(xxx);这段代码，就是在让运行该段代码的线程阻塞（休眠）。</p><h3 id="2-4：interrupt-stop"><a href="#2-4：interrupt-stop" class="headerlink" title="2.4：interrupt&amp;stop"></a>2.4：interrupt&amp;stop</h3><p>都用于主动终止一个线程，区别在于，<code>interrupt</code>比较<code>温和</code>，<code>stop</code>属于<code>暴力关停</code>，我们下面通过一个例子来看下它们的区别。</p><p>线程本身调用这俩方法后，视为已终止状态，下面来用interrupt和join来做个实验：</p><figure class="highlight java"><figcaption><span>代码块7</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinTest</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isStop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">JoinTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JoinTest</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">loopT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(test::loopTask); <span class="comment">//test::loopTask等于test.loopTask()</span></span><br><span class="line">        loopT.start();</span><br><span class="line"> </span><br><span class="line">        sleep(<span class="number">2000L</span>); <span class="comment">//2s后终止线程</span></span><br><span class="line">        test.setStop(<span class="literal">true</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="type">long</span> <span class="variable">s</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        loopT.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程终止后，join阻塞时间为：&quot;</span> + (System.currentTimeMillis() - s));</span><br><span class="line">        System.out.println(<span class="string">&quot;end~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStop</span><span class="params">(<span class="type">boolean</span> stop)</span> &#123;</span><br><span class="line">        isStop = stop;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loopTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!isStop) &#123; <span class="comment">//若状态为false，则继续执行下面的逻辑，每隔1s打印一次</span></span><br><span class="line">            sleep(<span class="number">1000L</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;loop trigger ~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.currentThread().interrupt(); <span class="comment">//在这里终止掉当前线程</span></span><br><span class="line">        <span class="comment">//事实上，在终止掉线程后，还有接下来的逻辑要执行</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">s</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>]; <span class="comment">//模拟耗时操作，这里不能用sleep了，因为当前线程已经被终止了</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程终止后，逻辑块运行时间：&quot;</span> + (System.currentTimeMillis() - s));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(time);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><figcaption><span>代码块8</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loop trigger ~</span><br><span class="line">loop trigger ~</span><br><span class="line">线程终止后，逻辑块运行时间：98</span><br><span class="line">线程终止后，join阻塞时间为：114</span><br><span class="line">end~</span><br></pre></td></tr></table></figure><p>通过interrupt终止线程，即便线程被终止了，后面的逻辑也会触发，join依旧会选择阻塞，直到后续逻辑执行完毕，事实上，大部分任务都可以及时的终止，比如第一个例子，异步出去的任务，最终都会执行完成，线程变为终止状态，join都可以顺利结束，但是反观上例，如果没人及时的设置isStop的值，程序会一直执行下去，没有终止态，join会无止境的终止下去。</p><p>而stop，线程的stop方法已被官方标记为“不建议使用”的方法，如果把上例的interrupt的调用换成stop，来看看其运行结果：</p><figure class="highlight shell"><figcaption><span>代码块9</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">loop trigger ~</span><br><span class="line">loop trigger ~</span><br><span class="line">线程终止后，join阻塞时间为：0</span><br><span class="line">end~</span><br></pre></td></tr></table></figure><p>可以看到，线程终止后的后续逻辑均没有触发，前面说过，stop是一种很粗暴的终止线程的方式，一旦被stop，那么里面的业务逻辑将直接断掉，因此官方并不推荐使用该方法来终止线程。</p><p>而interrupt，仅仅是对目标线程发送了了一个中断信号（改变了线程的中断状态而已），当目标线程再次通过<strong>obj.wait、thread.sleep、thread.join</strong>方法进入阻塞状态时，接收到该信号，就会抛出<strong>InterruptedException</strong>异常，这时候需要业务方自行处理或者直接抛出，以结束线程阻塞状态（这里需要注意的是被obj.wait方法阻塞时，抛出该异常需要目标线程再次获得实例对象obj的锁才行）。</p><p>上述三个“需要花费时间”的方法均抛出了<strong>InterruptedException</strong>异常，针对这些特性，想要完成以下操作就非常方便了：</p><ol><li>取消wait方法等待notify&#x2F;notifyAll的处理</li><li>取消在sleep方法指定时间内停止的处理</li><li>取消join方法等待其他线程终止的处理</li></ol><p>取消之后所做的处理，取决于需求，可能会终止线程，或者通知用户已取消，或者终止当前处理进入下一个处理阶段。</p><h3 id="2-5：yield"><a href="#2-5：yield" class="headerlink" title="2.5：yield"></a>2.5：yield</h3><p>通过前面的理解，我们知道线程是靠CPU通过来回切换执行的方式来执行多个线程的，那么你知道你的线程通过代码调用start后，会发生哪些状态变化吗？</p><p>首先，start触发线程后，线程状态进入运行状态，而我们前面讲过CPU是来回切换运行线程的，所以我们针对”被调度到“和”等待被调度“两种情况又对运行状态又做了细分，即运行中和就绪：</p><blockquote><p>⚠️ 请务必仔细跟着图中的序号顺序梳理一遍这个流程，对之后的线程生命周期理解起来很有帮助</p></blockquote><p><img src="http://myblog.sharemer.com/2020/04/02/20200402-1-6.png?imageView2/0/w/1024" alt="图6"></p><p>为什么要说这个呢？因为它可以帮你理解yield，yield被当前线程触发后，首先当前线程会直接进入”就绪状态“，你可以这么理解，当前线程做出yield调用之后，会将本该调度到它的CPU”让出去“，让CPU重新调度一次，注意我这里说的是重新调度一次，所以即便调用了yield，下次CPU仍然有概率调度到它，来看下这个过程：</p><p><img src="http://myblog.sharemer.com/2020/04/02/20200402-1-7.png?imageView2/0/w/1100" alt="图7"></p><p>看到了吗？任意线程只要自行触发自己的yield方法，就会立马让自己变成就绪态，然后让CPU重新选择线程调度，重新调度意味着可能会调度到其它线程，也可能再次调度到自己，如果再次调度到自己（如图中的情况2），那么就只能继续往下执行咯，等于yield无用，如果调度到别人（如图中的情况1）则yield有意义，因为你确实让出了CPU让别人进入运行态了。</p><p>就不举例子了，你也看到了，yield的意义是这样的，本就不好举例，但是这个过程一定要梳理清楚，至少你要知道线程处于运行状态的时候，又根据CPU调度状态细分了就绪和运行中状态。</p><h2 id="三、线程状态迁移图"><a href="#三、线程状态迁移图" class="headerlink" title="三、线程状态迁移图"></a>三、线程状态迁移图</h2><p>截止目前，我们知道一个线程对象可以通过下面的方法改变自己的运行状态：</p><ol><li>通过start让自己变成运行中状态。而运行中状态又根据有没有被CPU调度到分成了就绪态和运行中两个状态</li><li>通过sleep让自己陷入阻塞状态，阻塞状态意味着CPU不会再调度到它，除非它解除阻塞变为就绪状态</li><li>通过调用其它线程的join方法让自己在其它线程结束前陷入阻塞状态，其它线程结束后，自己再次由阻塞变为就绪状态</li><li>通过某个对象的wait方法，让自己处于阻塞状态，然后再次通过同一对象的notify触发，让自己变成就绪状态</li><li>通过yield让自己让出正在调度自己的CPU，让自己直接进入就绪状态</li><li>通过interrupt或者stop让自己变成终止状态</li></ol><p>我们结合上面的六条信息，整理下一个线程的生命周期，应该包含哪几个状态：</p><p>运行状态（又细分为就绪和运行中两个小状态）、阻塞状态、终止状态</p><p>让我们来画下线程的生命周期，或者叫线程状态转换图：</p><p><img src="http://myblog.sharemer.com/2019/03/13/20190313-1-2.png?imageView2/0/w/1024" alt="图8"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h2&gt;&lt;p&gt;这些方法属于线程对象里的方法，属于线程本身的操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;join：&lt;/strong&gt;用于等待一个线程的终止，等待期间将会进入阻塞状态，直到被等待的线程终止结束。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;yield：&lt;/strong&gt;用于线程让步，触发了此方法的线程会进入就绪状态，也就是说会让出CPU的调度一下，让CPU转去其他线程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sleep：&lt;/strong&gt;强制当前正在运行的线程进入阻塞状态，直到休眠期结束，才会再次进入运行状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;interrupt：&lt;/strong&gt;终止当前正在运行的线程。&lt;/p&gt;</summary>
    
    
    
    <category term="JAVA进化论" scheme="http://example.com/categories/JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA/"/>
    
    
    <category term="JAVA进化论" scheme="http://example.com/tags/JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>【JAVA进化论】LV5-4：线程通信：wait、notify、notifyall</title>
    <link href="http://example.com/2020/04/01/%E3%80%90JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA%E3%80%91LV5-4%EF%BC%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%9Await%E3%80%81notify%E3%80%81notifyall/"/>
    <id>http://example.com/2020/04/01/%E3%80%90JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA%E3%80%91LV5-4%EF%BC%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%9Await%E3%80%81notify%E3%80%81notifyall/</id>
    <published>2020-04-01T14:35:00.000Z</published>
    <updated>2023-12-06T10:20:19.927Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Object类里对线程实施控制的方法"><a href="#一、Object类里对线程实施控制的方法" class="headerlink" title="一、Object类里对线程实施控制的方法"></a>一、Object类里对线程实施控制的方法</h2><p>前面说过，<code>Object</code>是所有类的父类，它自带<code>equals</code>、<code>hashCode</code>等方法，我们这次来介绍几个新的成员方法：</p><span id="more"></span><p><img src="http://myblog.sharemer.com/2020/04/01/20200401-3-1.png" alt="图1"></p><p>这节要讲的<code>wait</code>、<code>notify</code>、<code>notifyall</code>都是Object里自带的方法，通过这些方法可以控制当前正在运行这个对象的线程，如何控制？往下看~</p><h2 id="二、利用线程控制方法完成线程通信"><a href="#二、利用线程控制方法完成线程通信" class="headerlink" title="二、利用线程控制方法完成线程通信"></a>二、利用线程控制方法完成线程通信</h2><p>上述几个方法是属于每个实例对象的，所有实例都拥有一个“等待队列”（虚拟概念，实例里并不存在该字段），它是在实例的wait方法调用后存放停止操作线程的队列。执行wait方法后，线程进入当前实例的“等待队列”，以下几种情况可以让线程退出“等待队列”：</p><ol><li>其他线程调用<code>notify</code>、<code>notifyAll</code>方法来将其<code>唤醒</code></li><li>其他线程调用<code>interrupt</code>来将其<code>唤醒</code></li><li><code>wait</code>方法本身<code>超时</code></li></ol><h3 id="2-1：wait"><a href="#2-1：wait" class="headerlink" title="2.1：wait"></a>2.1：wait</h3><p>当执行了下面的代码：</p><figure class="highlight java"><figcaption><span>代码块1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.wait();</span><br></pre></td></tr></table></figure><p>我们可以说当前线程在obj上发生了等待，当前线程进入了obj的“等待队列”，此时当前线程会让出锁，让其他线程继续竞争获得该实例的锁（因此这里有个规则，调用wait的线程<strong>必须持有当前实例对象的锁</strong>）</p><blockquote><p>⚠️ 普通不加synchronized的方法也可以使用wait，这在编译器是没问题的，但是运行期会报<code>IllegalMonitorStateException</code>异常。</p></blockquote><p>还是以前面提过的Word对象为例，但是现在A这个方法里调用了wait方法，这时多线程访问时过程就变成了下图：</p><p><img src="http://myblog.sharemer.com/2020/04/01/20200401-3-2.png?imageView2/0/w/1024" alt="图2"></p><h3 id="2-2：notify"><a href="#2-2：notify" class="headerlink" title="2.2：notify"></a>2.2：notify</h3><p>现在先来介绍下<code>notify</code>，该方法会将等待队列里的线程取出，让其退出等待并参与锁竞争然后继续执行上次wait后没有执行完的语句。整体过程如下图所示：</p><p><img src="http://myblog.sharemer.com/2020/04/01/20200401-3-3.png?imageView2/0/w/1224" alt="图3"></p><p>可以看到，t1在被挂起后，会因为t2调用了<strong>同实例的notify</strong>方法，而让t1被从等待队列里释放，重新加入到所得竞争力，t2执行完毕后释放锁，锁又再次被t1竞争到，t1将继续执行上次被挂起时后面未执行完的语句。</p><p>需要指出的是，如果等待队列里的线程是多个，那么被唤醒的那一个，将会是等待队列里所有线程随机的一个，不会特定哪一个线程会被唤起。</p><h3 id="2-3：notifyAll"><a href="#2-3：notifyAll" class="headerlink" title="2.3：notifyAll"></a>2.3：notifyAll</h3><p>接下来介绍<code>notifyAll</code>方法，顾名思义，就是将等待队列里的线程<code>全部唤起</code>，然后这些线程将全部加入到锁竞争，竞争到，继续完成上次被挂起时未执行完毕的操作，流程图如下：</p><p><img src="http://myblog.sharemer.com/2020/04/01/20200401-3-4.png?imageView2/0/w/1224" alt="图4"></p><p>说明，当线程调用实例的<code>wait</code>、<code>notify</code>、<code>notifyAll</code>方法有个大前提，就是必须要求该线程<code>拥有</code>该实例的<code>锁</code>，否则会抛<code>IllegalMonitorStateException</code>异常。</p><p>在编写程序时，是该选择notify还是选择notifyAll？这个可以指出的是，notifyAll往往更加<code>健壮</code>，而notify由于唤起的线程少，因此效率会更高，但是存在程序停止的<code>风险</code>。</p><h2 id="三、实例"><a href="#三、实例" class="headerlink" title="三、实例"></a>三、实例</h2><h3 id="3-1：wait-notify的简单例子"><a href="#3-1：wait-notify的简单例子" class="headerlink" title="3.1：wait+notify的简单例子"></a>3.1：wait+notify的简单例子</h3><p>以<code>图4</code>里的Word对象为例，我们将这个Word类定义出来：</p><figure class="highlight java"><figcaption><span>代码块2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Word</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">A</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A方法 wait触发前&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.wait(); <span class="comment">//将竞争到对象锁后运行到这里的线程，放入到自己的wait队列，让它处于&quot;挂起&quot;的状态</span></span><br><span class="line">        System.out.println(<span class="string">&quot;A方法 wait触发后&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">B</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B方法被触发~&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类，我们开启两个线程来访问同一个word对象里的同步方法：</p><figure class="highlight java"><figcaption><span>代码块3</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Word</span> <span class="variable">w1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Word</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            w1.A(); <span class="comment">//第一个线程触发w1对象的A方法</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            w1.B(); <span class="comment">//第二个线程触发w1对象的B方法</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000L</span>); <span class="comment">//t1启动后main线程睡眠一秒，确保t1可以抢到w1的对象锁</span></span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个运行结果为：</p><figure class="highlight shell"><figcaption><span>代码块4</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A方法 wait触发前</span><br><span class="line">B方法被触发~</span><br><span class="line">A方法 wait触发后</span><br></pre></td></tr></table></figure><p>看到了吗？明明t1抢到了对象锁，但是只运行了A方法wait前面的部分，这时因为运行到wait时被挂起，释放锁，然后1s后t2抢到锁，运行B方法，然后触发B方法里的notifyAll后，所有放到w1对象等待队列里的线程被唤起，重新加入到锁竞争里去，此时t1再次竞争到w1的对象锁，然后把自己没执行完的方法栈执行完。</p><h3 id="3-2：利用线程通信实现阻塞队列"><a href="#3-2：利用线程通信实现阻塞队列" class="headerlink" title="3.2：利用线程通信实现阻塞队列"></a>3.2：利用线程通信实现阻塞队列</h3><p>大体流程如下：</p><p><img src="http://myblog.sharemer.com/2020/04/01/20200401-3-5.png?imageView2/0/w/500" alt="图5"></p><p>简单来说，就是有一个<code>公共缓冲带</code>，我们管它叫做<code>消息队列</code>，可以由多个生产者往它里面生产数据，可以由多个消费者获取，当队列内无消息可读时，所有消费者陷入等待，等待新的消息到来：</p><p><img src="http://myblog.sharemer.com/2020/04/01/20200401-3-6.png?imageView2/0/w/500" alt="图6"></p><p>根据这个结构的特性，我们可以利用本节所学<code>wait</code>和<code>notify</code>来编写。</p><p>定义阻塞队列类，根据我们上面的描述，一个组的队列应该具备生产和获取的能力：</p><figure class="highlight java"><figcaption><span>代码块5</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//阻塞队列类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockQueue</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; msgs = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(); <span class="comment">//用于存放生产者生产的消息的结构</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//因为支持多个生产者往里面生产数据，之前说过ArrayList线程不安全，所以这里需要给这个方法加锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        msgs.add(msg); <span class="comment">//存放进</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll(); <span class="comment">//生产完就通知消费者们，让它们知道有消息可以消费了~</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (msgs.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait(); <span class="comment">//如果生产者生产的消息都被消费者拿完了，那么消费者想再拿的时候就只能陷入等待，等待生产者再次生产信息</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> msgs.remove(msgs.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来开启几个独立的线程来当成是生产者程序和消费者程序，分别对BlockQueue对象进行生产-消费的操作：</p><figure class="highlight java"><figcaption><span>代码块6</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">BlockQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BlockQueue</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        queue.put(<span class="string">&quot;1号生产者生产的消息&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        queue.put(<span class="string">&quot;2号生产者生产的消息&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        queue.put(<span class="string">&quot;3号生产者生产的消息&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    p1.start();</span><br><span class="line">    p2.start();</span><br><span class="line">    p3.start(); <span class="comment">//此时这三个代表着生产者的线程被启动，意味着队列里的list已经有了三条数据</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者1消费到的消息：&quot;</span> + queue.get()); <span class="comment">//消费者线程从阻塞队列里获取消息</span></span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者2消费到的消息：&quot;</span> + queue.get()); <span class="comment">//消费者线程从阻塞队列里获取消息</span></span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者3消费到的消息：&quot;</span> + queue.get()); <span class="comment">//消费者线程从阻塞队列里获取消息</span></span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    c1.start();</span><br><span class="line">    c2.start();</span><br><span class="line">    c3.start(); <span class="comment">//此时这三个代表着消费者的线程被启动，若执行完毕，则意味着队列里的list已变成空值</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//此时队列里的消息已经被消费完，现在我们再开启一个消费者，让它继续获取消息（此时便会陷入等待）</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者4消费到的消息：&quot;</span> + queue.get()); <span class="comment">//由于消息空了，因此该消费者线程会陷入queue对象的等待队列，挂起自己</span></span><br><span class="line">    &#125;);</span><br><span class="line">    c4.start();</span><br><span class="line"> </span><br><span class="line">    Thread.sleep(<span class="number">5000L</span>); <span class="comment">//等待5s后，我们再开启一个生产者线程，让它产生一条消息</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">p4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        queue.put(<span class="string">&quot;4号生产者生产的消息&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    p4.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="http://myblog.sharemer.com/2020/04/01/20200401-3-7.png" alt="图7"></p><p>这个流程，如果对线程通信还不是很熟悉的话就需要仔细分析一下😁</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、Object类里对线程实施控制的方法&quot;&gt;&lt;a href=&quot;#一、Object类里对线程实施控制的方法&quot; class=&quot;headerlink&quot; title=&quot;一、Object类里对线程实施控制的方法&quot;&gt;&lt;/a&gt;一、Object类里对线程实施控制的方法&lt;/h2&gt;&lt;p&gt;前面说过，&lt;code&gt;Object&lt;/code&gt;是所有类的父类，它自带&lt;code&gt;equals&lt;/code&gt;、&lt;code&gt;hashCode&lt;/code&gt;等方法，我们这次来介绍几个新的成员方法：&lt;/p&gt;</summary>
    
    
    
    <category term="JAVA进化论" scheme="http://example.com/categories/JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA/"/>
    
    
    <category term="JAVA进化论" scheme="http://example.com/tags/JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>【JAVA进化论】LV5-3：java里的同步锁</title>
    <link href="http://example.com/2020/04/01/%E3%80%90JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA%E3%80%91LV5-3%EF%BC%9Ajava%E9%87%8C%E7%9A%84%E5%90%8C%E6%AD%A5%E9%94%81/"/>
    <id>http://example.com/2020/04/01/%E3%80%90JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA%E3%80%91LV5-3%EF%BC%9Ajava%E9%87%8C%E7%9A%84%E5%90%8C%E6%AD%A5%E9%94%81/</id>
    <published>2020-04-01T13:25:00.000Z</published>
    <updated>2023-12-06T10:16:20.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、为什么会存在线程安全问题？"><a href="#一、为什么会存在线程安全问题？" class="headerlink" title="一、为什么会存在线程安全问题？"></a>一、为什么会存在线程安全问题？</h2><h3 id="1-1：用户如何访问我的程序？"><a href="#1-1：用户如何访问我的程序？" class="headerlink" title="1.1：用户如何访问我的程序？"></a>1.1：用户如何访问我的程序？</h3><p>我们前面了解了java如何开启一个线程做异步处理，也知道了在实际的项目里，我们写的的web程序也被tomcat安排成了多线程调用的程序。</p><p>如果现在只有一个用户访问我们的web程序，这个过程再针对tomcat细化下，如下：</p><p><img src="http://myblog.sharemer.com/2020/04/01/20200401-2-1.png?imageView2/0/w/1024" alt="图1"></p><span id="more"></span><p>tomcat接收客户端请求的流程大致如上图所示，但是我们也可以同时接收和响应多个用户的请求和响应，当请求数据包进入我们的tomcat时，它会从它自带的线程池里取出一个空闲的线程，用于执行具体的servlet逻辑，也就是你写的业务程序。</p><blockquote><p><code>线程池</code>：事先申请好一批线程，存放到一个结构里（可以是数组，也可以是集合，能存线程对象就行），这样就不用每次进来一个请求就去向操作系统申请一个线程，申请线程开销是比较大的，事先开启一批放到一个结构里，用的时候直接拿来用即可，这种技术叫<code>池化技术</code>，之后的数据库<code>连接池</code>也属于一种<code>池化技术</code>，本质上都是避免开销大的操作，让它们事先准备好，不至于用的时候现用现申请，可以提升程序效率。</p><p>注意，线程是操作系统层面的东西，只是每种语言都支持申请，像java之前的<code>new Thread</code>语句在创建一个Thread对象的同时，也会向操作系统申请创建一个实际的线程出来，Thread类其实只是对申请的线程的抽象，你可以通过这个类来操纵具体的线程，就像你可以利用HttpServletRequest类在Servlet场景里操作HTTP协议信息一样。</p></blockquote><p><code>图1</code>里tomcat的处理模式只有一个客户端一次请求，试想一下，你这个tomcat程序放到服务器上是要给全国人民访问的，我们来结合压测来理解，我们单机一个接口的压测成绩在500qps我们都会觉得超级低，而我们的接口平均响应时间在20ms，如果就是一个用户访问我们的tomcat，完成后再让第二个用户访问，以此类推，这样显然是不合理的，让我们做个数学题，每个用户访问我们这个接口都消耗20ms，1s是1000ms，如果是按照排队访问的方式，1s只能处理<strong>（1000&#x2F;20 &#x3D; 50）</strong>个用户的请求，然而我们觉得这种接口，不压到1000qps都算是非常非常低的成绩。既然是这样，tomcat在处理用户请求的时候，就不可能是处理完一个再处理一个，一定是一起处理的，基于此，我们引出多线程下的tomcat处理模式，来看下多线程模式下的tomcat运行方式，拿之前的例子StudentInfoController来说事：</p><p><img src="http://myblog.sharemer.com/2020/04/01/20200401-2-2.png?imageView2/0/w/1024" alt="图2"></p><p>通过<code>图2</code>可以更清晰的看到，多个用户同时访问你的web程序时的样子，可以看到进来的请求都是被从线程池里取到的线程并发执行的，换句话说，下面的代码是会被多线程并发执行的：</p><figure class="highlight java"><figcaption><span>代码块1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentInfoController</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="type">StudentDao</span> <span class="variable">studentDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentDao</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        resp.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">result</span> <span class="operator">=</span> studentDao.getStudentInfo();</span><br><span class="line">            resp.getOutputStream().write(JSON.toJSONBytes(result));</span><br><span class="line">            resp.setStatus(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            resp.setStatus(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2：线程安全问题"><a href="#1-2：线程安全问题" class="headerlink" title="1.2：线程安全问题"></a>1.2：线程安全问题</h3><p>先记住<code>1.1</code>关于tomcat的访问分发模式。我们现在来看下线程安全问题主要是指什么。</p><p>线程安全问题主要是指多条线程对同一个公共资源的操作，导致的一系列”违反常规“的事情，举个例子，现在来定义一个类：</p><figure class="highlight java"><figcaption><span>代码块2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adder</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incre</span><span class="params">()</span> &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getI</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类很简单，有一个叫i的属性，incre方法用来给自己这个属性做+1操作，getI用于返回这个属性值。</p><p>来编写下main方法，我们让同一个Adder对象被两个不同的线程做incre的调用：</p><figure class="highlight java"><figcaption><span>代码块3</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="type">Adder</span> <span class="variable">adder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adder</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">            adder.incre(); <span class="comment">//第一个线程让Adder对象里的i自增1000次</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">2000</span>; j++) &#123;</span><br><span class="line">            adder.incre(); <span class="comment">//第二个线程让Adder对象里的i自增2000次</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//启动线程</span></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    <span class="comment">//利用线程睡眠，让main线程睡眠2s，等待上面两个线程执行完毕</span></span><br><span class="line">    Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line"> </span><br><span class="line">    System.out.println(adder.getI());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个线程让i自增1000次，第二个线程让i自增2000次，我们这时来猜一下最终运行结果应该是多少？3000吗？是的，看逻辑是3000没错！可是运行下，多运行几遍，就会发现诡异的事情发生了：</p><figure class="highlight shell"><figcaption><span>代码块4</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2160</span><br><span class="line">2698</span><br><span class="line">3000</span><br><span class="line">3000</span><br><span class="line">2863</span><br><span class="line">3000</span><br></pre></td></tr></table></figure><p>我运行了6次，得到的结果让人惊讶，不仅不完全正确，甚至很”随机“，这便是线程安全问题。</p><p>还记得一开始说的吗？造成线程安全问题的原因主要是因为多个线程同时操作同一公共资源造成的，在本例中，Adder的对象就是个公共资源，自然它内部的i属性也是个公共资源了。那这种线程安全问题到底是如何导致的呢？我们根据本例进行分析一下：</p><p><img src="http://myblog.sharemer.com/2020/04/01/20200401-2-3.png?imageView2/0/w/900" alt="图3"></p><p>如图所示，仿照incre的逻辑，做了一个流程图，incre的逻辑一定是先从Adder对象里拿到i的值，然后做+1计算，然后将计算结果重新写回对象的i属性，这没问题，在单线程下运行良好，但是现在线程2也做类似的操作，这时就有问题了，因为某一时刻，从内存取到的i值可能是相同的，例如第一次调用incre方法时，线程1和线程2同时取i的值，此时都是0，然后各自完成incre的调用，再将i写回对象，发现问题了吗？虽然线程1和线程2都执行了incre方法，但最终俩线程写回内存的i的值都是1，这就是为什么结果会不准的原因，不过你会发现，结果除了不准，它还随机，这就牵扯到多线程调用的一个随机性，线程是独立的、同时运行的，所以我前面描述的问题有可能发生，也有可能不发生，但只要发生一次，就足以影响结果的准确性，而发生的次数又是随机的，这也是结果为什么随机的原因。</p><h2 id="二、synchronize关键词的作用"><a href="#二、synchronize关键词的作用" class="headerlink" title="二、synchronize关键词的作用"></a>二、synchronize关键词的作用</h2><h3 id="2-1：synchronize是干啥的？"><a href="#2-1：synchronize是干啥的？" class="headerlink" title="2.1：synchronize是干啥的？"></a>2.1：synchronize是干啥的？</h3><p>首先它是个方法的修饰词，可以修饰成员方法，也可以修饰静态方法，也可以单独作为域来修饰一个代码块，被它修饰的方法或代码块，相当于加了个同步锁，在被多线程访问时，线程会发生”排队“，也就是后面会说的锁竞争，从而保证一个方法在多线程方法下有且仅有一个线程可以运行它。</p><h3 id="2-2：对象锁"><a href="#2-2：对象锁" class="headerlink" title="2.2：对象锁"></a>2.2：对象锁</h3><h4 id="2-2-1：利用对象锁解决Adder类的累加问题"><a href="#2-2-1：利用对象锁解决Adder类的累加问题" class="headerlink" title="2.2.1：利用对象锁解决Adder类的累加问题"></a>2.2.1：利用对象锁解决Adder类的累加问题</h4><p>作用在对象上的同步锁，以对象实例为单位给访问它的线程进行”排队“，我们上面的例子就符合这种规则，我们现在让上面的incre方法变成一个同步方法（被<code>synchronize</code>修饰的方法，被称作同步方法）：</p><figure class="highlight java"><figcaption><span>代码块5</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adder</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">incre</span><span class="params">()</span> &#123; <span class="comment">//改成同步方法</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getI</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在再来测试下<code>代码块3</code>里的内容：</p><figure class="highlight shell"><figcaption><span>代码块6</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3000</span><br><span class="line">3000</span><br><span class="line">3000</span><br><span class="line">3000</span><br><span class="line">3000</span><br><span class="line">3000</span><br></pre></td></tr></table></figure><p>事实上，incre方法加了锁之后，不管运行几遍，程序始终都是正确的3000次。</p><p>为什么呢？再试着理解下<code>图3</code>，看看不加锁的时候是怎么导致最终结果不正确的？就是因为两个线程同一时刻访问统一资源导致的，那么再结合我们<code>2.1</code>中所描述的，加了<code>synchronize</code>的方法，在有多个线程同时访问自己的时候，只放行一个，另外一个排队，直到第一个线程执行完毕释放掉锁后，另外一个线程才可能进入：</p><p><img src="http://myblog.sharemer.com/2020/04/01/20200401-2-4.png?imageView2/0/w/900" alt="图4"></p><p>由于锁的控制，我们如<code>图3</code>里的线程安全性问题被解决了~</p><p>本例中的锁属于同步锁里的对象锁，它的作用域仅限于对象本身，一个线程要想访问它内部被<code>synchronize</code>修饰了的方法、代码块，则必须要获取当前对象的锁，就像<code>图4</code>中那样。</p><figure class="highlight java"><figcaption><span>代码块7</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectLock</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">incre</span><span class="params">()</span> &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decre</span><span class="params">()</span> &#123;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setI</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我不在同步块内，我可以被多个线程同时触发运行&quot;</span>);</span><br><span class="line">        <span class="comment">//这时同步块，只有线程竞争到对象锁时才能访问</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123; <span class="comment">//同步代码块，括号里声明为this，代表这个代码块上的锁是对象锁</span></span><br><span class="line">            <span class="built_in">this</span>.i = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，任何线程要想调用incre、decre、setI的同步代码块，都必须要竞争到当前ObjectLock对象的对象锁，否则排队等待别的线程释放。</p><h4 id="2-2-2：对象锁的作用域"><a href="#2-2-2：对象锁的作用域" class="headerlink" title="2.2.2：对象锁的作用域"></a>2.2.2：对象锁的作用域</h4><p>通过前面的了解，对象锁指的是当前线程获得了某个实例的锁，然后对其内部”上了锁“的资源的访问，举个例子，有个Word类，有A、B两个同步方法，C属于普通方法，如图所示：</p><p><img src="http://myblog.sharemer.com/2020/04/01/20200401-2-5.png?imageView2/0/w/1024" alt="图5"></p><p>可以发现，对象锁的作用域只针对当前对象生效，就像<code>w1</code>和<code>w2</code>里的A方法可以被不同的线程同时执行，但是同一个对象内的同步块，却只允许持有当前对象锁的线程执行，如<code>t2</code>、<code>t3</code>均被挡在了外面，当<code>t1</code>释放锁以后，<code>t2</code>、<code>t3</code>才会重新竞争锁，竞争到锁以后就会执行自己想要执行的同步逻辑。</p><p>这跟我们后面要说的类锁很不一样。</p><h3 id="2-3：类锁"><a href="#2-3：类锁" class="headerlink" title="2.3：类锁"></a>2.3：类锁</h3><p>跟对象锁的目标是一致的，就是控制线程同时访问，与对象锁不同的是，它是按照类来进行上锁的，就像普通方法和<code>static</code>方法一样，一个属于对象范畴的，一个属于类范畴的。</p><p>一般使用<code>synchronize</code>修饰的<code>static</code>方法，或者这样声明同步块：</p><figure class="highlight java"><figcaption><span>代码块8</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (XXX.class)&#123; <span class="comment">//跟对象锁用this做声明不一样，类锁使用class本身做声明</span></span><br><span class="line">   ...略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类锁的作用域跟对象锁不太一样，改造下Word类，让其方法都变成静态的，<code>图5</code>里的访问就要变成下面这样：</p><p><img src="http://myblog.sharemer.com/2020/04/01/20200401-2-6.png?imageView2/0/w/1024" alt="图6"></p><p>跟上面相比较，这里的<code>t5</code>受到了<code>t1</code>的影响，因为<code>t1</code>获得了Word类的锁，<code>w1</code>和<code>w2</code>共属一个类，因此<code>t1</code>获得类锁以后，其他线程想要访问这个类里的同步块，就得等到<code>t1</code>释放锁以后才可以继续竞争锁然后执行自己想要执行的同步逻辑。</p><h3 id="2-4：死锁"><a href="#2-4：死锁" class="headerlink" title="2.4：死锁"></a>2.4：死锁</h3><p>死锁就是指两个线程互相等待对方释放锁资源的现象，举个例子：线程1持有对象a的对象锁，线程2持有对象b的对象锁，此时a对象里需要调用b对象的同步方法，而对象b也需要调用对象a的同步方法，这时线程1在等着获取对象b的对象锁，线程2等着获取对象a的对象锁，互不撒手，此时就导致程序发生了死锁，我们通过代码来说明下这个问题：</p><p>定义一个DeadLock类：</p><figure class="highlight java"><figcaption><span>代码块9</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">Object</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">//为了便于说明问题，我们随便new个a对象</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">//为了便于说明问题，我们随便new个b对象</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (a) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程1已经获取到了a对象的对象锁，进入同步块~&quot;</span>);</span><br><span class="line">            <span class="comment">//假设接下来需要获取b对象的对象锁才能正常运行</span></span><br><span class="line">            <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1已经获取到了b的对象锁，进入同步块~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程2已经获取到了b对象的对象锁，进入同步块~&quot;</span>);</span><br><span class="line">            <span class="comment">//假设接下来需要获取a对象的对象锁才能正常运行</span></span><br><span class="line">            <span class="keyword">synchronized</span> (a) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2已经获取到了a的对象锁，进入同步块~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序输出：</p><figure class="highlight shell"><figcaption><span>代码块10</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线程1已经获取到了a对象的对象锁，进入同步块~</span><br><span class="line">线程2已经获取到了b对象的对象锁，进入同步块~</span><br></pre></td></tr></table></figure><p>然后阻塞，一直阻塞，这俩线程算是废了，这就是死锁，线程1和线程2各自等着对方释放自己需要的锁，可是这是不可能的，因为同步块不执行完锁是没办法释放的。</p><h2 id="三、锁的种类有哪些？synchronize属于哪一种？"><a href="#三、锁的种类有哪些？synchronize属于哪一种？" class="headerlink" title="三、锁的种类有哪些？synchronize属于哪一种？"></a>三、锁的种类有哪些？synchronize属于哪一种？</h2><p>锁的分类太多太杂，感兴趣的话可以通过美团技术团队这篇文章来了解：<a href="https://tech.meituan.com/2018/11/15/java-lock.html">不可不说的Java“锁”事</a></p><p><code>synchronized</code>在实现上属于一种<code>可重入</code>的<code>非公平锁</code>，之后会结合java底层有关<code>synchronized</code>的实现来给具体的说一说同步锁。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、为什么会存在线程安全问题？&quot;&gt;&lt;a href=&quot;#一、为什么会存在线程安全问题？&quot; class=&quot;headerlink&quot; title=&quot;一、为什么会存在线程安全问题？&quot;&gt;&lt;/a&gt;一、为什么会存在线程安全问题？&lt;/h2&gt;&lt;h3 id=&quot;1-1：用户如何访问我的程序？&quot;&gt;&lt;a href=&quot;#1-1：用户如何访问我的程序？&quot; class=&quot;headerlink&quot; title=&quot;1.1：用户如何访问我的程序？&quot;&gt;&lt;/a&gt;1.1：用户如何访问我的程序？&lt;/h3&gt;&lt;p&gt;我们前面了解了java如何开启一个线程做异步处理，也知道了在实际的项目里，我们写的的web程序也被tomcat安排成了多线程调用的程序。&lt;/p&gt;
&lt;p&gt;如果现在只有一个用户访问我们的web程序，这个过程再针对tomcat细化下，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://myblog.sharemer.com/2020/04/01/20200401-2-1.png?imageView2/0/w/1024&quot; alt=&quot;图1&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="JAVA进化论" scheme="http://example.com/categories/JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA/"/>
    
    
    <category term="JAVA进化论" scheme="http://example.com/tags/JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>【JAVA进化论】LV3-4：反射[转载]</title>
    <link href="http://example.com/2020/04/01/%E3%80%90JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA%E3%80%91LV5-2%EF%BC%9A%E5%B9%B6%E5%8F%91&amp;%E5%B9%B6%E8%A1%8C/"/>
    <id>http://example.com/2020/04/01/%E3%80%90JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA%E3%80%91LV5-2%EF%BC%9A%E5%B9%B6%E5%8F%91&amp;%E5%B9%B6%E8%A1%8C/</id>
    <published>2020-04-01T11:15:00.000Z</published>
    <updated>2023-12-06T10:11:50.218Z</updated>
    
    <content type="html"><![CDATA[<p>两张图来理解<code>并发</code>和<code>并行</code>：</p><span id="more"></span><p><img src="http://myblog.sharemer.com/2020/04/01/20200401-1-1.png?imageView2/0/w/800" alt="图1"></p><p>如果只有一个CPU，通过CPU调度切换线程上下文，我们认为，在任意一个时刻，各个线程有且只能运行一个，这个叫并发。</p><p>相反的，如果有两个或者更多的CPU，那么就会是下面这样：</p><p><img src="http://myblog.sharemer.com/2020/04/01/20200401-1-2.png?imageView2/0/w/800" alt="图2"></p><p>两个CPU一起调度的时候，总会出现一些”同时被调度运行“的线程，比如上图的<code>红色⭐️标记</code>的部分，它们确实在同一时刻都被调度到并且开始运行了，我们称这种因多CPU调度而产生的线程运行时间<code>重叠</code>的现象叫并行。</p><p>并行必须要有多个CPU，能并行的一定能并发，如果你只有一个CPU，那么你只能是并发了，不可能并行。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;两张图来理解&lt;code&gt;并发&lt;/code&gt;和&lt;code&gt;并行&lt;/code&gt;：&lt;/p&gt;</summary>
    
    
    
    <category term="JAVA进化论" scheme="http://example.com/categories/JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA/"/>
    
    
    <category term="JAVA进化论" scheme="http://example.com/tags/JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA/"/>
    
  </entry>
  
</feed>
