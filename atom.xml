<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>胖虎de文库</title>
  
  <subtitle>– – – – – _ _ – _ _ –</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-12-06T10:58:53.202Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>胖虎</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL知识整合（一）：InnoDB存储引擎</title>
    <link href="http://example.com/2021/07/03/MySQL%E7%9F%A5%E8%AF%86%E6%95%B4%E5%90%88%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AInnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <id>http://example.com/2021/07/03/MySQL%E7%9F%A5%E8%AF%86%E6%95%B4%E5%90%88%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AInnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</id>
    <published>2021-07-03T01:41:00.000Z</published>
    <updated>2023-12-06T10:58:53.202Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、服务端的请求处理"><a href="#一、服务端的请求处理" class="headerlink" title="一、服务端的请求处理"></a>一、服务端的请求处理</h2><p>当一条sql由MySQL客户端发往MySQL服务端时，它所经历的流程如下：</p><span id="more"></span><p><img src="http://myblog.sharemer.com/2021/07/03/20210703-1-1.png?imageView2/0/w/650" alt="图1"></p><p>最终数据的读取和写入是由存储引擎负责的，下面来看下MySQL默认的存储引擎InnoDB的存储结构。</p><h2 id="二、InnoDB存储结构"><a href="#二、InnoDB存储结构" class="headerlink" title="二、InnoDB存储结构"></a>二、InnoDB存储结构</h2><h3 id="2-1：页"><a href="#2-1：页" class="headerlink" title="2.1：页"></a>2.1：页</h3><p>InnoDB的存储单元是<code>页</code>，一页的大小一般是<code>16KB</code>，可以通过系统变量<code>innodb_page_size</code>控制，它的默认值是16384（字节），也就是16KB。我们获取数据时，InnoDB也是以页为单位进行传输的，页的详细介绍放到了下面第三节。</p><h3 id="2-2：行-行结构"><a href="#2-2：行-行结构" class="headerlink" title="2.2：行&amp;行结构"></a>2.2：行&amp;行结构</h3><p>平时我们向表中插入一行数据，这一行数据是需要存放在磁盘上的，常见的存储格式有<code>COMPACT</code>、<code>REDUNDANT</code>、<code>DYNAMIC</code>、<code>COMPRESSED</code>，下面是设置语句：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CREATE</span> TABLE <span class="variable">$&#123;表名&#125;</span> <span class="variable">$&#123;列名&#125;</span> ROW_FORMAT = <span class="variable">$&#123;行格式名称&#125;</span></span><br><span class="line"><span class="attribute">ALTER</span> TABLE <span class="variable">$&#123;表名&#125;</span> ROW_FORMAT = <span class="variable">$&#123;行格式名称&#125;</span></span><br></pre></td></tr></table></figure><p>这些格式在原理上大体相同，下面主要以<code>COMPACT</code>为切入点进行介绍。COMPACT行格式如下：</p><p><img src="http://myblog.sharemer.com/2021/07/03/20210703-1-2.png?imageView2/0/w/1050" alt="图2"></p><h3 id="2-3：存储-数据溢出"><a href="#2-3：存储-数据溢出" class="headerlink" title="2.3：存储&amp;数据溢出"></a>2.3：存储&amp;数据溢出</h3><p>页是以16kb为单位存储的，但我们的数据又是以行为单位插入的（行记录），页容量固定，但行记录的大小不可控，因此就导致了各种数据溢出问题。</p><h4 id="2-3-1：列溢出"><a href="#2-3-1：列溢出" class="headerlink" title="2.3.1：列溢出"></a>2.3.1：列溢出</h4><p>首先是单列溢出，如果有的列数据特别大，大到一页都放不下，那这一列就溢出了，COMPACT的做法是当前页只记录该列的少量数据，剩余的数据则分散的存到其他页中，然后在当前页花20字节记录下这些页的地址：</p><p><img src="http://myblog.sharemer.com/2021/07/03/20210703-1-3.png?imageView2/0/w/680" alt="图3"></p><p>这里再说下<code>DYNAMIC</code>和<code>COMPRESSED</code>这两种行格式，它们跟COMPACT基本一致，只是在处理列溢出时的策略不太一样，DYNAMIC和COMPRESSED遇到超大列时并不会在当前页保存该列的少量数据，而是直接将真实数据分配到其他页中，当前页只记录其他页的地址，相比DYNAMIC，COMPRESSED还会压缩页数据，用来节省空间。</p><h4 id="2-3-2：页溢出"><a href="#2-3-2：页溢出" class="headerlink" title="2.3.2：页溢出"></a>2.3.2：页溢出</h4><p>再来看下页溢出，如何判定页是否溢出了呢？</p><p>页溢出临界判定：mysql规定正常情况下一页至少存储两行记录，假如我们行记录所需的真实数据存储上限为N，那么一页的数据构成就会是下面这样：</p><p><img src="http://myblog.sharemer.com/2021/07/03/20210703-1-4.png?imageView2/0/w/950" alt="图4"></p><p>只有行记录所需空间满足上面这个式子（N &lt; 8099)，页才不会溢出，否则就会溢出，而对于溢出页，就不会再要求至少存储两行记录了，因而可以进一步做数据拆分来解决掉页溢出问题。</p><h2 id="三、InnoDB页结构"><a href="#三、InnoDB页结构" class="headerlink" title="三、InnoDB页结构"></a>三、InnoDB页结构</h2><h3 id="3-1：基本结构"><a href="#3-1：基本结构" class="headerlink" title="3.1：基本结构"></a>3.1：基本结构</h3><p>前面已经简单介绍了页、行、以及行的结构，本节就来重点讲下页的结构（为了便于理解，这里将<code>图4</code>顺延了下来）：</p><p><img src="http://myblog.sharemer.com/2021/07/03/20210703-1-5.png?imageView2/0/w/950" alt="图5"></p><p>接下来详细的介绍下上图中的每一个部分。</p><h3 id="3-2：记录-Free-Space、User-Records、Infimum-Supremum"><a href="#3-2：记录-Free-Space、User-Records、Infimum-Supremum" class="headerlink" title="3.2：记录-Free Space、User Records、Infimum+Supremum"></a>3.2：记录-Free Space、User Records、Infimum+Supremum</h3><p>如图5，页由7部分数据组成，其中<code>User Records</code>是由<code>Free Space</code>转化而来，每当我们往页里插入一条记录，就会从Free Space申请一块内存作为User Records存放这条记录，Free Space用完，就可以申请新的页了：</p><p><img src="http://myblog.sharemer.com/2021/07/03/20210703-1-6.png?imageView2/0/w/850" alt="图6"></p><p>来个例子，page_demo表有三个属性，分别是c1(主键)、c2(int)、c3(varchar)，以COMPACT格式存储，这时王这张表里新增四条记录：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">INSERT</span> INTO page_demo VALUES(<span class="number">1</span>, <span class="number">100</span>, &#x27;aaa&#x27;), (<span class="number">2</span>, <span class="number">200</span>, &#x27;bbbb&#x27;), (<span class="number">3</span>, <span class="number">300</span>, &#x27;cccc&#x27;), (<span class="number">4</span>, <span class="number">400</span>, &#x27;dddd&#x27;);</span><br></pre></td></tr></table></figure><p>此时数据页的存储状态如下：</p><p><img src="http://myblog.sharemer.com/2021/07/03/20210703-1-7.png?imageView2/0/w/1050" alt="图7"></p><p>如果删除掉一条数据，那么这条数据的delete_flag会被标记为1，仅此而已，当插入新的数据时，会挤掉这条被删掉的老数据。</p><h3 id="3-2：页目录-Page-Directoy"><a href="#3-2：页目录-Page-Directoy" class="headerlink" title="3.2：页目录-Page Directoy"></a>3.2：页目录-Page Directoy</h3><p>当一张表中的记录值非常多时，要按照主键进行查询，为了保证查询效率，InnoDB又将上面的数据进行了分组，然后利用<code>Page Directory</code>保存了这些分组最后一条数据的地址偏移量，并以此来定位一个分组，详情如下：</p><p><img src="http://myblog.sharemer.com/2021/07/03/20210703-1-8.png?imageView2/0/w/1050" alt="图8"></p><p>有了这些，根据主键查询的效率就得到了提升，具体过程：通过<code>二分法</code>找到该分组对应的槽信息，然后通过邻槽的最后一条记录找到该槽对应组里主键值最小的记录，以这条记录开始，通过next_record一直往下遍历（单链表遍历），匹配要查的主键。二分查找法的时间复杂度为<code>O(logN)</code></p><h3 id="3-3：页头-Page-Header"><a href="#3-3：页头-Page-Header" class="headerlink" title="3.3：页头-Page Header"></a>3.3：页头-Page Header</h3><p>页头主要用来存储页的一些状态信息，这些信息如下：</p><table><thead><tr><th align="left">名称</th><th align="left">大小</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">PAGE_N_DIR_SLOTS</td><td align="left">2bytes</td><td align="left">页目录内的槽数量</td></tr><tr><td align="left">PAGE_HEAP_TOP</td><td align="left">2bytes</td><td align="left">还未使用的空间最小地址，该地址后就是Free Space</td></tr><tr><td align="left">PAGE_N_HEAP</td><td align="left">2bytes</td><td align="left">首bit标记本页是否为紧凑型，剩余15bit表示本页的总记录数（包含Infimum+Supremum、被删除数据）</td></tr><tr><td align="left">PAGE_N_RECS</td><td align="left">2bytes</td><td align="left">本页用户记录的数量（不包含Infimum+Supremum、被删除数据）</td></tr><tr><td align="left">PAGE_FREE</td><td align="left">2bytes</td><td align="left">被删记录同样会通过next_record组成一个“废弃链表”，这些记录空间可被重复利用，PAGE_FREE就是链表头对应记录在页中的偏移量</td></tr><tr><td align="left">PAGE_GARBAGE</td><td align="left">2bytes</td><td align="left">已删除记录所占字节数</td></tr><tr><td align="left">PAGE_LAST_INSERT</td><td align="left">2bytes</td><td align="left">最后插入记录的位置</td></tr><tr><td align="left">PAGE_DIRECTION</td><td align="left">2bytes</td><td align="left">记录插入的方向（新插入记录的主键值比上一条记录大，此时插入方向视为右插，否则是左插，即左小右大，PAGE_DIRECTION就用来记录最后插入数据的插入方向）</td></tr><tr><td align="left">PAGE_N_DIRECTION</td><td align="left">2bytes</td><td align="left">同一个方向连续多次插入记录时，会用该字段计数，如果后续插入方向发生变化，便会清零重计</td></tr><tr><td align="left">PAGE_MAX_TRX_ID</td><td align="left">8bytes</td><td align="left">修改本页的最大事务id，该值仅在二级索引页面中定义</td></tr><tr><td align="left">PAGE_LEVEL</td><td align="left">2bytes</td><td align="left">本页在B+树中所处的层级</td></tr><tr><td align="left">PAGE_INDEX_ID</td><td align="left">8bytes</td><td align="left">索引ID，表示本页属于哪个索引</td></tr><tr><td align="left">PAGE_BTR_SEG_LEAF</td><td align="left">10bytes</td><td align="left">B+树叶子节点段的头部信息，仅在B+树的跟页面中定义</td></tr><tr><td align="left">PAGE_BTR_SEG_TOP</td><td align="left">10bytes</td><td align="left">B+树非叶子节点段的头部信息，仅在B+树的跟页面中定义</td></tr></tbody></table><center>表1</center><h3 id="3-4：文件头-File-Header"><a href="#3-4：文件头-File-Header" class="headerlink" title="3.4：文件头-File Header"></a>3.4：文件头-File Header</h3><p>如果说Page Header是用来描述页内记录的状态，那么File Header则用来记录页本身的信息，这些信息如下：</p><table><thead><tr><th align="left">名称</th><th align="left">大小</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">FIL_PAGE_SPACE_OR_CHKSUM</td><td align="left">4bytes</td><td align="left">mysql版本 &lt; 4.0.14：表示本页所在的表空间ID；mysql版本 &gt;&#x3D; 4.0.14：表示本页的校验和</td></tr><tr><td align="left">FIL_PAGE_OFFSET</td><td align="left">4bytes</td><td align="left">页号（即页ID，InnoDB通过页号来确定一个页）；当要存放的数据本身很大，以至于出现了前面所说的溢出现象，这时就需要多个页存放这些数据了，聚合这些数据最简单的办法就是通过页号将它们串连成一个<code>双向链表</code>，下方的两个属性就是用来干这个的</td></tr><tr><td align="left">FIL_PAGE_PREV</td><td align="left">4bytes</td><td align="left">上一页的页号</td></tr><tr><td align="left">FIL_PAGE_NEXT</td><td align="left">4bytes</td><td align="left">下一页的页号</td></tr><tr><td align="left">FIL_PAGE_LSN</td><td align="left">8bytes</td><td align="left">本页被最后修改时对应的LSN值（日志序列号）</td></tr><tr><td align="left">FIL_PAGE_TYPE</td><td align="left">2bytes</td><td align="left">本页的类型，InnoDB为了不同的目的将页分成了好几种，具体的类型以及类型值详见<code>表3</code></td></tr><tr><td align="left">FIL_PAGE_FILE_FLUSH_LSN</td><td align="left">8bytes</td><td align="left">仅在系统表空间的第一个页中定义，代表文件至少被刷新到了对应的LSN值</td></tr><tr><td align="left">FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td><td align="left">4bytes</td><td align="left">本页所在的表空间ID</td></tr></tbody></table><center>表2</center><table><thead><tr><th align="left">页类型</th><th align="left">类型值</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">FIL_PAGE_TYPE_ALLOCATED</td><td align="left">0x0000</td><td align="left">新分配，还未使用</td></tr><tr><td align="left">FIL_PAGE_UNDO_LOG</td><td align="left">0x0002</td><td align="left">undo日志页</td></tr><tr><td align="left">FIL_PAGE_INODE</td><td align="left">0x0003</td><td align="left">存储段的信息</td></tr><tr><td align="left">FIL_PAGE_IBUF_FREE_LIST</td><td align="left">0x0004</td><td align="left">Change Buffer空闲链表</td></tr><tr><td align="left">FIL_PAGE_IBUF_BITMAP</td><td align="left">0x0005</td><td align="left">Change Buffer的一些属性</td></tr><tr><td align="left">FIL_PAGE_TYPE_SYS</td><td align="left">0x0006</td><td align="left">存储一些系统数据</td></tr><tr><td align="left">FIL_PAGE_TYPE_TRX_SYS</td><td align="left">0x0007</td><td align="left">事务系统数据</td></tr><tr><td align="left">FIL_PAGE_TYPE_FSP_HDR</td><td align="left">0x0008</td><td align="left">表空间头部信息</td></tr><tr><td align="left">FIL_PAGE_TYPE_XDES</td><td align="left">0x0009</td><td align="left">存储区的一些属性</td></tr><tr><td align="left">FIL_PAGE_TYPE_BLOB</td><td align="left">0x000A</td><td align="left">溢出页</td></tr><tr><td align="left">FIL_PAGE_INDEX</td><td align="left">0x45BF</td><td align="left">索引页（也就是存放我们业务数据的页，之前例子中的页就是这种）</td></tr></tbody></table><center>表3</center><h3 id="3-5：文件尾-File-Trailer"><a href="#3-5：文件尾-File-Trailer" class="headerlink" title="3.5：文件尾-File Trailer"></a>3.5：文件尾-File Trailer</h3><p>InnoDB存储引擎会把数据存放在磁盘上，但磁盘速度很慢，所以InnoDB会以页为单位将数据载入到内存中处理，处理后的数据会再刷入磁盘中，如果在刷入磁盘的过程中发生意外（比如断电、死机），势必会导致严重的后果，为了避免这种情况的发生，InnoDB追加了File Trailer，结合File Header一起来校验页的完整性，它由8字节组成，分为两个部分：</p><p><img src="http://myblog.sharemer.com/2021/07/03/20210703-1-9.png?imageView2/0/w/560" alt="图9"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、服务端的请求处理&quot;&gt;&lt;a href=&quot;#一、服务端的请求处理&quot; class=&quot;headerlink&quot; title=&quot;一、服务端的请求处理&quot;&gt;&lt;/a&gt;一、服务端的请求处理&lt;/h2&gt;&lt;p&gt;当一条sql由MySQL客户端发往MySQL服务端时，它所经历的流程如下：&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="mysql" scheme="http://example.com/tags/mysql/"/>
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Redis知识整合（四）：集群</title>
    <link href="http://example.com/2021/05/26/Redis%E7%9F%A5%E8%AF%86%E6%95%B4%E5%90%88%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E9%9B%86%E7%BE%A4/"/>
    <id>http://example.com/2021/05/26/Redis%E7%9F%A5%E8%AF%86%E6%95%B4%E5%90%88%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E9%9B%86%E7%BE%A4/</id>
    <published>2021-05-26T00:20:00.000Z</published>
    <updated>2023-12-03T10:42:00.293Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上回主要介绍了redis的主从模式，主从模式最主要的作用是提高redis的可用性，假如主节点挂了，从节点可以在<code>哨兵机制</code>的协助下晋升为主节点继续对外服务，但主从终归是多个redis节点都保存同一份数据，在redis数据快速膨胀时，又该如何应对呢？redis对于这种情况提供了Cluster模式，这是redis的分布式解决方案，使得大批量数据可以拆分成小部分保存进多个redis节点中，本篇笔记将展开说一下<code>Redis Cluster</code>.</p></blockquote><span id="more"></span><h3 id="一、分布式DB常用的分区方案"><a href="#一、分布式DB常用的分区方案" class="headerlink" title="一、分布式DB常用的分区方案"></a>一、分布式DB常用的分区方案</h3><p>分布式数据库在存储全量数据时，首先要解决的是如何把整个数据集按照分区规则映射到多个节点上：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-1.png?imageView2/0/w/560" alt="图1"></p><p>这里介绍几个常用分分区方案：</p><h4 id="1-1：取模"><a href="#1-1：取模" class="headerlink" title="1.1：取模"></a>1.1：取模</h4><p>这是最常用的方式，假如现在有N个存储节点，则计算方式为：p &#x3D; hash(key) % N，也就是取唯一标识（在本例中就是redis key）进行哈希计算后跟当前节点数取模，最终就可以得出这条数据会被分配到哪台机器上，这是这种方式的优缺点：</p><ul><li>优点：简单易用</li><li>缺点：扩缩容时可能导致全部节点失效（<code>rehash</code>），建议扩缩容时按照<code>原节点数 × 2</code>来进行，这样只要原来的哈希值不变，余数也就不会变</li></ul><h4 id="1-2：一致性哈希"><a href="#1-2：一致性哈希" class="headerlink" title="1.2：一致性哈希"></a>1.2：一致性哈希</h4><p>这种方式的实现思路是为每个节点分配一个token值，取值范围在0~2^32间，当给节点分配完token，这些节点就会形成一个闭环：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-2.png?imageView2/0/w/600" alt="图2"></p><p>当有新的数据到来时，跟前面一样先计算出唯一标识（key）的哈希值，然后拿着这个哈希值顺时针找到第一个大于等于该值的token（找不到比自身大的token就放进顺时针第一个节点中，所以才说这是个闭合的环嘛），将其存入该token对应的节点中：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-3.png?imageView2/0/w/650" alt="图3"></p><p>这样一来，增减节点时只会影响哈希环中相邻的节点，对其他节点无影响：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-5.png?imageView2/0/w/1100" alt="图4"></p><p>至于加减节点导致的一小部分数据不可用，需要手动处理，如果利用一致性哈希存缓存数据，那么也可以忽略这部分数据，等回源时再次写入正确的节点即可。</p><p>如果节点过少，则节点变化将大范围影响哈希环中的数据映射，而且数据会严重倾斜，所以一致性哈希不适合节点数较少时使用。</p><p>在使用一致性哈希时，节点扩缩容容易导致负载不均衡（如图4），尤其是删除一个节点时，被删节点的负载将全部打到下一个节点，如果下一个节点不堪重负挂掉，此时更大的压力将会顺延至下下一个节点，以此类推，最终可能导致服务全员故障，为了解决一致性哈希的这些问题，诞生了<code>虚拟节点</code>的概念，这是对一致性哈希算法的优化，算法的本质没有变化，但与之前不同的是现在数据不与实际的节点交互而是跟抽象出来的虚拟节点交互：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-7.png?imageView2/0/w/600" alt="图5"></p><p>图中简化了，实际上虚拟节点是逻辑层面的节点，数量会非常多。</p><p>加这一层虚拟节点做一致性哈希的代理层，然后再将虚拟节点映射到具体的机器上，只要这个映射逻辑足够散列，那么之前的问题将不复存在，比如现在我们去掉一个节点：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-9.png?imageView2/0/w/600" alt="图6"></p><p>可以看到，受被删节点影响的数据最终会被节点2和节点3的虚拟节点接收，这就是虚拟节点比原生一致性哈希优秀的地方，通过一层抽象，解决了一致性哈希的痛点。</p><h4 id="1-3：哈希槽"><a href="#1-3：哈希槽" class="headerlink" title="1.3：哈希槽"></a>1.3：哈希槽</h4><p>它结合了上述两种哈希算法的特点实现，首先它会抽象出来一大堆的哈希槽，这些哈希槽都有自己编号，每个物理节点负责存储一定范围内的哈希槽，存储数据时跟前两种哈希算法一样，先计算出唯一标识（key）的哈希值，然后看该值在哪个槽区间里，若命中区间，则存进负责该槽区间的节点：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-10.png?imageView2/0/w/600" alt="图7"></p><p>增减节点时需要重新分配每个节点负责的槽范围，将一些错位数据做迁移，这样可以保证每个节点仍然是均匀的负责一个哈希槽区间，也就自然不存在数据倾斜等问题，Redis Cluster正是采用哈希槽的方式实现数据分区的，它一共有16383个槽位，流程跟<code>图7</code>中描绘的一样，分区算法为：<code>CRC16(key) % 16383</code></p><h3 id="二、Redis集群搭建"><a href="#二、Redis集群搭建" class="headerlink" title="二、Redis集群搭建"></a>二、Redis集群搭建</h3><h4 id="2-1：集群配置-启动"><a href="#2-1：集群配置-启动" class="headerlink" title="2.1：集群配置&amp;启动"></a>2.1：集群配置&amp;启动</h4><p>redis集群一般需要至少6个节点（3主3从）才能保证组成完整的高可用集群，单节点的redis-6379.conf主要配置如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">port 6379 #端口号</span><br><span class="line">cluster-enabled yes #开启集群模式</span><br><span class="line">cluster-node-timeout 15000 #节点超时时间（单位：ms）</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">↓集群配置文件，若没有则自动创建，当集群内节点信息发生变化（如添加/下线节点、故障转移等），节点</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">会自动保存集群状态到该配置文件中（redis自动维护该文件，不需要手动修改）</span></span><br><span class="line">cluster-config-file &quot;node-6379.conf&quot;</span><br></pre></td></tr></table></figure><p>配置完成后将所有节点都启动起来，假设有这样6个节点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-server conf/redis-6379.conf</span><br><span class="line">redis-server conf/redis-6380.conf</span><br><span class="line">redis-server conf/redis-6381.conf</span><br><span class="line">redis-server conf/redis-6382.conf</span><br><span class="line">redis-server conf/redis-6383.conf</span><br><span class="line">redis-server conf/redis-6384.conf</span><br></pre></td></tr></table></figure><p>启动完成后，来随便看一个节点的集群配置文件，比如node-6379.conf：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5adabec665d2b4005adabec665d2b40adabec665 127.0.0.1:6379 myself,master - 0 0 0 connected vars currentEpoch 0 lastVoteEpoch 0</span><br></pre></td></tr></table></figure><p>这里面记录的是集群的初始状态，其中第一个40位的十六进制字符串表示的是节点ID，它是节点在集群中的唯一标识，很多集群操作都需要借助这个ID来完成（ID在初始化集群时生成，节点重启会重用）</p><h4 id="2-2：握手"><a href="#2-2：握手" class="headerlink" title="2.2：握手"></a>2.2：握手</h4><p>到上面的步骤为止，节点只是打开了集群模式，完成了启动，它们彼此并不知道彼此的节点信息，接下来这一步操作就可以让它们感知到身处同一个集群里的彼此，这个操作由客户端发起：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster meet $&#123;ip&#125; $&#123;port&#125;</span><br></pre></td></tr></table></figure><p>发送meet就可以让节点间进行握手通信，就像下面这样：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-11.png?imageView2/0/w/700" alt="图8"></p><p>当某个节点对着其他节点全部发一次meet消息后，集群中每个节点就会慢慢感知到其他的节点，最终在每一个节点内执行下面这个命令，都可以获取到所有的节点信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; cluster nodes</span><br><span class="line">5adabec665d2b4005adabec665d2b40adabec665 127.0.0.1:6379 myself,master - 0 0 0 connected</span><br><span class="line">8ebabevc789d2b6125becbec123d2f45adabecec 127.0.0.1:6380 master - 0 146345454 1 connected</span><br><span class="line">fdadadacddd2b4666adabec125d2aaaadabecdec 127.0.0.1:6381 master - 0 146345454 2 connected</span><br><span class="line">dddddddcddd5bbbbbadabec567d2bb0adabecfed 127.0.0.1:6382 master - 0 146345454 3 connected</span><br><span class="line">fadabec567d6bddddadabec690d2b40adabecede 127.0.0.1:6383 master - 0 146345454 4 connected</span><br><span class="line">dadacecef8d1b4a85adabece76d2b40adabecded 127.0.0.1:6384 master - 0 146345454 5 connected</span><br></pre></td></tr></table></figure><p>至于meet的过程，我们放到后面详细说。</p><p>节点建立握手后，集群还无法工作，整体处于下线状态，所有数据的读写都会被禁止，这是因为还没给主节点分配槽位，没有槽位连插入的数据放到哪个节点都不知道。</p><h4 id="2-3：分配哈希槽"><a href="#2-3：分配哈希槽" class="headerlink" title="2.3：分配哈希槽"></a>2.3：分配哈希槽</h4><p>redis是通过哈希槽进行数据分区的，这在之前已经提过了，分配槽位用到的指令是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster addslots &#123;x...y&#125; #xy就是当前节点负责的槽范围</span><br></pre></td></tr></table></figure><p>我们设6379&#x2F;6380&#x2F;6381三个节点为主节点，将16384个槽均匀分配给这三个节点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379 cluster addslots &#123;0...5461&#125;</span><br><span class="line">redis-cli -h 127.0.0.1 -p 6380 cluster addslots &#123;5462...10922&#125;</span><br><span class="line">redis-cli -h 127.0.0.1 -p 6381 cluster addslots &#123;19023...16383&#125;</span><br></pre></td></tr></table></figure><p>在每个分配好槽位的主节点执行<code>cluster info</code>可以查看具体的集群状态信息，使用<code>cluster nodes</code>则可以查看整个集群的情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; cluster nodes</span><br><span class="line">5adabec665d2b4005adabec665d2b40adabec665 127.0.0.1:6379 myself,master - 0 0 0 connected 0-5461</span><br><span class="line">8ebabevc789d2b6125becbec123d2f45adabecec 127.0.0.1:6380 master - 0 146345454 1 connected 5462-10922</span><br><span class="line">fdadadacddd2b4666adabec125d2aaaadabecdec 127.0.0.1:6381 master - 0 146345454 2 connected 10923-16383</span><br><span class="line">dddddddcddd5bbbbbadabec567d2bb0adabecfed 127.0.0.1:6382 master - 0 146345454 3 connected</span><br><span class="line">fadabec567d6bddddadabec690d2b40adabecede 127.0.0.1:6383 master - 0 146345454 4 connected</span><br><span class="line">dadacecef8d1b4a85adabece76d2b40adabecded 127.0.0.1:6384 master - 0 146345454 5 connected</span><br></pre></td></tr></table></figure><p>相比之前，三个主节点已经输出了自己负责的槽位信息。</p><h4 id="2-4：配置主从"><a href="#2-4：配置主从" class="headerlink" title="2.4：配置主从"></a>2.4：配置主从</h4><p>上述集群中还有3个节点没有利用到，这3个节点就是我们要设置的从节点，在集群模式下建立主从关系有些不太一样，用的是这个指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster replicate $&#123;master-node-id&#125;</span><br></pre></td></tr></table></figure><p>在集群中，从节点负责复制主节点的槽信息和数据。虽然指令不同，但复制的流程则和原来讲的普通主从模式一致，最终我们这个集群的完整拓补图将会是下面这样：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-12.png?imageView2/0/w/600" alt="图9"></p><p>此时如果再执行<code>cluster nodes</code>命令，主从信息也会被打印出来（这里不再演示）。</p><h4 id="2-5：redis-trib-rb"><a href="#2-5：redis-trib-rb" class="headerlink" title="2.5：redis-trib.rb"></a>2.5：redis-trib.rb</h4><p>如果你觉得上面的流程太过复杂，没关系，redis提供了官方的快速搭建集群的工具：redis-trib.rb，它采用ruby实现，可以帮我们简化集群创建、检查、迁移槽、均衡等常见运维操作。</p><p>使用前需要先装ruby：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wget https://cache.ruby-lang.org/pub/ruby/$&#123;big_ver&#125;/ruby-$&#123;ver&#125;.tar.gz #下载压缩包，big_ver为大版本号，如2.3，ver为具体版本号，如2.3.1</span><br><span class="line">tar xvf ruby-yy.tar.gz #解压</span><br><span class="line">./configure -prefix=/usr/local/ruby</span><br><span class="line">make #编译</span><br><span class="line">make install</span><br><span class="line">cd /usr/local/ruby</span><br><span class="line">sudo cp bin/ruby /usr/local/bin</span><br><span class="line">sudo cp bin/gem /usr/local/bin</span><br></pre></td></tr></table></figure><p>安装rubygem redis依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http://rubygems.org/downloads/redis-$&#123;ver&#125;.gem #下载redis.gem，ver是具体的版本号，如3.3.0</span><br><span class="line">gem install -l redis-$&#123;ver&#125;.gem</span><br><span class="line">gem list --check redis gem</span><br></pre></td></tr></table></figure><p>安装redis-trib.rb：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /$&#123;redis_home&#125;/src/redis-trib.rb /usr/local/bin</span><br></pre></td></tr></table></figure><p>安装完ruby环境后，执行redis-trib.rb命令确认环境是否正确即可，若准确则打印相关信息。</p><p>然后开始创建集群：</p><p>①首先准备好6个开启集群模式节点，过程跟之前一样，不再赘述。</p><p>②执行redis-trib.rb创建集群：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-trib.rb create --replicas 1 127.0.0.1:6379 127.0.0.1:6380 127.0.0.1:6381 127.0.0.1:6382 127.0.0.1:6383 127.0.0.1:6384</span><br></pre></td></tr></table></figure><p><code>--replicas</code>可以指定每个主节点配置几个从节点，这里设置的是1，如果是多台机器部署，redis-trib.rb会尽可能保证主从不在同一个机器里（不然会弱化高可用）</p><p>上面的指令执行后，会将当前的主从分配信息打印出来，然后征求你的同意，你只要输入了<code>yes</code>，redis-trib.rb就会紧接着进行节点握手和槽分配；相比原生搭建集群，redis-trib.rb的确可以帮我们省去很多麻烦。</p><h3 id="三、节点通信"><a href="#三、节点通信" class="headerlink" title="三、节点通信"></a>三、节点通信</h3><h4 id="3-1：Gossip"><a href="#3-1：Gossip" class="headerlink" title="3.1：Gossip"></a>3.1：Gossip</h4><p>如<code>图8</code>所示，为什么某个节点对着其他节点全部发一次meet消息后，每个节点就会慢慢感知到其他的节点呢？这是因为redis利用<code>Gossip</code>协议（一种分布式一致性协议，为最终一致）做信息同步，Gossip的工作原理就是节点间彼此不断的通信进行信息交换，这样持续一段时间后，所有的节点就都知道了集群的完整信息（这种方式很像流言的传播，所以Gossip协议也叫流言协议），过程如下：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-13-fix2.png?imageView2/0/w/1400" alt="图10"></p><p>注意图中的流程是按照6379的meet消息同时发到各节点，各节点又同时发pong给6379的，但实际操作中这肯定不是同时发生的，但这并不影响节点的传播。</p><p>上面所涉及到的<code>meet</code>、<code>ping</code>、<code>pong</code>消息均为Redis Gossip消息，除了这些还有<code>fail</code>消息，当任意节点发现某一个节点挂掉后，会向集群内广播一个fail消息，其他节点接收到这条fail消息后会把对应的坏节点更新为下线状态（后面会详细介绍<code>故障转移</code>）。</p><h4 id="3-2：定时消息"><a href="#3-2：定时消息" class="headerlink" title="3.2：定时消息"></a>3.2：定时消息</h4><p>上面的流程图告诉我们集群内的每个节点都会定时对其他节点通信进行信息交换，频率是10次&#x2F;秒，高频是为了让信息扩散的更快，可是这样就会导致另一个问题：每次请求都携带很多信息（比如自身和其他节点的状态信息等），这样势必会造成网络带宽的浪费；为了解决这一问题，节点间每次只选取部分节点进行通信，选取逻辑主要源自两部分，这里以6379这个节点（定时发ping消息）为例：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-14.png?imageView2/0/w/850" alt="图11"></p><p>根据这两个选取规则可以估算出每个节点每秒需要发送的消息数为：<code>1 + 10 * num(node.pong_last_time &gt; cluster_node_timeout/2)</code>，其中<code>cluster_node_timeout</code>可配，默认15s，当我们的带宽资源紧张时可以适当调大该值来降低贷款占用率，当然扩大该值意味着故障转移、槽信息更新、新节点发现等信息的同步速度降低，所以调整该值大小需要仔细斟酌，有得必有失。</p><p>除了削减每次发送的消息数量，还缩小了每次发送的数据包，每条Gossip消息都由消息头和消息体组成，其中消息头中的myslots字段（自己负责的槽信息，约占2kb），而主要的削减对象是消息体，消息体中主要携带其他节点的信息，用于信息交换，但每次都全量携带所有节点的信息显然太浪费，所以Redis进行了削减，每次只携带<code>cluster.nodes.size/10</code>个其他节点的信息。</p><h4 id="3-3：扩容"><a href="#3-3：扩容" class="headerlink" title="3.3：扩容"></a>3.3：扩容</h4><p>前面我们就讲过集群中的每条数据都会通过哈希计算被映射进一个槽位，而每个槽位又按照编号均匀分布在集群的每个节点中，所以扩缩容说白了就是槽和数据在各个节点间移动。现在我们假设给集群加入了两个节点，它们融入进cluster的流程如下：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-15.png?imageView2/0/w/1100" alt="图10"></p><p>截至目前，新节点依旧没有对外服务，因为还没分配槽，只要两个节点有一个不是从节点（假设6385非从），那么slots一定会重新分配，就像这样（其他主节点匀给新节点一部分slots）：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-16.png?imageView2/0/w/380" alt="图11"></p><p>迁移过程较复杂，我们以一个槽位的迁移为切入点进行详细介绍，假设现在要将6381的某个槽对应的数据迁移到6385，过程如下：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-17.png?imageView2/0/w/650" alt="图12"></p><p>这个过程很复杂，如果全部通过手动来做那肯定不合适，所以redis-trib.rb为我们提供了槽重新分片的功能：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-trib.rb reshard $&#123;host:port&#125; --from $&#123;source-node-id&#125; --to $&#123;target-node-id&#125; --slots $&#123;need-migrate-slots-total&#125; --yes --timeout $&#123;pre-migrate-timeout&#125; --pipline $&#123;per-migrate-key-total&#125;</span><br></pre></td></tr></table></figure><p>入参释义：</p><ol><li>host:port：必传，是集群中任意节点的地址，用来获取整个集群的信息</li><li>source-node-id：源节点id，可用逗号传多个</li><li>target-node-id：目标节点id，只允许填写一个，例如图11中就可以认为source-node-id是6379&#x2F;6380&#x2F;6381三个节点，而目标节点就是6385</li><li>need-migrate-slots-total：需要迁移的槽的总数量，新增主节点可以根据16384&#x2F;nodes.size估算出来</li><li>pre-migrate-timeout：单次migrate超时时间，缺省值：60000ms</li><li>per-migrate-key-total：单次migrate迁移的键数量，缺省值：10</li></ol><blockquote><p>ps：因为reshard命令每次只允许指定一个<code>目标节点</code>，所以当扩容多个节点时需要一个个的进行迁移（此时被加进来的节点为<code>目标节点</code>），而缩容时如果需要缩多个节点，可以将这些下线节点同时指定为源节点，但迁移至其集群内其他节点时也需要一个个执行（此时其他节点为<code>目标节点</code>）。</p></blockquote><h4 id="3-4：缩容"><a href="#3-4：缩容" class="headerlink" title="3.4：缩容"></a>3.4：缩容</h4><p>理解了扩容，缩容就好理解了，如果要从集群下掉一个节点，流程如下：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-18.png?imageView2/0/w/500" alt="图13"></p><p><strong>1.迁移槽</strong></p><p>假如我们要将上面例子中的某个主节点下掉，这里槽迁移过程和扩容时是一样的，唯一的不同点是现在的目标节点有三个，而源节点只有一个，所以需要将源节点里的槽位列出来，算出来其负责的槽位数，然后用<code>槽位数/3</code>计算出其余三个节点均摊多少槽位，然后分三次reshard即可。</p><p><strong>2.忘记节点</strong></p><p>通过以下命令来完成：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">向集群内每个节点发送下面的命令，发送后对应节点就会把下线节点加入到禁用列表里，</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">处于禁用列表中的node不再参与Gossip通信，但该列表只有60s有效期，所以得在过</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">期前让集群内所有节点都收到cluster forget指令</span></span><br><span class="line">cluster forget $&#123;target-node-id&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果觉得上面的流程麻烦，还可以使用redis-trib对着任意集群节点发送以下指令</span></span><br><span class="line">redis-trib.rb del-node $&#123;host:port&#125; $&#123;target-node-id&#125;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">↑上面这个指令内部逻辑就是循环集群内其他节点挨个发cluster forget指令，除此</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">之外，它还会将下线节点的从节点（如果有的话）指向别的主节点（原则上是指定给从</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">节点最少的那个主节点）</span></span><br></pre></td></tr></table></figure><h4 id="3-5：故障转移"><a href="#3-5：故障转移" class="headerlink" title="3.5：故障转移"></a>3.5：故障转移</h4><p>通过前面几个小节，我们知道了redis集群如何做心跳检查和扩缩容，这一小节，我们就来聊聊故障的转移。</p><p>一个正常集群内的各个节点会定期发送ping&#x2F;pong消息，用来同步集群信息和做心跳检查（参考<code>图11</code>），那么自然也会通过这种方式发现故障节点，通过图11我们知道，一个节点与另一个节点间的ping消息正常情况下不会超出<code>cluster_node_timeout</code>，若超过，说明ping消息失败且重连失败，导致cluster_node_timeout一直得不到刷新，这时便可以判定对方为<code>主观下线（pfail）</code>，现在还不能给这个节点判死刑，因为单台机器认定的故障不具备权威性，这条主观下线信息最终会被传播出去，当超过半数的主节点均认为该节点下线时，此时这个节点才是真正意义上的下线，即<code>客观下线</code>，详细流程如下：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-25.png?imageView2/0/w/860" alt="图14"></p><p>故障节点变为<code>客观下线</code>后，如果被下线的节点持有槽，那么接下来就需要<code>故障恢复</code>，当它的从节点也收到客观下线的消息时，就开始选举一个能替换它对外服务的节点作为新的主节点，选举和恢复流程如下：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-27.png?imageView2/0/w/980" alt="图15"></p><p>故障转移时间跟所配的cluster-node-timeout息息相关（默认15s），配置时可以根据业务容忍度做出适当的调整。</p><h4 id="3-6：路由"><a href="#3-6：路由" class="headerlink" title="3.6：路由"></a>3.6：路由</h4><h5 id="3-6-1：重定向"><a href="#3-6-1：重定向" class="headerlink" title="3.6.1：重定向"></a>3.6.1：重定向</h5><p>槽分配都是在服务端完成的，且服务端每个节点都保存有一份当前的槽信息，那客户端要如何准确的访问整个集群呢？redis官方的做法是让客户端无脑发起直连，被连到的服务端做路由分析与转发，流程如下：</p><p>前两种方案都是建立在服务端节点无作为的情况下进行的，这样做有一个坏处，Gossip协议是最终一致的，那么槽信息的同步必定会存在延迟，这样在做槽迁移时会存在大量路由错误的key，而且第二种方案还加大了系统的复杂度，得不偿失。</p><p>第三种方案是服务端自身做路由转发，这也就意味着服务端节点本身具备判断槽分配的能力，即便是正在槽迁移，路由至错误节点，错误节点也能很好的更正路由（多次路由转发必定会找到正确的那个节点），而且这个方案并没有额外增加模块，没有增加维护成本，所以redis官方采用了这种方案，流程如下：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-19.png?imageView2/0/w/560" alt="图16"></p><p>客户端指令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6379</span><br><span class="line">127.0.0.1:6379&gt; set $&#123;key&#125; $&#123;value&#125;</span><br><span class="line">(error) MOVED $&#123;slot-num&#125; 127.0.0.1:6381 #表示当前key所属槽分布在6381上</span><br><span class="line"></span><br><span class="line">127.0.0.1:6381&gt; set $&#123;key&#125; $&#123;value&#125;</span><br><span class="line">OK #重新到6381上则顺利执行</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">你或许觉得上面的操作过于麻烦，没关系，还可以给redis-cli加-c自动路由（内部逻辑跟上面是一样的，只是redis-cli帮我们屏蔽掉了）</span></span><br><span class="line">redis-cli -p 6379 -c</span><br><span class="line">127.0.0.1:6379&gt; set $&#123;key&#125; $&#123;value&#125;</span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">Redirected to slot [<span class="variable">$&#123;slot-num&#125;</span>] located at 127.0.0.1:6381 <span class="comment">#即便在6379上执行，也可以自动路由</span></span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><blockquote><p>集群环境下，不能很好的支持<code>mget</code>等批量命令，因为多个key无法保证都落到同一个节点上，可以通过<code>&#123;&#125;</code>做路由控制，因为cluster做哈希计算时如果发现key里包含一对<code>&#123;&#125;</code>，则只让<code>&#123;&#125;</code>内的部分参与哈希计算，可以通过这个特点来让一些需要批量操作的key落入同一个节点内。</p></blockquote><p>集群中每个节点都保存一份完整的slot-node映射关系，其保存在<code>clusterState</code>结构中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line">    clusterNode *myself; <span class="comment">//自身节点</span></span><br><span class="line">    clusterNode *slots[CLUSTER_SLOTS]; <span class="comment">//16384个槽-节点映射数组，下标为槽</span></span><br><span class="line">    ...略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面客户端请求重定向的逻辑伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">execute_or_redirect</span><span class="params">(key)</span>:</span><br><span class="line"><span class="type">int</span> slot = key_hash_slot(key);</span><br><span class="line">ClusterNode node = slots[slot];</span><br><span class="line"><span class="keyword">if</span>(node == clusterState.myself):</span><br><span class="line"><span class="keyword">return</span> executeCommand(key);</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;(error) MOVED [slot-num] [ip]:[port]&#x27;</span>;</span><br></pre></td></tr></table></figure><p>通过上面的了解，我们知道了客户端与集群交互的基本流程，但这个流程存在一个问题，倘若大部分时候都请求不到准确的节点，那岂不是意味着客户端大部分访问都需要通信两次才能完成？这对IO来说是笔不菲的开销，有没有更聪明的办法来做路由呢？</p><h5 id="3-6-2：Smart-Client"><a href="#3-6-2：Smart-Client" class="headerlink" title="3.6.2：Smart Client"></a>3.6.2：Smart Client</h5><p>事实上现在大部分语言的客户端都解决了这个问题，比如<code>Jedis</code>，解决办法就是在本地直接缓存下来slot-node映射信息（初始化时访问任意节点发送<code>cluster slots</code>指令即可获得），等key来了可以直接在客户端做好路由发给正确的节点，当偶尔发生MOVE响应时就更新本地的映射信息。</p><p>拿<code>JedisCluster</code>来说，它的处理流程如下：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-20.png?imageView2/0/w/700" alt="图17"></p><p>上面在出问题的情况下（比如连接出错、重定向）会重试一定的次数，当超出重试个数就会抛出以下异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JedisClusterMaxRedirectionsException(<span class="string">&quot;Too many Cluster redirections?&quot;</span>);</span><br></pre></td></tr></table></figure><p>所以不管是太多次连接出错，还是大量重定向发生，都会抛出这个异常。</p><h5 id="3-6-3：ASK重定向"><a href="#3-6-3：ASK重定向" class="headerlink" title="3.6.3：ASK重定向"></a>3.6.3：ASK重定向</h5><p>这绝对是我最感兴趣的部分，参考<code>图12</code>，如果客户端在发送命令时redis集群正在进行槽迁移，那么势必会出现下面这种情况：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-22.png?imageView2/0/w/400" alt="图18"></p><p>出现了上面的问题，如果要保证客户端的可用性，此时源节点肯定会通知客户端重定向至目标节点，那么redis具体是怎么做的呢？答案就是<code>ASK重定向</code>，与<code>MOVED重定向</code>有一些不同，它只会发生在槽迁移阶段，它的具体流程如下：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-23.png?imageView2/0/w/400" alt="图19"></p><p>通过这个流程可以保证在槽迁移过程中客户端也能很好的得到响应，再来看看服务端具体的处理流程：</p><p><img src="http://myblog.sharemer.com/2021/05/26/20210526-1-24.png?imageView2/0/w/750" alt="图20"></p><h3 id="四、问题-建议"><a href="#四、问题-建议" class="headerlink" title="四、问题&amp;建议"></a>四、问题&amp;建议</h3><h4 id="4-1：配置上的建议"><a href="#4-1：配置上的建议" class="headerlink" title="4.1：配置上的建议"></a>4.1：配置上的建议</h4><p><code>3.5</code>中的故障转移过程中整个集群是不可用状态，可以通过将<code>cluster-require-full-coverage</code>设为<code>no</code>来保证出现故障时其他未故障节点可用。</p><h4 id="4-2：带宽开销"><a href="#4-2：带宽开销" class="headerlink" title="4.2：带宽开销"></a>4.2：带宽开销</h4><p>Redis对带宽的消耗主要体现在两方面，一是Gossip本身会消耗带宽，二是指令处理，官方建议redis集群最大规模在1000以内，也是出于对消息通信成本的考虑，可以通过增加物理机器来增加整体带宽；</p><p>提高cluster-node-timeout可以降低Gossip通信速率，但同样会影响故障转移的速度，请酌情选择合适的值。</p><p>如果条件允许，集群尽量部署在更多的机器上，如果大量的节点集中部署在少量物理机器上，这时机器的带宽消耗将非常严重。</p><h4 id="4-3：集群倾斜"><a href="#4-3：集群倾斜" class="headerlink" title="4.3：集群倾斜"></a>4.3：集群倾斜</h4><p>导致集群倾斜的原因和解决之道：</p><ul><li>节点和槽分布严重不均：可以通过<code>redis-trib.rb rebalance</code>均衡槽的分配</li><li>不同槽对应的键数量差异过大：我们知道键通过CRC16哈希函数映射到槽上，正常情况下槽内键数会相对均匀，但当大量使用hash_tag时（例如user:user1:ids，user1就是hash_tag），会有不同的键映射到同一个槽的情况，通过命令<code>cluster countkeysinslot $&#123;slot&#125;</code>可以获得槽对应的键数，识别出哪些槽映射了过多的键，再通过命令<code>cluster getkeysinslot $&#123;slot&#125; $&#123;count&#125;</code>迭代出槽下所有的键，从而发现过度使用hash_tag的键。</li><li>集合对象包含大量元素：大集合对象可在客户端通过<code>--bigkeys</code>指令输出，找出大集合后可根据业务场景进行拆分（大集合的键迁移时还容易超时导致失败）</li><li>内存相关配置不一致：集群内各节点的内存配置要保持一致（比如xxxx-max-ziplist-value等）。</li></ul><h4 id="4-4：手动故障转移"><a href="#4-4：手动故障转移" class="headerlink" title="4.4：手动故障转移"></a>4.4：手动故障转移</h4><p>在从节点执行<code>cluster failover</code>命令将会发起故障转移流程。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;上回主要介绍了redis的主从模式，主从模式最主要的作用是提高redis的可用性，假如主节点挂了，从节点可以在&lt;code&gt;哨兵机制&lt;/code&gt;的协助下晋升为主节点继续对外服务，但主从终归是多个redis节点都保存同一份数据，在redis数据快速膨胀时，又该如何应对呢？redis对于这种情况提供了Cluster模式，这是redis的分布式解决方案，使得大批量数据可以拆分成小部分保存进多个redis节点中，本篇笔记将展开说一下&lt;code&gt;Redis Cluster&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="redis" scheme="http://example.com/tags/redis/"/>
    
    <category term="缓存技术" scheme="http://example.com/tags/%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Redis知识整合（三）：高可用-主从</title>
    <link href="http://example.com/2021/05/24/Redis%E7%9F%A5%E8%AF%86%E6%95%B4%E5%90%88%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E9%AB%98%E5%8F%AF%E7%94%A8-%E4%B8%BB%E4%BB%8E/"/>
    <id>http://example.com/2021/05/24/Redis%E7%9F%A5%E8%AF%86%E6%95%B4%E5%90%88%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E9%AB%98%E5%8F%AF%E7%94%A8-%E4%B8%BB%E4%BB%8E/</id>
    <published>2021-05-24T14:25:00.000Z</published>
    <updated>2023-12-03T10:52:17.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis知识整合（三）：高可用-主从"><a href="#Redis知识整合（三）：高可用-主从" class="headerlink" title="Redis知识整合（三）：高可用-主从"></a>Redis知识整合（三）：高可用-主从</h1><blockquote><p>要想提高一个有状态服务的可用性，最简单直接的办法就是扩展从节点，这样主节点挂了，从节点就可以上位并代替原先的节点继续对外提供服务，同时也可用从节点做负载均衡，作为目前最好用的分布式缓存之一的redis自然也支持主从配置，这篇文档的主要内容就是围绕这个话题展开的。</p></blockquote><span id="more"></span><h3 id="一、配置-部署"><a href="#一、配置-部署" class="headerlink" title="一、配置&amp;部署"></a>一、配置&amp;部署</h3><h4 id="1-1：建立主从关系"><a href="#1-1：建立主从关系" class="headerlink" title="1.1：建立主从关系"></a>1.1：建立主从关系</h4><p>如何让一个redis节点变成另一个节点的从节点呢？很简单，首先在从节点的配置文件中加上以下配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof [master host] [master port]</span><br></pre></td></tr></table></figure><p>↑这同样也是个命令，可以直接在从节点上执行</p><p>也可以在启动redis-server的命令后面加上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--slaveof [master host] [master port]</span><br></pre></td></tr></table></figure><p>注：<code>slaveof</code>是一个异步命令，开始只保存主节点信息，后续复制操作都是在从节点内异步执行的，<code>info replication</code>可以帮助我们查看当前的复制情况（主从节点都可以执行这个指令，只是输出信息不一样而已）。</p><h4 id="1-2：废除主从关系"><a href="#1-2：废除主从关系" class="headerlink" title="1.2：废除主从关系"></a>1.2：废除主从关系</h4><p>在从节点执行以下命令可废除与主节点的关联，并晋升为主节点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof no one</span><br></pre></td></tr></table></figure><p>废除关系后，原从节点内的数据还在，只是失去了同步原主节点数据的能力。</p><h4 id="1-3：切主"><a href="#1-3：切主" class="headerlink" title="1.3：切主"></a>1.3：切主</h4><p>非常简单，只需要在从节点再次执行以下命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof [new master host] [new master port]</span><br></pre></td></tr></table></figure><p>执行后，发生以下变化：</p><ol><li>断开与旧主节点的复制关系</li><li>建立与新主节点的复制关系</li><li><strong>删除当前自身所有的数据</strong></li><li>复制新主节点的数据</li></ol><h4 id="1-4：只读"><a href="#1-4：只读" class="headerlink" title="1.4：只读"></a>1.4：只读</h4><p>一般情况下，从节点对外应只提供读操作，可以通过以下配置启用节点的只读模式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slave-read-only = yes</span><br></pre></td></tr></table></figure><h4 id="1-5：部署方案"><a href="#1-5：部署方案" class="headerlink" title="1.5：部署方案"></a>1.5：部署方案</h4><p>redis主从可行的部署方案如下：</p><p><img src="http://myblog.sharemer.com/2021/05/24/20210524-1-1.png?imageView2/0/w/800" alt="图1"></p><p>无论是哪种主从模式，都可以解决单点故障问题，但需要注意的是，一主多从虽然可以做读操作的负载均衡，但会加大主节点的负载（因为所有从节点都订阅了主节点的变更），为了解决这个问题，便有了树状部署方式，从节点继续向下拓展，这样可以有效降低主节点的负载（主节点只需要关心自己下一层的从节点即可）</p><blockquote><p>我现在的公司通常为一主一从、集群部署，主从所在的物理机必定不是同一台，这样可以有效降低缓存雪崩的概率（两台物理机同时gg的概率很小），且没有开启持久化等影响主进程的操作，完全将redis当成缓存来用。</p></blockquote><h3 id="二、同步过程"><a href="#二、同步过程" class="headerlink" title="二、同步过程"></a>二、同步过程</h3><ol><li>保存主节点信息：当<code>slaveof</code>命令执行完毕后，复制流程还没有真正开始，而是将master的ip+port保存了下来。</li><li>主从建立socket连接：从节点有个维护复制相关逻辑的定时器，当其发现存在新的主节点后，会尝试与其建立连接，用来接收主节点发来的复制命令（建连失败时，定时任务会无限重试，除非建连成功或执行<code>slave no one</code>）</li><li>发送<code>ping</code>请求：目的是检查socket是否可用、主节点是否受理（若不满足条件，从节点会断开socket，并在下次定时循环中重试）</li><li>权限校验：在主节点设置了<code>requirepass</code>的情况下，则需要密码校验，从节点需要设置<code>masterauth</code>来保证通过主节点的校验（若未通过校验，同3）</li><li>同步数据集：一切就绪后，从节点会向主节点发送一个<code>psync</code>指令，主节点第一次会将自己全部的数据生成快照发送给从节点（rdb文件）；2.8之前只支持<code>sync</code>同步，sync无脑全量复制，比如从节点断连后重连，也会触发一次全量复制，从节点在全量复制时是无法对外提供服务的，为了解决这一痛点，redis在2.8支持了<code>psync</code>，psync支持<code>全量复制</code>和<code>部分复制</code>，当第一次同步数据时才会全量复制，重连操作一般会利用<code>主节点运行ID</code>、<code>复制偏移量</code>和<code>复制积压缓冲区</code>，并采用<code>部分复制</code>的方式补发断连期间产生的增量数据（指令：<code>psync [runid] [offset]</code>）。</li><li>增量复制：当5完成后，接下来主节点会持续的将写命令发送给从节点，来保证主从一致性</li></ol><p>整体流程图（黄色部分为<code>复制建设流程</code>，紫色为<code>全量复制流程</code>，绿色为稳定期间的<code>增量同步流程</code>，蓝色为从节点挂掉又恢复后的<code>部分复制流程</code>）：</p><p><img src="http://myblog.sharemer.com/2021/05/24/20210524-1-8.png?imageView2/0/w/1600" alt="图2"></p><h3 id="三、常见问题"><a href="#三、常见问题" class="headerlink" title="三、常见问题"></a>三、常见问题</h3><h4 id="3-1：传输延迟"><a href="#3-1：传输延迟" class="headerlink" title="3.1：传输延迟"></a>3.1：传输延迟</h4><p>主节点一般通过网络传输同步数据，存在延迟的风险，redis通过以下配置项控制是否关闭<code>TCP_NODELAY</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repl-disable-tcp-nodelay = yes ### 默认no</span><br></pre></td></tr></table></figure><ul><li>开启：主节点为了节省带宽会合并较小的TCP数据包，默认发送时间取决于Linux内核，默认40ms，这种方式虽然节省了带宽但也加大了主从延迟，适用于主从网络环境较紧张的场景，比如主从跨机房部署。</li><li>关闭：主节点产生的命令数据无论多大都会及时的发送给从节点，这样主从延迟会变小，但加大了网络带宽，适用于主从网络环境较好的场景，比如主从同机房部署。</li></ul><h4 id="3-2：主从配置不一致"><a href="#3-2：主从配置不一致" class="headerlink" title="3.2：主从配置不一致"></a>3.2：主从配置不一致</h4><p>主从节点有关内存阈值的配置一定要保持一致</p><h4 id="3-3：避免复制风暴"><a href="#3-3：避免复制风暴" class="headerlink" title="3.3：避免复制风暴"></a>3.3：避免复制风暴</h4><p>如果一个主节点挂载了很多从节点，当这个主节点重启时，它的所有从节点势必会同时发起全量复制流程，虽然可以共享rdb文件，但这对主节点的带宽消耗是灾难性的，解决方案就是改变部署结构，参考图1中的树状结构部署，以减少直接挂载到主节点的从节点数量。</p><h4 id="3-4：各缓冲区-超时时间不够用"><a href="#3-4：各缓冲区-超时时间不够用" class="headerlink" title="3.4：各缓冲区&#x2F;超时时间不够用"></a>3.4：各缓冲区&#x2F;超时时间不够用</h4><p>可以估算出大致的阈值，然后设置一个大于该估算值的结果，比如估算rdb同步超时时间，假设网卡带宽峰值为100M&#x2F;s，那么rdb传输耗时就是：repl_timeout &#x3D; rdb大小 &#x2F; 100MB；</p><p>再比如估算复制积压缓冲区应设大小，假如网络中断时长为net_break_time(秒)，然后根据高峰期每秒的master_repl_offset推算出高峰期每秒的大概写入量write_size_per_sec，然后保证：<code>repl_backlog_size &gt; net_break_time * write_size_per_sec</code>即可。</p><h4 id="3-5：最终一致"><a href="#3-5：最终一致" class="headerlink" title="3.5：最终一致"></a>3.5：最终一致</h4><p>诚如你所见，redis主从复制是最终一致的，既然是最终一致，那就有可能在极端情况下造成少量数据丢失，应注意这个问题，至少你不应该完全信任redis，需要做好防范措施，比如定期回源刷新数据，保证少量问题数据可以自动得到修复。</p><h3 id="四、哨兵（Sentinel）"><a href="#四、哨兵（Sentinel）" class="headerlink" title="四、哨兵（Sentinel）"></a>四、哨兵（Sentinel）</h3><h4 id="4-1：基本工作流程"><a href="#4-1：基本工作流程" class="headerlink" title="4.1：基本工作流程"></a>4.1：基本工作流程</h4><p>前面的内容主要介绍了redis的主从模式，主从模式最主要的作用是提高redis的可用性，假如主节点挂了，从节点可以晋升为主节点继续对外提供服务，这个自动调整主从的过程可以通过<code>Sentinel</code>机制来实现，如果没有Sentinel，我们就得手动搞定这一切了，想想就可怕（redis在2.8版本才支持了Sentinel）。</p><p>Redis Sentinel高可用架构包含了多个sentinel节点和多个redis节点（主+从），每个sentinel节点都会对这些redis节点和其他sentinel节点进行监控（事实上sentinel节点也是redis节点，只是比较特殊，它们不存储数据且只接收部分命令），大致结构如下：</p><p><img src="http://myblog.sharemer.com/2021/05/24/20210524-1-10.png?imageView2/0/w/650" alt="图3"></p><p>当某个sentinel发现自己所监控的某个节点不可达后，会对这个节点做下线标识，如果该节点是redis的master节点，它就会和其他sentinel协商，当大多数sentinel都认为这个主节点不可达时，就会选出一个sentinel代表来完成故障转移工作，同时会将这个变化实时同步给redis client，这个过程是全自动的，下面的流程图展示了这个过程（假设主节点挂掉）：</p><p><img src="http://myblog.sharemer.com/2021/05/24/20210524-1-11.png?imageView2/0/w/1920" alt="图4"></p><h4 id="4-2：安装-部署"><a href="#4-2：安装-部署" class="headerlink" title="4.2：安装&amp;部署"></a>4.2：安装&amp;部署</h4><p>假如我们现在要搭建图3里的Redis Sentinel架构，那要如何配置呢？</p><h5 id="4-2-1：启动主节点"><a href="#4-2-1：启动主节点" class="headerlink" title="4.2.1：启动主节点"></a>4.2.1：启动主节点</h5><p>这是主节点主要的的配置信息(<code>redis-6379.conf</code>)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 6379 # 端口号</span><br><span class="line">daemonize yes # 以守护线程的方式在后台运行</span><br><span class="line">logfile &quot;log-6379.log&quot; # redis日志输出文件</span><br><span class="line">dbfilename &quot;dump-6379.rdb&quot; # rdb输出文件</span><br><span class="line">dir &quot;/opt/soft/redis/data/&quot; # rdb输出文件所在的路径</span><br></pre></td></tr></table></figure><p>启动+测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis-6379.conf</span><br><span class="line"></span><br><span class="line">redis-cli -h 127.0.0.1 -p 6379 ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><h5 id="4-2-2：启动从节点"><a href="#4-2-2：启动从节点" class="headerlink" title="4.2.2：启动从节点"></a>4.2.2：启动从节点</h5><p>两个从节点的配置除了端口号等细节外是一样的，我们这里拿其中一个举例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">port 6380</span><br><span class="line">daemonize yes</span><br><span class="line">logfile &quot;log-6380.log&quot;</span><br><span class="line">dbfilename &quot;dump-6380.rdb&quot;</span><br><span class="line">dir &quot;/opt/soft/redis/data/&quot;</span><br><span class="line">slaveof 127.0.0.1 6379 # 跟上面的主节点建立主从关系</span><br></pre></td></tr></table></figure><p>启动+测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis-6380.conf</span><br><span class="line">redis-server redis-6381.conf</span><br><span class="line"></span><br><span class="line">redis-cli -h 127.0.0.1 -p 6380 ping</span><br><span class="line">PONG</span><br><span class="line">redis-cli -h 127.0.0.1 -p 6381 ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><p>然后确认一遍主从关系是否正确，这是主节点视角的验证：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 6379 info replication</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=281,lag=1</span><br><span class="line">slave1:ip=127.0.0.1,port=6381,state=online,offset=281,lag=0</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这是从节点视角的验证（以其中一个为例）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 6380 info replication</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>到这里，主从架构就搭建完成了，接下来开始搭建sentinel环境。</p><h5 id="4-2-3：部署sentinel"><a href="#4-2-3：部署sentinel" class="headerlink" title="4.2.3：部署sentinel"></a>4.2.3：部署sentinel</h5><p>前面我们就了解到sentinel的本质也是redis节点，且不管几个sentinel，它们每个节点的部署方法都是一致的，所以我们只关注一个sentinel节点如何部署就好。</p><p>这是主要的配置信息(redis-sentinel-26379.conf)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">port 26379</span><br><span class="line">daemonize yes</span><br><span class="line">logfile &quot;log-26379.log&quot;</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2 # 监听指定的主节点，将其命名为mymaster，且判断主节点失败至少需要2个sentinel节点同意</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000 # 定时检查发送的检查指令响应超出30s视为失败</span><br><span class="line">sentinel parallel-syncs mymaster 1 # 含义参考下面的说明</span><br><span class="line">sentinel failover-timeout mymaster 180000 # 含义参考下面的说明</span><br><span class="line">说明：</span><br><span class="line">sentinel monitor [master_name] [master_ip] [master_port] [quorum]</span><br><span class="line">sentinel会定期监控主节点，上面的配置可以指定要监控的主节点，quorum比较特殊，它可以</span><br><span class="line">代表判定主节点最终不可达所需要的票数，也可以代表至少需要max(quorum,num(sentinel)/2 + 1)</span><br><span class="line">个sentinel参与才能选出sentinel的领导者来处理故障转移任务；</span><br><span class="line">quorum的取值建议设为num(sentinel)/2+1</span><br><span class="line">============================================================================</span><br><span class="line">sentinel down-after-milliseconds [master_name] [time]</span><br><span class="line">sentinel节点会定期发送ping命令来确定redis节点和sentinel节点是否可达，若ping所用</span><br><span class="line">时间超出了配置的times（毫秒），则判为不可达</span><br><span class="line">============================================================================</span><br><span class="line">sentinel parallel-syncs [master_name] [nums]</span><br><span class="line">当主节点故障时，sentinel选出新的主节点，此时从节点会向新主节点发起复制，nums用来控制</span><br><span class="line">同时发起复制的从节点数量，可以通过调小该值达到降低主节点的网络/IO开销的目的</span><br><span class="line">============================================================================</span><br><span class="line">sentinel failover-timeout [master_name] [time]</span><br><span class="line">故障转移超时时间，作用于故障转移的各个阶段，比如重新选主、命令从节点向主节点发起复制（不</span><br><span class="line">含复制时间）、等待原主节点恢复后命令其发起复制，在这几个步骤里任意步骤超过failover-timout</span><br><span class="line">就视为故障转移失败</span><br></pre></td></tr></table></figure><p>启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel redis-sentinel-26379.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或</span></span><br><span class="line">redis-server redis-sentinel-26379.conf --sentinel</span><br></pre></td></tr></table></figure><p>当三个sentinel节点都启动完毕后，输入以下指令检验其准确性：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 26379 info Sentinel</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Sentinel</span></span><br><span class="line">sentinel_masters 1</span><br><span class="line">sentinel_tilt:0</span><br><span class="line">sentinel_running_scripts:0</span><br><span class="line">sentinel_scripts_queue_length:0</span><br><span class="line">master0:name=mymaster,status=ok,address=127.0.0.1:6379,slaves=2,sentinels=3</span><br></pre></td></tr></table></figure><p>到这里整个sentinel+主从架构就搭建完成了，它们会按照之前说的那样工作；虽然redis可以单机多实例部署，但为了保证高可用，不建议将所有的节点都部署在同一台物理机上。</p><p>所有节点都启动后，sentinel配置文件发生了变化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">port 26379</span><br><span class="line">daemonize yes</span><br><span class="line">logfile &quot;log-26379.log&quot;</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line">sentinel config-epoch mymaster 0</span><br><span class="line">sentinel leader-epoch mymaster 0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发现2个slave</span></span><br><span class="line">sentinel-know-slave mymaster 127.0.0.1 6380</span><br><span class="line">sentinel-know-slave mymaster 127.0.0.1 6381</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发现另外2个sentinel节点</span></span><br><span class="line">sentinel known-sentinel mymaster 127.0.0.1 26380 xxxxxxxx(runid)</span><br><span class="line">sentinel known-sentinel mymaster 127.0.0.1 26381 yyyyyyyy(runid)</span><br><span class="line">sentinel current-epoch 0</span><br></pre></td></tr></table></figure><p>可以看到<code>down-after-milliseconds</code>、<code>parallel-syncs</code>、<code>failover-timeout</code>消失了，取而代之的是sentinel发现的各种节点信息，也就是说每个sentinel都是有能力自动发现所有需要监控的节点的。</p><h5 id="4-2-4：监控多个master"><a href="#4-2-4：监控多个master" class="headerlink" title="4.2.4：监控多个master"></a>4.2.4：监控多个master</h5><p>非常简单，只需要将原来的配置改成监听多个master的即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">port 26379</span><br><span class="line">daemonize yes</span><br><span class="line">logfile &quot;log-26379.log&quot;</span><br><span class="line">sentinel monitor mymaster-1 127.0.0.1 6379 2</span><br><span class="line">sentinel down-after-milliseconds mymaster-1 30000</span><br><span class="line">sentinel parallel-syncs mymaster-1 1</span><br><span class="line">sentinel failover-timeout mymaster-1 180000</span><br><span class="line"></span><br><span class="line">sentinel monitor mymaster-2 127.0.0.1 6389 2</span><br><span class="line">sentinel down-after-milliseconds mymaster-2 30000</span><br><span class="line">sentinel parallel-syncs mymaster-2 1</span><br><span class="line">sentinel failover-timeout mymaster-2 180000</span><br></pre></td></tr></table></figure><p>假如现在有一个sentinel集群，同时服务了两套redis主从服务，拓扑图就变成了下面这样：</p><p><img src="http://myblog.sharemer.com/2021/05/24/20210524-1-12.png?imageView2/0/w/850" alt="图5"></p><h5 id="4-2-5：部署技巧"><a href="#4-2-5：部署技巧" class="headerlink" title="4.2.5：部署技巧"></a>4.2.5：部署技巧</h5><ul><li>sentinel节点、主从节点应尽可能不部署到同一台物理机上</li><li>至少部署3个且奇数个sentinel节点，这是为了提高故障判定的准确率（多sentinel节点协商可以降低误判），奇数是为了在满族要求的机器数量基础上节约一台机器。</li><li>只配一套sentinel监听所有节点，还是专门以主节点为维度给每个主节点单独配置一套？只配一套可以降低维护成本，但是这样容错率很低，比如sentinel集群出问题会影响所有的redis节点，但反过来给每个主节点单独配置一套又拉高了维护成本和资源浪费，那该怎么取舍呢？这个可以分情况：如果是同一个业务下的主节点可以共用一套sentinel，反之多套。</li></ul><h4 id="4-3：哨兵专属指令集"><a href="#4-3：哨兵专属指令集" class="headerlink" title="4.3：哨兵专属指令集"></a>4.3：哨兵专属指令集</h4><table><thead><tr><th align="left">指令</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left"><code>sentinel masters</code> [master_name]</td><td align="left">列出所有被监控的主节点状态以及相关的统计信息，可指定主节点</td></tr><tr><td align="left"><code>sentinel slaves</code></td><td align="left">列出所有被监控的从节点状态以及相关的统计信息</td></tr><tr><td align="left"><code>sentinel sentinels</code> [master_name]</td><td align="left">列出正在监听指定主节点的sentinel节点信息（但不包含当前sentinel节点）</td></tr><tr><td align="left"><code>sentinel get-master-addr-by-name</code> [master_name]</td><td align="left">输出指定主节点的ip+port</td></tr><tr><td align="left"><code>sentinel reset</code> [pattern]</td><td align="left">当前sentinel对符合<code>pattern</code>的主节点进行配置重置，清除主节点的相关状态，重新发现该主节点和其他sentinel节点</td></tr><tr><td align="left"><code>sentinel failover</code> [master_name]</td><td align="left">对指定主节点（在不和其他sentinel协商的情况下）进行强制故障转移，转移完成后，其他sentinel按照该结果更新自身配置</td></tr><tr><td align="left"><code>sentinel ckquorum</code> [master_name]</td><td align="left">检测当前sentinel节点数是否达到所配的<code>quorum</code>，若未达到，则无法进行故障转移工作</td></tr><tr><td align="left"><code>sentinel flushconfig</code></td><td align="left">将sentinel节点的配置刷到磁盘上</td></tr><tr><td align="left"><code>sentinel remove</code> [master_name]</td><td align="left">取消当前sentinel节点对指定主节点的监控</td></tr><tr><td align="left"><code>sentinel monitor</code> [master_name] [ip] [port] [quorum]</td><td align="left">增加要监控的主节点，详细请参考上面配置文件里对该指令的介绍</td></tr><tr><td align="left"><code>sentinel set</code> [master_name]</td><td align="left">可以利用该指令动态的修改一些配置文件内的属性</td></tr><tr><td align="left"><code>sentinel is-master-down-by-addr</code></td><td align="left">当某个sentinel节点发现主节点坏掉时，为了防止误判，会向其他sentinel节点发送此命令，来获取其他节点对于主节点的判定结果，超出quorum个sentinel判定主节点失效则视为真正失效，此时会发起故障转移，除此之外，它还可以让当前sentinel申请成为故障转移的领导者</td></tr></tbody></table><h4 id="4-4：客户端"><a href="#4-4：客户端" class="headerlink" title="4.4：客户端"></a>4.4：客户端</h4><p>对于客户端来讲，sentinel最重要的一个功能就是将变更后的主节点通知到客户端，如果客户端仍然按照之前的方式进行直连master肯定是不行的，客户端需要跟sentinel进行交互，获取可用的master节点信息，具体过程如下：</p><p><img src="http://myblog.sharemer.com/2021/05/24/20210524-1-13.png?imageView2/0/w/950" alt="图6"></p><p>java里面利用<code>Jedis</code>的JedisSentinelPool和<code>redisson</code>的SentinelServersConfig就可以完成这个过程，具体使用不再赘述。</p><h4 id="4-5：原理"><a href="#4-5：原理" class="headerlink" title="4.5：原理"></a>4.5：原理</h4><h5 id="4-5-1：监控"><a href="#4-5-1：监控" class="headerlink" title="4.5.1：监控"></a>4.5.1：监控</h5><p>sentinel监控其他节点在前面的流程图中就一条线带过，但其实内部逻辑涵盖了三个定时任务，分别是：</p><p><img src="http://myblog.sharemer.com/2021/05/24/20210524-1-14.png?imageView2/0/w/950" alt="图7"></p><h5 id="4-5-2：下线协商"><a href="#4-5-2：下线协商" class="headerlink" title="4.5.2：下线协商"></a>4.5.2：下线协商</h5><p>现在假如master挂掉，此时sentinel会如何处理呢？master挂掉，意味着任意sentinel都无法ping通它，此时sentinel节点会向其他sentinel节点发送<code>sentinel is-master-down-by-addr</code>指令，来获取其他节点对于master节点的判定结果，当超过<code>quorum</code>个sentinel节点都认为master挂掉时，才会真的进行故障转移，这是为了防止单点误判，过程如下：</p><p><img src="http://myblog.sharemer.com/2021/05/24/20210524-1-15.png?imageView2/0/w/650" alt="图8"></p><h5 id="4-5-3：选举领导者"><a href="#4-5-3：选举领导者" class="headerlink" title="4.5.3：选举领导者"></a>4.5.3：选举领导者</h5><p>当认定一个主节点挂掉后（客观下线），并不会立即进行故障转移，而是在sentinel节点间选举出来一个领导者，然后由领导者进行故障转移，这个选举过程采用<code>raft算法</code>实现，具体过程如下：</p><p><img src="http://myblog.sharemer.com/2021/05/24/20210524-1-16.png?imageView2/0/w/700" alt="图9"></p><p>需要注意，图中仅列出了sentinel-2发起申请领导者角色，但实际上任意一个sentinel节点都会请求其他sentinel节点让自己变成领导者，每个sentinel有且仅有一票，最后谁得票多就选谁，如果一轮没选出领导者，那就继续进行下一轮选举，逻辑一致。</p><h5 id="4-5-4：故障转移"><a href="#4-5-4：故障转移" class="headerlink" title="4.5.4：故障转移"></a>4.5.4：故障转移</h5><p>选出领导者，接下来就可以进行故障转移了：</p><p><img src="http://myblog.sharemer.com/2021/05/24/20210524-1-17.png?imageView2/0/w/750" alt="图10"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Redis知识整合（三）：高可用-主从&quot;&gt;&lt;a href=&quot;#Redis知识整合（三）：高可用-主从&quot; class=&quot;headerlink&quot; title=&quot;Redis知识整合（三）：高可用-主从&quot;&gt;&lt;/a&gt;Redis知识整合（三）：高可用-主从&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;要想提高一个有状态服务的可用性，最简单直接的办法就是扩展从节点，这样主节点挂了，从节点就可以上位并代替原先的节点继续对外提供服务，同时也可用从节点做负载均衡，作为目前最好用的分布式缓存之一的redis自然也支持主从配置，这篇文档的主要内容就是围绕这个话题展开的。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="redis" scheme="http://example.com/tags/redis/"/>
    
    <category term="缓存技术" scheme="http://example.com/tags/%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Redis知识整合（二）：数据的持久化</title>
    <link href="http://example.com/2021/05/21/Redis%E7%9F%A5%E8%AF%86%E6%95%B4%E5%90%88%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://example.com/2021/05/21/Redis%E7%9F%A5%E8%AF%86%E6%95%B4%E5%90%88%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/</id>
    <published>2021-05-21T15:15:00.000Z</published>
    <updated>2023-12-03T10:55:59.577Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如果重启redis服务，或者重启redis所在的机器，那么对于将数据全部保存在内存中的redis而言，这两个操作无疑会让其数据全部丢失，此时如果我们没有做更多的容错方案，比如横向做集群、纵向做主从，此时就会造成<code>缓存雪崩</code>，所以我们或许需要给redis内的数据做个持久化，让其在恢复时读取持久化数据，恢复原始数据，redis有两种持久化方式，分别是<code>RDB</code>和<code>AOF</code>，RDB的实时性不如AOF，AOF恢复速度不如RDB</p></blockquote><span id="more"></span><h2 id="一、RDB"><a href="#一、RDB" class="headerlink" title="一、RDB"></a>一、RDB</h2><h3 id="1-1：概览"><a href="#1-1：概览" class="headerlink" title="1.1：概览"></a>1.1：概览</h3><p>RDB持久化会将当前redis进程内的数据生成快照保存到硬盘中（rdb文件），相关指令为<code>bgsave</code></p><p>我们可以通过配置<code>redis.conf</code>使其自动持久化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">save &lt;seconds&gt; &lt;changes&gt; #表示seconds秒内存在changes次修改时，自动触发bgsave命令</span><br><span class="line">dbfilename dump.rdb #这里指定保存的文件名</span><br></pre></td></tr></table></figure><p>在没有开启<code>AOF</code>的情况下<code>shutdown</code>掉redis，也会自动触发一次bgsave;</p><p>还有一种情况会自动触发bgsave，从节点发起全量复制时，主节点会自动触发bgsave并将生成的rdb文件发送给从节点。</p><h3 id="1-2：过程"><a href="#1-2：过程" class="headerlink" title="1.2：过程"></a>1.2：过程</h3><p>bgsave过程如下：</p><p><img src="http://myblog.sharemer.com/2021/05/21/20210521-1-1.png?imageView2/0/w/680" alt="图1-1"></p><p>这是个重操作，好在不影响主进程，即便如此，bgsave也不能频繁执行，这也是rdb持久化方式无法做到秒级持久化的原因，采用这种方式持久化就要承担部分数据丢失的风险。</p><h2 id="二、AOF"><a href="#二、AOF" class="headerlink" title="二、AOF"></a>二、AOF</h2><h3 id="2-1：概览"><a href="#2-1：概览" class="headerlink" title="2.1：概览"></a>2.1：概览</h3><p>针对rdb不适合实时持久化的问题，redis提供了<code>aof</code>持久化方案来解决。</p><p>开启aof持久化的redis.conf配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes #这一项置为true（默认false）</span><br><span class="line">appendfilename &quot;appendonly.aof&quot; #这里指定保存的文件名</span><br></pre></td></tr></table></figure><h3 id="2-2：流程"><a href="#2-2：流程" class="headerlink" title="2.2：流程"></a>2.2：流程</h3><p>aof的大体流程如下：</p><p><img src="http://myblog.sharemer.com/2021/05/21/20210521-1-2.png?imageView2/0/w/880" alt="图2-1"></p><p>主要分为<code>同步aof</code>文件和<code>定期刷新aof</code>文件两大块，定期刷新文件时保证数据不丢失的做法是增量双写（<code>1-1</code>）和旧数据同步（<code>1-2</code>），其中1-2中批量同步新aof文件时，可以通过<code>aof-rewrite-incremental-fsync</code>来控制每次同步的数据大小，默认32M。</p><p>aof重写文件的触发时机主要由以下两种方式控制：</p><ul><li>手动调用<code>bgrewriteaof</code>命令</li><li>根据<code>auto-aof-rewrite-min-size</code>和<code>auto-aof-rewrite-percentage</code>参数控制自动触发时机</li></ul><blockquote><p>auto-aof-rewrite-min-size：运行aof重写时aof文件的最小体积，默认64M</p><p>auto-aof-rewrite-percentage：当前aof文件的增量大小和上一次重写后aof文件大小的比值</p></blockquote><p>根据以上描述，重写aof文件的自动触发条件为：</p><p><img src="http://myblog.sharemer.com/2021/05/21/20210521-1-3.png?imageView2/0/w/880" alt="图2-2"></p><h2 id="三、重启加载"><a href="#三、重启加载" class="headerlink" title="三、重启加载"></a>三、重启加载</h2><p>不管是aof还是rdb，都是为了让redis重启时可以恢复原来的数据，整个过程如下：</p><p><img src="http://myblog.sharemer.com/2021/05/21/20210521-1-4.png?imageView2/0/w/880" alt="图3-1"></p><p>可以看到，当rdb和aof同时启用时，优先使用aof.</p><h2 id="四、优化"><a href="#四、优化" class="headerlink" title="四、优化"></a>四、优化</h2><h3 id="4-1：fork操作"><a href="#4-1：fork操作" class="headerlink" title="4.1：fork操作"></a>4.1：fork操作</h3><p>无论是aof还是rdb，涉及到的fork操作都是重操作，其耗时取决于redis主进程中的内存大小（每次fork都需要复制主进程的内存页表），主进程内存每增加1GB将拖慢fork操作20ms，可以在<code>info stats</code>统计中查看<code>latest_fork_usec</code>指标获取最近一次fork操作的耗时。</p><p>改善fork耗时：</p><ul><li>优先使用物理机或高效支持fork操作的虚拟化技术，避免使用<code>Xen</code></li><li>控制redis的最大可用内存（因为fork耗时跟内存量息息相关），生产环境建议redis实例内存控制在10G内</li><li>合理配置Linux内存分配策，避免物理内存不足导致的fork失败</li><li>降低fork操作的频率，如适当放宽aof的触发时机</li></ul><h3 id="4-2：子进程开销监控-优化"><a href="#4-2：子进程开销监控-优化" class="headerlink" title="4.2：子进程开销监控&amp;优化"></a>4.2：子进程开销监控&amp;优化</h3><p>通过前面的了解，我们知道redis中的子进程主要负责aof和rdb文件的重写，它的运行过程主要涉及CPU、内存、磁盘三部分的消耗：</p><h4 id="4-2-1：CPU"><a href="#4-2-1：CPU" class="headerlink" title="4.2.1：CPU"></a>4.2.1：CPU</h4><p>开销：子进程将进程内的数据分批次写入磁盘属于CPU密集型操作（对单核CPU的利用率可达90%）</p><p>优化：主要以减少资源竞争为优化点，比如：</p><ul><li>redis为CPU密集型服务，所以不要绑定单核CPU操作，因为子进程非常耗CPU，会严重影响父进程（单核上下文竞争）</li><li>要避免和其他CPU密集型服务部署在一起，避免过渡竞争CPU</li><li>多实例部署redis时，应保证同一时刻只有一个子进程在运行</li></ul><h4 id="4-2-2：硬盘"><a href="#4-2-2：硬盘" class="headerlink" title="4.2.2：硬盘"></a>4.2.2：硬盘</h4><p>开销：子进程主要负责将aof或rdb文件写入硬盘，也就造成了硬盘写入压力（可通过系统工具sar、iostat、iotop等分析出重写期间硬盘的负载情况）</p><p>优化：</p><ul><li>不要和其他高硬盘负载的服务部署在一起（比如存储服务、消息队列等）</li><li>aof重写会消耗大量的硬盘IO，所以在重写期间应减少aof缓冲区往aof里fsync的操作（设置<code>no-appendfsync-no-rewrite</code>为true即可，表示在重写期间不做fsync操作，但这样也可能会丢失整个aof重写期间的数据）</li><li>在开启aof且redis处于高流量写入场景时，若使用普通机械硬盘，则在aof同步硬盘时会发生瓶颈</li><li>对于单机多实例的部署，可以配置不同实例分盘存储aof，分摊硬盘写入压力</li></ul><h4 id="4-2-3：AOF追加阻塞"><a href="#4-2-3：AOF追加阻塞" class="headerlink" title="4.2.3：AOF追加阻塞"></a>4.2.3：AOF追加阻塞</h4><p>通过图2-1我们知道，被写入aof缓冲区的数据在everysec策略下会每隔1s调用系统的fsync写一次磁盘，既然是一次调用，那必然存在耗时，fsync是通过delay的方式定期触发的，每次redis主线程在发起fsync调用前都会判断上次fsync的时间，如果耗时超出2s，redis主线程便会陷入阻塞，等待上次fsync执行完，所以aof理论上最多会丢失2s的数据（通过info Persistence中的<code>aof_delayed_fsync</code>可以查看aof同步任务是否发生了delay）。</p><p>避免这种情况发生的办法就是优化硬盘（参考4.2.2）</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;如果重启redis服务，或者重启redis所在的机器，那么对于将数据全部保存在内存中的redis而言，这两个操作无疑会让其数据全部丢失，此时如果我们没有做更多的容错方案，比如横向做集群、纵向做主从，此时就会造成&lt;code&gt;缓存雪崩&lt;/code&gt;，所以我们或许需要给redis内的数据做个持久化，让其在恢复时读取持久化数据，恢复原始数据，redis有两种持久化方式，分别是&lt;code&gt;RDB&lt;/code&gt;和&lt;code&gt;AOF&lt;/code&gt;，RDB的实时性不如AOF，AOF恢复速度不如RDB&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="redis" scheme="http://example.com/tags/redis/"/>
    
    <category term="缓存技术" scheme="http://example.com/tags/%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Redis知识整合（一）：常用数据结构&amp;指令集</title>
    <link href="http://example.com/2021/05/18/Redis%E7%9F%A5%E8%AF%86%E6%95%B4%E5%90%88%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E6%8C%87%E4%BB%A4%E9%9B%86/"/>
    <id>http://example.com/2021/05/18/Redis%E7%9F%A5%E8%AF%86%E6%95%B4%E5%90%88%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E6%8C%87%E4%BB%A4%E9%9B%86/</id>
    <published>2021-05-18T04:56:00.000Z</published>
    <updated>2023-12-03T10:59:45.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言：Redis各版本重大更新"><a href="#前言：Redis各版本重大更新" class="headerlink" title="前言：Redis各版本重大更新"></a>前言：Redis各版本重大更新</h2><p>截至2021年5月，Redis的稳定版本已经更新到了6.2，所以这里我想整理一下redis自发布以来每一个大版本的重要更新，当然我不会全部都展示出来，只挑那些具有重要革新的功能说。</p><span id="more"></span><h3 id="redis2-6"><a href="#redis2-6" class="headerlink" title="redis2.6"></a>redis2.6</h3><p>发行于2012年，相比旧版，它新支持了以下功能：</p><ul><li>redis-server支持Lua脚本</li><li>键的过期时间可以精确到毫秒</li><li>slave节点提供只读功能</li><li>新指令：<code>bitcount</code>、<code>bittop</code>（操作位图用的）</li><li>基于浮点数的自增功能：<code>incrbyfloat</code>、<code>hincrbyfloat</code></li><li>redis-cli支持用<code>--eval</code>参数实现Lua脚本</li></ul><h3 id="redis2-8"><a href="#redis2-8" class="headerlink" title="redis2.8"></a>redis2.8</h3><p>发行于2013年11月，新功能如下：</p><ul><li>支持部分主从复制，降低了由于网络问题导致频繁全量复制RDB时对系统造成的压力</li><li>支持IPv6</li><li>支持<code>config rewrite</code>指令可以将<code>config set</code>持久化到redis的配置文件中</li><li>新指令：pubsub（给订阅发布功能用的）</li><li>redis哨兵v2</li></ul><h3 id="redis3-0"><a href="#redis3-0" class="headerlink" title="redis3.0"></a>redis3.0</h3><p>发行于2015年4月，新功能如下：</p><ul><li>支持redis集群（<code>Redis Cluster</code>），这是redis官方的集群方案，在这之前，有两种方案也可以实现redis的集群：<code>Codis</code> 和<code>Twemproxy</code></li><li>LRU算法大幅提升</li><li><code>migrate</code>连接缓存，大幅提升键的迁移速度</li><li><code>incr</code>、<code>bitcount</code>命令性能提升</li></ul><h3 id="redis3-2"><a href="#redis3-2" class="headerlink" title="redis3.2"></a>redis3.2</h3><ul><li>新增GEO功能</li><li>对redis底层字符串（<code>SDS</code>）在速度和节省空间上都做了相关优化</li><li>支持用<code>upstart</code>或<code>systemd</code>管理redis进程</li><li>新的list编码类型：quicklist</li><li>新增<code>hstrlen</code>指令、增强<code>debug</code>、<code>spop</code>指令（支持的参数更多了）、增强<code>cluster nodes</code>指令（提速）</li><li>新RDB格式（兼容旧版），提升了RDB文件的加载速度</li><li>Jemalloc更新至4.0.3版本</li></ul><h3 id="redis4-0"><a href="#redis4-0" class="headerlink" title="redis4.0"></a>redis4.0</h3><ul><li>提供模块功能，方便第三方拓展功能</li><li>PSYNC2.0：优化了之前版本中，主从节点切换必然引起全量复制的问题</li><li>支持LFU，并对已有缓存过期算法进行了优化</li><li>提供非阻塞式的<code>del</code>和<code>flushall</code>&#x2F;<code>flushdb</code>功能，解决了删除大key时可能会造成redis阻塞的问题</li><li>提供RDB-AOF混合持久化格式，充分结合了RDB和AOF的优点</li><li>新增<code>memory</code>指令，使内存监控更加全面</li><li>Redis Cluster兼容NAT和docker</li></ul><h2 id="一、五种数据结构"><a href="#一、五种数据结构" class="headerlink" title="一、五种数据结构"></a>一、五种数据结构</h2><p>redis有五种数据结构，在操作它们时会使用到不同的api，在实际开发中，这些api也是离我们开发最近的一块内容，所以熟练掌握常用的api对我们非常有用。</p><h3 id="字符串（string）"><a href="#字符串（string）" class="headerlink" title="字符串（string）"></a>字符串（string）</h3><p>最基本的k-v格式，value是一个字符串，它的内部编码如下：</p><p><img src="http://myblog.sharemer.com/2021/05/18/20210518-1-1.png?imageView2/0/w/500" alt="图1-1"></p><p>指令集：</p><table><thead><tr><th align="left">指令</th><th align="left">解释</th><th align="left">时间复杂度</th></tr></thead><tbody><tr><td align="left"><code>set</code> [k] [v]</td><td align="left">最常用的质量，写入一对k-v</td><td align="left">O(1)</td></tr><tr><td align="left"><code>mset</code> [k1] [v1] [k2] [v2] …</td><td align="left">批量写入k-v</td><td align="left">O(k) k&#x3D;键数</td></tr><tr><td align="left"><code>set</code> [k] [v] <code>nx</code></td><td align="left">只有当key不存在时才会写入成功（新增）</td><td align="left">O(1)</td></tr><tr><td align="left"><code>setnx</code> [k] [v]</td><td align="left">作用等同于上面一条</td><td align="left">O(1)</td></tr><tr><td align="left"><code>set</code> [k] [v] <code>xx</code></td><td align="left">只有当key存在时才会写入成功（修改）</td><td align="left">O(1)</td></tr><tr><td align="left"><code>setxx</code> [k] [v]</td><td align="left">作用等同于上面一条</td><td align="left">O(1)</td></tr><tr><td align="left"><code>get</code> [k]</td><td align="left">取value值</td><td align="left">O(1)</td></tr><tr><td align="left"><code>del</code> [k1] [k2] …</td><td align="left">删除掉k-v数据，支持传多个key</td><td align="left">O(k) k&#x3D;键数</td></tr><tr><td align="left"><code>incr</code> [k]</td><td align="left">自增</td><td align="left">O(1)</td></tr><tr><td align="left"><code>decr</code> [k]</td><td align="left">自减</td><td align="left">O(1)</td></tr><tr><td align="left"><code>incrby</code> [k] [num]</td><td align="left">自增指定的数字</td><td align="left">O(1)</td></tr><tr><td align="left"><code>decrby</code> [k] [num]</td><td align="left">自减指定的数字</td><td align="left">O(1)</td></tr><tr><td align="left"><code>incrbyfloat</code> [k] [num]</td><td align="left">自增指定的数字（针对浮点数自增）</td><td align="left">O(1)</td></tr><tr><td align="left"><code>append</code> [k] [v]</td><td align="left">往原有字符串尾部追加内容</td><td align="left">O(1)</td></tr><tr><td align="left"><code>strlen</code> [k]</td><td align="left">获取value的长度（单位：字节）</td><td align="left">O(1)</td></tr><tr><td align="left"><code>setrange</code> [k] [offset] [v]</td><td align="left">字符替换，offset为被替换字符的位置</td><td align="left">O(1)</td></tr><tr><td align="left"><code>getrange</code> [k] [start] [end]</td><td align="left">获取部分字符串，截取区间：[start, end]</td><td align="left">O(n) n&#x3D;字符串长度</td></tr></tbody></table><p>适用范围：做基本的分布式缓存、分布式锁、计数&#x2F;限流、保存集群下的登录状态等。</p><h3 id="列表（list）"><a href="#列表（list）" class="headerlink" title="列表（list）"></a>列表（list）</h3><p>顾名思义，一个key对应了一个列表，列表内保存着多个value，其内部结构和编码如下：</p><p><img src="http://myblog.sharemer.com/2021/05/18/20210518-1-2.png?imageView2/0/w/560" alt="图1-2"></p><p>其中<code>list-max-ziplist-entries</code>和<code>list-max-ziplist-value</code>都是redis的配置项。</p><p>指令集：</p><table><thead><tr><th align="left">指令</th><th align="left">解释</th><th align="left">时间复杂度</th></tr></thead><tbody><tr><td align="left"><code>rpush</code> [k] [v1] [v2] …</td><td align="left">从列表的右边插入元素</td><td align="left">O(k) k&#x3D;插入元素数</td></tr><tr><td align="left"><code>lpush</code> [k] [v1] [v2] …</td><td align="left">从列表的左边插入元素</td><td align="left">同上</td></tr><tr><td align="left"><code>linsert</code> [k] <code>before/after</code> [vx] [vn]</td><td align="left">向vx的前或后面插入vn</td><td align="left">O(n) n&#x3D;vx与表头&#x2F;尾的距离</td></tr><tr><td align="left"><code>lrange</code> [k] [start] [end]</td><td align="left">输出指定范围的列表，范围：[start, end]，start&#x2F;end为下标值</td><td align="left">O(s+n) s&#x3D;start偏移量；n&#x3D;start~end的范围</td></tr><tr><td align="left"><code>lindex</code> [k] [index]</td><td align="left">获取指定下标的value</td><td align="left">O(n) n&#x3D;index偏移量</td></tr><tr><td align="left"><code>llen</code> [k]</td><td align="left">获取列表长度</td><td align="left">O(1)</td></tr><tr><td align="left"><code>lpop</code> [k]</td><td align="left">弹出左边第一个元素</td><td align="left">O(1)</td></tr><tr><td align="left"><code>rpop</code> [k]</td><td align="left">弹出右边第一个元素</td><td align="left">O(1)</td></tr><tr><td align="left"><code>blpop</code> [k] [timeout]</td><td align="left">阻塞式弹出左边第一个元素，timout非必须，当列表中没有元素时阻塞</td><td align="left">O(1)</td></tr><tr><td align="left"><code>brpop</code> [k] [timeout]</td><td align="left">阻塞式弹出右边第一个元素，timout非必须，当列表中没有元素时阻塞</td><td align="left">O(1)</td></tr><tr><td align="left"><code>lrem</code> [num] [v]</td><td align="left">删除v包括其前后的元素，这取决于num：num&gt;0，从左至右删除最多num个元素；num&lt;0，从右至左删除最多|count|个元素；num&#x3D;0，全部删除</td><td align="left">O(n) n&#x3D;列表长度</td></tr><tr><td align="left"><code>ltrim</code> [k] [start] [end]</td><td align="left">只保留[start, end]区间的数据</td><td align="left">O(n) n&#x3D;start~end的长度</td></tr><tr><td align="left"><code>lset</code> [k] [index] [v]</td><td align="left">修改指定下标中的元素</td><td align="left">O(n) n&#x3D;index偏移量</td></tr></tbody></table><p>如你所见，我们可以利用lpush和brpop来实现一个消息队列：</p><p><img src="http://myblog.sharemer.com/2021/05/18/20210518-1-3.png?imageView2/0/w/860" alt="图1-3"></p><p>除此之外，我们可以利用它来保存一个信息id列表，然后用<code>lrange</code>指令实现列表的高效分页，拿到单页id集合后再去批量查询这些id对应的详细信息，最终聚合成完整信息输出给客户端，这样既节约资源，又便于我们设计和复用缓存结构。（ps：根据lrange的复杂度不难推断出在数据量庞大的情况下会影响其性能，这时可以尝试大key拆分成小key，比如可以利用CRC32(value) % key_num来做数据拆分，当然也可以利用redis3.2推出的<code>quicklist</code>内部编码实现，它对大key的性能一样很高）</p><h3 id="集合（set）"><a href="#集合（set）" class="headerlink" title="集合（set）"></a>集合（set）</h3><p>跟list一样，一个key对应一堆value，但是set不允许有重复的value，同时它也是无序的，其内部结构和编码如下：</p><p><img src="http://myblog.sharemer.com/2021/05/18/20210518-1-4.png?imageView2/0/w/560" alt="图1-4"></p><p>其中<code>set-max-intset-entrie</code>可配。</p><p>指令集：</p><table><thead><tr><th align="left">指令</th><th align="left">解释</th><th align="left">时间复杂度</th></tr></thead><tbody><tr><td align="left"><code>sadd</code> [k] [v1] [v2] …</td><td align="left">添加元素</td><td align="left">O(k) k&#x3D;插入元素数</td></tr><tr><td align="left"><code>srem</code> [k] [v1] [v2] …</td><td align="left">删除元素</td><td align="left">O(k) k&#x3D;删除元素数</td></tr><tr><td align="left"><code>scard</code> [k]</td><td align="left">获取元素总数</td><td align="left">O(1)</td></tr><tr><td align="left"><code>sismember</code> [k] [v]</td><td align="left">v是否在集合k中</td><td align="left">O(1)</td></tr><tr><td align="left"><code>srandmember</code> [k] [num]</td><td align="left">从集合k中随机返回num个元素</td><td align="left">O(k) k&#x3D;num</td></tr><tr><td align="left"><code>spop</code> [k] [num]</td><td align="left">从集合k中随机弹出num个元素</td><td align="left">O(1)</td></tr><tr><td align="left"><code>smembers</code> [k]</td><td align="left">获取所有元素（结果无序）</td><td align="left">O(n) n&#x3D;元素总数</td></tr><tr><td align="left"><code>sscan</code> [k]</td><td align="left">迭代出所有元素，类似下面<code>scan</code>的用法</td><td align="left">同上</td></tr><tr><td align="left"><code>sinter</code> [k1] [k2] …</td><td align="left">求多个集合的交集</td><td align="left">O(m*k) k&#x3D;多个集合中最少元素数，m&#x3D;集合数</td></tr><tr><td align="left"><code>sinterstore</code> [dk] [k1] [k2] …</td><td align="left">将算出的交集存入dk中</td><td align="left">同上</td></tr><tr><td align="left"><code>suinon</code> [k1] [k2] …</td><td align="left">求多个集合的并集</td><td align="left">O(k) k&#x3D;多个集合的总元素数</td></tr><tr><td align="left"><code>suinonstore</code> [dk] [k1] [k2] …</td><td align="left">将算出的并集存入dk中</td><td align="left">同上</td></tr><tr><td align="left"><code>sdiff</code> [k1] [k2] …</td><td align="left">求多个集合的差集</td><td align="left">同上</td></tr><tr><td align="left"><code>sdiffstore</code> [dk] [k1] [k2] …</td><td align="left">将算出的差集存入dk中</td><td align="left">同上</td></tr></tbody></table><p>相比list，set并不能用来分页以及展示一个列表，因为它是无序的，但我们仍然可以为它找到合适的应用场景，比如可以用它来存储用户的喜好标签，便于利用取<code>交集</code>、<code>差集</code>等功推荐同好；也可以存储某些权益信息，比如某大V粉丝集合，利用<code>sismember</code>指令可以很快得出一个用户是否是另一个用户的粉丝（得出按钮展示“已关注”还是“未关注”），这同样可以计算一个大V与另一个大V的粉丝重合度。</p><h3 id="有序集合（zset）"><a href="#有序集合（zset）" class="headerlink" title="有序集合（zset）"></a>有序集合（zset）</h3><p>相比set，zset可以进行灵活排序、分页等操作，同样它也不允许有重复元素，其内部结构和编码如下：</p><p><img src="http://myblog.sharemer.com/2021/05/18/20210518-1-5.png?imageView2/0/w/580" alt="图1-5"></p><p>其中<code>zset-max-ziplist-entries</code>和<code>zset-max-ziplist-value</code>都是redis的配置项。</p><p>指令集：</p><table><thead><tr><th align="left">指令</th><th align="left">解释</th><th align="left">时间复杂度</th></tr></thead><tbody><tr><td align="left"><code>zadd</code> [k] [s1] [v1] [s2] [v2] …</td><td align="left">添加成员</td><td align="left">O(k*log(n)) k&#x3D;插入个数，n&#x3D;总个数</td></tr><tr><td align="left"><code>zscore</code> [k] [v]</td><td align="left">获取某成员分数</td><td align="left">O(1)</td></tr><tr><td align="left"><code>zcard</code> [k]</td><td align="left">获取元素总数</td><td align="left">O(1)</td></tr><tr><td align="left"><code>zcount</code> [k] [min] [max]</td><td align="left">获取score值在[min, max]区间的元素总数</td><td align="left">O(log(n)) n&#x3D;总个数</td></tr><tr><td align="left"><code>zincrby</code> [k] [num] [v]</td><td align="left">给v加num分</td><td align="left">同上</td></tr><tr><td align="left"><code>zrank</code> [k] [v]</td><td align="left">返回v的正序排名</td><td align="left">同上</td></tr><tr><td align="left"><code>zrevrank</code> [k] [v]</td><td align="left">返回v的倒序排名</td><td align="left">同上</td></tr><tr><td align="left"><code>zrem</code> [k] [v1] [v2] …</td><td align="left">删除元素</td><td align="left">O(k*log(n)) k&#x3D;删除个数，n&#x3D;总个数</td></tr><tr><td align="left"><code>zscan</code> [k]</td><td align="left">迭代出[k]里所有的元素，类似下面<code>scan</code>的用法</td><td align="left">O(N) N&#x3D;总个数</td></tr><tr><td align="left"><code>zrange</code> [k] [start] [end] <code>withsocres</code></td><td align="left">按分数从小到大返回[start, end]区间内的数据（score+v都会返回）</td><td align="left">O(log(n)+k) k&#x3D;获取数；n&#x3D;总个数</td></tr><tr><td align="left"><code>zrevrange</code> [k] [start] [end] <code>withscores</code></td><td align="left">按分数从大到小返回[start, end]区间内的数据（score+v都会返回）</td><td align="left">同上</td></tr><tr><td align="left"><code>zrangebyscore</code> [k] [min] [max] <code>withscores</code></td><td align="left">返回score值在[min, max]区间的数据（按从小到大排序）</td><td align="left">同上</td></tr><tr><td align="left"><code>zrevrangebyscore</code> [k] [max] [min] <code>withscores</code></td><td align="left">返回score值在[max, min]区间的数据（按从大到小排序）</td><td align="left">同上</td></tr><tr><td align="left"><code>zremrangebyrank</code> [k] [start] [end]</td><td align="left">删除[start, end]名次区间内的数据</td><td align="left">O(log(n)+k) k&#x3D;删除数；n&#x3D;总个数</td></tr><tr><td align="left"><code>zremrangebyscore</code> [k] [min] [max]</td><td align="left">删除分数在[min, max]区间内的数据</td><td align="left">同上</td></tr><tr><td align="left"><code>zinterstore</code> [dk] [num] [k1] [k2] …</td><td align="left">将k1、k2等集合的交集存入dk中</td><td align="left">O(n<em>k)+O(m</em>log(m)) n&#x3D;成员数最小集合的成员数，k&#x3D;参与取交集的集合数，m&#x3D;结果集中的成员数</td></tr><tr><td align="left"><code>zunionstore</code> [dk] [num] [k1] [k2] …</td><td align="left">将k1、k2等集合的并集存入dk中</td><td align="left">O(n)+O(m*log(m)) n&#x3D;所有集合成员数之和，m&#x3D;结果集中的成员数</td></tr></tbody></table><p>作为一个支持正序、倒序、分页的集合，它特别适合做一些排行榜类的需求，这样可以很方便的获取名次、分数等关键信息；</p><p>除此之外也可以做一些含排序操作的列表页：比如b站的个人空间中up主的稿件列表，可以按照时间、播放量、收藏量来进行正序和倒序展示，同时还支持分页，那么我们就可以建设3个统计维度的有序集合（分别以投稿时间、播放量、收藏量做score），value保存稿件id，然后按照排序类型、页码查询出单页数据，再利用单页的id集合批量查询稿件详细信息，最终将这些信息聚合成接口返回给客户端即可。</p><h3 id="哈希（hash）"><a href="#哈希（hash）" class="headerlink" title="哈希（hash）"></a>哈希（hash）</h3><p>hash类型的数据本身就是一个k-v结构，也就是一个redis key对应多个k-v，结构和内部编码如下：</p><p><img src="http://myblog.sharemer.com/2021/05/18/20210518-1-6.png?imageView2/0/w/590" alt="图1-6"></p><p>其中<code>hash-max-ziplist-entries</code>和<code>hash-max-ziplist-value</code>都是redis的配置项。</p><p>指令集：</p><table><thead><tr><th align="left">指令</th><th align="left">解释</th><th align="left">时间复杂度</th></tr></thead><tbody><tr><td align="left"><code>hset</code> [k] [KEY] [VALUE]</td><td align="left">为[k]添加一对[KEY]-[VALUE]</td><td align="left">O(1)</td></tr><tr><td align="left"><code>hget</code> [k] [KEY]</td><td align="left">获取[k]里[KEY]对应的value</td><td align="left">O(1)</td></tr><tr><td align="left"><code>hdel</code> [k] [KEY1] [KEY2] …</td><td align="left">删除[k]里的某些[KEY]</td><td align="left">O(k) k&#x3D;被删KEY的个数</td></tr><tr><td align="left"><code>hlen</code> [k]</td><td align="left">获取[k]里[KEY]的数量</td><td align="left">O(1)</td></tr><tr><td align="left"><code>hgetall</code> [k]</td><td align="left">获取[k]里所有的[KEY]-[VALUE]</td><td align="left">O(n) n&#x3D;KEY数</td></tr><tr><td align="left"><code>hscan</code> [k]</td><td align="left">迭代的方式获取[k]里所有的[KEY]-[VALUE]，用法跟后面的<code>scan</code>类似</td><td align="left">O(n) n&#x3D;单次迭代结果数</td></tr><tr><td align="left"><code>hmget</code> [k] [KEY1] [KEY2] …</td><td align="left">批量获取[k]里一些[KEY]的[VALUE]</td><td align="left">O(k) k&#x3D;获取的KEY数</td></tr><tr><td align="left"><code>hmset</code> [k] [KEY1] [VALUE1] [KEY2] [VALUE2] …</td><td align="left">为[k]添加多个[KEY]-[VALUE]</td><td align="left">O(k) k&#x3D;插入的KEY数</td></tr><tr><td align="left"><code>hexists</code> [k] [KEY]</td><td align="left">判断[k]内是否存在[KEY]键</td><td align="left">O(1)</td></tr><tr><td align="left"><code>hkeys</code> [k]</td><td align="left">获取[k]内所有的[KEY]</td><td align="left">O(n) n&#x3D;KEY数</td></tr><tr><td align="left"><code>hvals</code> [k]</td><td align="left">获取[k]内所有的[VALUE]</td><td align="left">同上</td></tr><tr><td align="left"><code>hsetnx</code> [k] [KEY] [VALUE]</td><td align="left">当[VALUE]不存在时才设置成功</td><td align="left">O(1)</td></tr><tr><td align="left"><code>hincrby</code> [k] [KEY] [num]</td><td align="left">对[k]内[KEY]的值自增num</td><td align="left">O(1)</td></tr><tr><td align="left"><code>hincrbyfloat</code> [k] [KEY] [num]</td><td align="left">对[k]内[KEY]的浮点值自增num</td><td align="left">O(1)</td></tr><tr><td align="left"><code>hstrlen</code> [k] [KEY]</td><td align="left">获取[k]内[KEY]对应[VALUE]的length</td><td align="left">O(1)</td></tr></tbody></table><p>用处主要是用来结构化的存储一些数据，比如可以把一个对象各个属性和属性值当成hash结构缓存入redis。</p><h2 id="二、通用指令"><a href="#二、通用指令" class="headerlink" title="二、通用指令"></a>二、通用指令</h2><p>下面是一些通用的指令，不同于上面的指令，这些指令不会针对某些数据结构生效，而是全局有效。</p><table><thead><tr><th align="left">指令</th><th align="left">解释</th><th align="left">时间复杂度</th></tr></thead><tbody><tr><td align="left"><code>keys</code> [xx]*</td><td align="left">获取所有前缀为“xx”的key，若直接为<code>keys *</code>就是获取所有key，重操作</td><td align="left">O(n) n&#x3D;key总数</td></tr><tr><td align="left"><code>scan</code> [cursor] [xx]* [count]</td><td align="left">非阻塞式获取所有key，相比<code>keys</code>，<code>scan</code>是利用[cursor]做游标进行迭代的，[count]则是返回的条数，默认10条，每次迭代结果中会返回下次迭代所需的[cursor]，这样就可以一步步迭代出来所有的key了，它不是一个重操作，也就不会长阻塞redis线程</td><td align="left">O(n) n&#x3D;单次迭代结果数</td></tr><tr><td align="left"><code>dbsize</code></td><td align="left">获取当前db内的key总数</td><td align="left">O(1)</td></tr><tr><td align="left"><code>exists</code> [k1] [k2] …</td><td align="left">是否存在[k1]、[k2]等键</td><td align="left">O(n) n&#x3D;查看key的个数</td></tr><tr><td align="left"><code>del</code> [k1] [k2] …</td><td align="left">删除[k1]、[k2]等键</td><td align="left">O(n) n&#x3D;删除key的个数</td></tr><tr><td align="left"><code>expire</code> [k] [time]</td><td align="left">让[k]time秒后过期</td><td align="left">O(1)</td></tr><tr><td align="left"><code>persist</code> [k]</td><td align="left">取消[k]的过期时间</td><td align="left">O(1)</td></tr><tr><td align="left"><code>ttl</code> [k]</td><td align="left">返回[k]的剩余过期时间，若返回-1，说明没设过期时间，-2表示[k]不存在，&gt;0表示剩余的时间，单位秒</td><td align="left">O(1)</td></tr><tr><td align="left"><code>type</code> [k]</td><td align="left">查看[k]对应值的类型（string、set、zset、list、hash）</td><td align="left">O(1)</td></tr><tr><td align="left"><code>object encoding</code> [k]</td><td align="left">查看[k]的内部编码（int、embstr、raw、ziplist、hashtable、linkedlist、skiplist、intset）</td><td align="left">O(1)</td></tr><tr><td align="left"><code>rename</code> [k1] [k2]</td><td align="left">将[k1]重命名为[k2]</td><td align="left">O(1)</td></tr><tr><td align="left"><code>renamenx</code> [k1] [k2]</td><td align="left">当k2不存在时才能重命名成功</td><td align="left">O(1)</td></tr><tr><td align="left"><code>randomkey</code></td><td align="left">随机返回一个key</td><td align="left">O(1)</td></tr><tr><td align="left"><code>dump</code> [k]</td><td align="left">将[k]的值dump成RDB格式的数据</td><td align="left">O(1)+O(M*N) M&#x3D;k对应的对象数；N&#x3D;对象平均大小，对于值很小的情况，复杂度趋近O(1)</td></tr><tr><td align="left"><code>restore</code> [k] [ttl] [v]</td><td align="left">跟dump结合使用，[v]&#x3D;dump出的数据，适用于数据转移（比如将redis1中的[k]转移到redis2中）；[ttl]为过期时间，若为0，则表示没有过期时间（这种迁移方式非原子性）</td><td align="left">同上，但有序集合为O(N * M * log(N))</td></tr><tr><td align="left"><code>migrate</code> [ip] [port] &#96;key</td><td align="left">“”<code>[db] [timeout]</code>copy<code>replace</code>keys&#96; [k1] [k2]…</td><td align="left">数据迁移（这个命令实际上是在源实例中执行一次dump+del，在目标实例中执行一次restore），[ip]+[port]为迁移的目标机器，&#96;key</td></tr><tr><td align="left"><code>select</code> [db]</td><td align="left">选择redis数据库，db为数据库下标（一般常为0）redis3中已弱化db功能，redis cluster更是不支持多db，默认0号db</td><td align="left">O(1)</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言：Redis各版本重大更新&quot;&gt;&lt;a href=&quot;#前言：Redis各版本重大更新&quot; class=&quot;headerlink&quot; title=&quot;前言：Redis各版本重大更新&quot;&gt;&lt;/a&gt;前言：Redis各版本重大更新&lt;/h2&gt;&lt;p&gt;截至2021年5月，Redis的稳定版本已经更新到了6.2，所以这里我想整理一下redis自发布以来每一个大版本的重要更新，当然我不会全部都展示出来，只挑那些具有重要革新的功能说。&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="redis" scheme="http://example.com/tags/redis/"/>
    
    <category term="缓存技术" scheme="http://example.com/tags/%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>插入式注解处理器的一次使用经历</title>
    <link href="http://example.com/2021/02/08/%E6%8F%92%E5%85%A5%E5%BC%8F%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8%E7%BB%8F%E5%8E%86/"/>
    <id>http://example.com/2021/02/08/%E6%8F%92%E5%85%A5%E5%BC%8F%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8%E7%BB%8F%E5%8E%86/</id>
    <published>2021-02-08T08:21:00.000Z</published>
    <updated>2023-12-03T11:05:05.949Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>插入式注解处理器在《深入理解Java虚拟机》一书中有一些介绍（前端编译篇有提到），但一直没有机会使用，直到碰到这个需求，觉得再合适不过了，就简单用了一下，这里做个记录。</p></blockquote><h2 id="一、需求"><a href="#一、需求" class="headerlink" title="一、需求"></a>一、需求</h2><p>我们为公司提供了一套通用的JAVA基础组件包，组件包内有不同的模块，比如熔断模块、负载均模块、rpc模块等等，这些模块均会被打成jar包，然后发布到公司的内部代码仓库中，供其他人引入使用。</p><p>这份代码会不断的迭代，我们希望可以通过<code>promethus</code>来监控现在公司内使用各版本代码库的比例，希望达到的效果图如下：</p><p><img src="https://myblog.sharemer.com/2021/02/08/20210208-1.png?imageView2/0/w/600" alt="图1-1"></p><p>我们希望看到每一个版本的使用率，这有利于我们做版本兼容，必要的时候可以对古早版本使用者溯源。</p><span id="more"></span><h2 id="二、问题"><a href="#二、问题" class="headerlink" title="二、问题"></a>二、问题</h2><p>需求似乎很简单，但真要获取自身的jar版本号还是挺麻烦的，有个比较简单但阴间的办法，就是给每一个组件都加上当前的jar版本号，写到配置文件里或者直接设置成常量，这样上报promethus时就可以直接获取到jar包版本号了，这个方法虽然可以解决问题，但每次迭代版本都要跟着改一遍所有组件包的版本号数据，过于麻烦。</p><p>有没有更好的解决办法呢？比如我们可不可以在gradle打包构建时拿到jar包的版本号，然后注入到每个组件中去呢？就像lombok那样，不需要写get、set方法，只需要加个注解标记就可以自动注入get、set方法。</p><p>比如我们可以给每个组件定义一个空常量，加上自定义的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TrisceliVersion</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">version</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure><p>然后像lombok生成set&#x2F;get方法那样注入真正的版本号：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TrisceliVersion</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">version</span> <span class="operator">=</span> <span class="string">&quot;1.0.31-SNAPSHOT&quot;</span>;</span><br></pre></td></tr></table></figure><p>参考lombok的实现，这其实是可以做到的，下面来看解决方案。</p><h2 id="三、解决"><a href="#三、解决" class="headerlink" title="三、解决"></a>三、解决</h2><p>java中解析一个注解的方式主要有两种：编译期扫描、运行期反射，这是lombok <code>@Setter</code>的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Setter &#123;</span><br><span class="line">  <span class="comment">// 略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>@Setter</code>的<code>Retention</code>是<code>SOURCE</code>类型的，也就是说这个注解只在编译期有效，它甚至不会被编入class文件，所以lombok无疑是第一种解析方式，那用什么方式可以在编译期就让注解被解析到并执行我们的解析代码呢？答案就是定义插入式注解处理器（通过JSR-269提案定义的<code>Pluggable Annotation Processing API</code>实现）</p><p>插入式注解处理器的触发点如下图所示：</p><p><img src="https://myblog.sharemer.com/2021/02/08/20210208-3-1.png?imageView2/0/w/950" alt="图3-1"></p><p>也就是说插入式注解处理器可以帮助我们在编译期修改抽象语法树（AST）！所以现在我们只需要自定义一个这样的处理器，然后其内部拿到jar版本信息（因为是编译期，可以找到源码的path，源码里随便搞个文件存放版本号，然后用java io读取进来即可），再将注解对应语法树上的常量值设置成jar包版本号，语法树变了，最终生成的字节码也会跟着变，这样就实现了我们想在编译期给常量version注入值的愿望。</p><p>自定义一个插入式注解处理器也很简单，首先要将自己的注解定义出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span> <span class="comment">//只在编译期有效，最终不会打进class文件中</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD&#125;)</span> <span class="comment">//仅允许作用于类属性之上</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TrisceliVersion &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义一个继承了<code>AbstractProcessor</code>的处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> AbstractProcessor&#125; 就属于 Pluggable Annotation Processing API</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrisceliVersionProcessor</span> <span class="keyword">extends</span> <span class="title class_">AbstractProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JavacTrees javacTrees;</span><br><span class="line">    <span class="keyword">private</span> TreeMaker treeMaker;</span><br><span class="line">    <span class="keyword">private</span> ProcessingEnvironment processingEnv;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化处理器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> processingEnv 提供了一系列的实用工具</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ProcessingEnvironment processingEnv)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.init(processingEnv);</span><br><span class="line">        <span class="built_in">this</span>.processingEnv = processingEnv;</span><br><span class="line">        <span class="built_in">this</span>.javacTrees = JavacTrees.instance(processingEnv);</span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> ((JavacProcessingEnvironment) processingEnv).getContext();</span><br><span class="line">        <span class="built_in">this</span>.treeMaker = TreeMaker.instance(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> SourceVersion <span class="title function_">getSupportedSourceVersion</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SourceVersion.latest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;String&gt; <span class="title function_">getSupportedAnnotationTypes</span><span class="params">()</span> &#123;</span><br><span class="line">        HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        set.add(TrisceliVersion.class.getName()); <span class="comment">// 支持解析的注解</span></span><br><span class="line">        <span class="keyword">return</span> set;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (TypeElement t : annotations) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Element e : roundEnv.getElementsAnnotatedWith(t)) &#123; <span class="comment">// 获取到给定注解的element（element可以是一个类、方法、包等）</span></span><br><span class="line">                <span class="comment">// JCVariableDecl为字段/变量定义语法树节点</span></span><br><span class="line">                JCTree.<span class="type">JCVariableDecl</span> <span class="variable">jcv</span> <span class="operator">=</span> (JCTree.JCVariableDecl) javacTrees.getTree(e);</span><br><span class="line">                <span class="type">String</span> <span class="variable">varType</span> <span class="operator">=</span> jcv.vartype.type.toString();</span><br><span class="line">                <span class="keyword">if</span> (!<span class="string">&quot;java.lang.String&quot;</span>.equals(varType)) &#123; <span class="comment">// 限定变量类型必须是String类型，否则抛异常</span></span><br><span class="line">                    printErrorMessage(e, <span class="string">&quot;Type &#x27;&quot;</span> + varType + <span class="string">&quot;&#x27;&quot;</span> + <span class="string">&quot; is not support.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                jcv.init = treeMaker.Literal(getVersion()); <span class="comment">// 给这个字段赋值，也就是getVersion的返回值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 利用processingEnv内的Messager对象输出一些日志</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e element</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m error message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printErrorMessage</span><span class="params">(Element e, String m)</span> &#123;</span><br><span class="line">        processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, m, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getVersion</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取version，这里省略掉复杂的代码，直接返回固定值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;v1.0.1&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>定义好的处理器需要<code>SPI机制</code>被发现，所以需要定义<code>META.services</code>：</p><p><img src="https://myblog.sharemer.com/2021/02/08/20210208-3-2.png?imageView2/0/w/950" alt="图3-2"></p><h2 id="四、测试"><a href="#四、测试" class="headerlink" title="四、测试"></a>四、测试</h2><p>新建测试模块，引入刚才写好的代码包：</p><p><img src="https://myblog.sharemer.com/2021/02/08/20210208-3-3.png?imageView2/0/w/980" alt="图4-1"></p><p>这是Test类：</p><p><img src="https://myblog.sharemer.com/2021/02/08/20210208-4-2.png?imageView2/0/w/800" alt="图4-2"></p><p>现在我们只需要让gradle build一下，新得到的字节码中该字段就有值了：</p><p><img src="https://myblog.sharemer.com/2021/02/08/20210208-4-3.png?imageView2/0/w/800" alt="图4-3"></p><p>这只是<code>插入式注解处理器</code>功能的冰山一角，既然它可以通过修改抽象语法树来控制生成的字节码，那么自然就有人能充分利用其特性来实现一些很酷的插件，比如lombok，我们再也不用写诸如set&#x2F;get这种模板式的代码了，只要我们足够有创意，就可以让基于这一套API实现的插件在功能上有很大的发挥空间。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;插入式注解处理器在《深入理解Java虚拟机》一书中有一些介绍（前端编译篇有提到），但一直没有机会使用，直到碰到这个需求，觉得再合适不过了，就简单用了一下，这里做个记录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、需求&quot;&gt;&lt;a href=&quot;#一、需求&quot; class=&quot;headerlink&quot; title=&quot;一、需求&quot;&gt;&lt;/a&gt;一、需求&lt;/h2&gt;&lt;p&gt;我们为公司提供了一套通用的JAVA基础组件包，组件包内有不同的模块，比如熔断模块、负载均模块、rpc模块等等，这些模块均会被打成jar包，然后发布到公司的内部代码仓库中，供其他人引入使用。&lt;/p&gt;
&lt;p&gt;这份代码会不断的迭代，我们希望可以通过&lt;code&gt;promethus&lt;/code&gt;来监控现在公司内使用各版本代码库的比例，希望达到的效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://myblog.sharemer.com/2021/02/08/20210208-1.png?imageView2/0/w/600&quot; alt=&quot;图1-1&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们希望看到每一个版本的使用率，这有利于我们做版本兼容，必要的时候可以对古早版本使用者溯源。&lt;/p&gt;</summary>
    
    
    
    <category term="JVM" scheme="http://example.com/categories/JVM/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
    <category term="注解处理器" scheme="http://example.com/tags/%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>分布式任务调度系统-PowerJob</title>
    <link href="http://example.com/2020/09/03/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F-PowerJob/"/>
    <id>http://example.com/2020/09/03/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F-PowerJob/</id>
    <published>2020-09-03T04:12:00.000Z</published>
    <updated>2023-12-03T11:18:50.492Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在调研分布式任务如何选型，最终选择了比较年轻的<code>PowerJob</code>，下面会简单介绍下这个框架的使用以及它的运行流程。</p></blockquote><span id="more"></span><h2 id="一、选择PowerJob的原因"><a href="#一、选择PowerJob的原因" class="headerlink" title="一、选择PowerJob的原因"></a>一、选择PowerJob的原因</h2><h3 id="1-1：同类产品对比"><a href="#1-1：同类产品对比" class="headerlink" title="1.1：同类产品对比"></a>1.1：同类产品对比</h3><p><a href="https://www.yuque.com/powerjob/guidence/ztn4i5">官方文档</a>给出的同类产品对比图：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-1.png?imageView2/0/w/846" alt="表1"></p><blockquote><p>作者の人生经验：<a href="https://zhuanlan.zhihu.com/p/157614020">https://zhuanlan.zhihu.com/p/157614020</a></p></blockquote><h3 id="1-2：特点"><a href="#1-2：特点" class="headerlink" title="1.2：特点"></a>1.2：特点</h3><p>定制方面：代码较简单，易于理解和改造，比如我们就集成了自己的服务发现平台来管理powerjob服务端节点。</p><p>功能方面：很全面，我们能想到的功能它全部支持</p><p>体积方面：非常轻量，代码量少，而且不依赖外部乱七八糟的服务（比如zk），仅需要一个mysql即可</p><h3 id="1-3：成熟度"><a href="#1-3：成熟度" class="headerlink" title="1.3：成熟度"></a>1.3：成熟度</h3><p>产品上线仅3个月，已积累<code>1.8k</code>的star：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-2.png" alt="图1"></p><p>并且已有较大的公司和机构接入：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-3.png?imageView2/0/w/500" alt="图2"></p><h2 id="二、PowerJob的工作流程"><a href="#二、PowerJob的工作流程" class="headerlink" title="二、PowerJob的工作流程"></a>二、PowerJob的工作流程</h2><h3 id="2-1：基本概念：app、worker、job、server"><a href="#2-1：基本概念：app、worker、job、server" class="headerlink" title="2.1：基本概念：app、worker、job、server"></a>2.1：基本概念：app、worker、job、server</h3><p>app可以理解为我们的一个工程项目，worker可以理解成一个app的集群节点，而job则是一个任务（可以是简单的定时任务，也可以是复杂的MapReduce），它跟具体某个app对应，而一个app则可以拥有很多job，它们的关系如下：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-4.png?imageView2/0/w/600" alt="图3"></p><p>server即为PowerJob节点，主要负责任务的监听和派发，可以单点部署，也可以集群部署，它的工作流程详细参考<code>2.2</code>和<code>2.3</code></p><h3 id="2-2：app-server的绑定"><a href="#2-2：app-server的绑定" class="headerlink" title="2.2：app&amp;server的绑定"></a>2.2：app&amp;server的绑定</h3><p>首先，在worker里配置上所需的server节点信息（这些节点信息也可以从服务发现获取），在worker启动时会注册到server，此时server便拥有了所有app的worker信息：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-5.png?imageView2/0/w/1124" alt="图4"></p><p>这层绑定关系在worker们启动后即可确认，这时worker端会启动两个定时任务，一个是heartbeat，用来给server端发送心跳，这样server端即可知道对应app有多少个worker在运行了，另外一个是discovery，用来同步server端状态，如果有备份server，可以用来做高可用。</p><p>图里powerjob服务端是单点部署，这不高可用，下面来看下powerjob是如何实现服务高可用的。</p><h3 id="2-3：高可用"><a href="#2-3：高可用" class="headerlink" title="2.3：高可用"></a>2.3：高可用</h3><p>2.2的过程运转的不错，但是如果server端故障，那么所有的任务将直接终止无法执行，这是我们不愿意看到的，因此需要给powerjob备份一个节点，假设现在它有两个节点，那么当单点故障时，powerjob会通过discovery机制做故障转移：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-6.png?imageView2/0/w/1200" alt="图5"></p><p>我们目前基于集群部署，一般有3台机器，一台<code>master</code>，两台<code>slave</code>。</p><h3 id="2-4：server端的调度"><a href="#2-4：server端的调度" class="headerlink" title="2.4：server端的调度"></a>2.4：server端的调度</h3><p>说完了整体的绑定流程，下面来详细看下server端是如何轮询和派发任务的：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-7.png?imageView2/0/w/1024" alt="图6"></p><h3 id="2-5：部署顺序"><a href="#2-5：部署顺序" class="headerlink" title="2.5：部署顺序"></a>2.5：部署顺序</h3><ol><li>部署PowerJob的server端（这个一般情况下都预先部署好了）</li><li>编写自己的job类app项目，写好各类job，在自身配置文件里指定一个server来调度自己</li><li>前往PowerJob客户端注册该app信息</li><li>启动发布该app项目（此时app集群会跟对应的server绑定上）</li><li>在PowerJob客户端利用该app登录，将该app里的job配置上去（此时便可指定cron表达式、并发度、是否mapreduce之类的信息）</li></ol><p>经过上面的步骤，你在app内编写的job程序便可被对应的PowerJob的server调度到了，不过上面的过程是裸用powerjob时需要做的，现在已经被我们大仓简化了，具体用法会出使用文档。</p><h2 id="三、任务类型-验证"><a href="#三、任务类型-验证" class="headerlink" title="三、任务类型&amp;验证"></a>三、任务类型&amp;验证</h2><h3 id="3-1：如何定义PowerJob任务"><a href="#3-1：如何定义PowerJob任务" class="headerlink" title="3.1：如何定义PowerJob任务"></a>3.1：如何定义PowerJob任务</h3><p>任务类必须要实现powerjob提供的一些接口，它们继承关系图如下：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-8.png?imageView2/0/w/900" alt="图7"></p><p>业务方只需要继承（实现）这些类（接口）即可，powerjob在执行任务时会率先从spring上下文里获取实例，如果你没使用spring，那么powerjob就会利用反射机制来触发你的业务逻辑（这在下方具体实例中有所体现，表单里填写的是类的全限定名）。</p><h3 id="3-1：任务类型-单机任务"><a href="#3-1：任务类型-单机任务" class="headerlink" title="3.1：任务类型-单机任务"></a>3.1：任务类型-单机任务</h3><p>这种就是普通定期执行的任务，属于最常用最普通的任务，现在来做下测试，测试用例代码如下：</p><figure class="highlight java"><figcaption><span>代码块1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StandaloneProcessor</span> <span class="keyword">implements</span> <span class="title class_">BasicProcessor</span> &#123; <span class="comment">//实现BasicProcessor接口</span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ProcessResult <span class="title function_">process</span><span class="params">(TaskContext context)</span> &#123; <span class="comment">//核心触发逻辑</span></span><br><span class="line">        log.info(<span class="string">&quot;简单定时任务-触发！，参数是：&#123;&#125;&quot;</span>, context.getJobParams());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProcessResult</span>(<span class="literal">true</span>, context + <span class="string">&quot;: &quot;</span> + <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将我们的job发布，发布完成后在powerjob平台对应app下配置该任务的调度信息：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-9.png?imageView2/0/w/900" alt="图8"></p><p>配好之后就可以运行我们的job了，来看看日志平台的打印：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-10.png?imageView2/0/w/900" alt="图9"></p><h3 id="3-2：任务类型-广播任务"><a href="#3-2：任务类型-广播任务" class="headerlink" title="3.2：任务类型-广播任务"></a>3.2：任务类型-广播任务</h3><h4 id="3-2-1：广播任务改造"><a href="#3-2-1：广播任务改造" class="headerlink" title="3.2.1：广播任务改造"></a>3.2.1：广播任务改造</h4><p>将上面的任务改成广播模式：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-11.png?imageView2/0/w/900" alt="图10"></p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-12.png?imageView2/0/w/900" alt="图11"></p><p>其实就是由原先单机触发，广播给worker集群里每个节点都触发一次。</p><h4 id="3-2-2：广播模式接口实现"><a href="#3-2-2：广播模式接口实现" class="headerlink" title="3.2.2：广播模式接口实现"></a>3.2.2：广播模式接口实现</h4><p>实例代码如下：</p><figure class="highlight java"><figcaption><span>代码块2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BroadcastProcessorDemo</span> <span class="keyword">extends</span> <span class="title class_">BroadcastProcessor</span> &#123; <span class="comment">//继承BroadcastProcessor类</span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ProcessResult <span class="title function_">preProcess</span><span class="params">(TaskContext context)</span> <span class="keyword">throws</span> Exception &#123; <span class="comment">//在所有节点广播执行前执行，只会在一台机器执行一次</span></span><br><span class="line">        log.info(<span class="string">&quot;广播前，参数：&#123;&#125;&quot;</span>, context.getJobParams());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProcessResult</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ProcessResult <span class="title function_">process</span><span class="params">(TaskContext taskContext)</span> <span class="keyword">throws</span> Exception &#123; <span class="comment">//核心逻辑，会广播给所有节点并行处理</span></span><br><span class="line">        log.info(<span class="string">&quot;广播核心逻辑触发！参数：&#123;&#125;&quot;</span>, taskContext.getJobParams());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProcessResult</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ProcessResult <span class="title function_">postProcess</span><span class="params">(TaskContext context, List&lt;TaskResult&gt; taskResults)</span> <span class="keyword">throws</span> Exception &#123; <span class="comment">//在所有节点广播执行完成后执行，只会在一台机器执行一次</span></span><br><span class="line">        <span class="comment">//通知执行结果，有点类似下面要测试的MapReduce的reduce方法</span></span><br><span class="line">        log.info(<span class="string">&quot;广播任务执行完毕，reduce触发！TaskContext: &#123;&#125;，List&lt;TaskResult&gt;: &#123;&#125;&quot;</span>,</span><br><span class="line">            JSONObject.toJSONString(context), JSONObject.toJSONString(taskResults));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProcessResult</span>(<span class="literal">true</span>, <span class="string">&quot;success&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在powerjob设置该任务：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-13.png?imageView2/0/w/900" alt="图12"></p><p>运行结果如下：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-14.png?imageView2/0/w/900" alt="图13"></p><p>广播模式执行流程如下（可以跟下方的MapReduce模式坐下对比）：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-15.png?imageView2/0/w/900" alt="图14"></p><h3 id="3-3：任务类型-Map（大任务拆分）"><a href="#3-3：任务类型-Map（大任务拆分）" class="headerlink" title="3.3：任务类型-Map（大任务拆分）"></a>3.3：任务类型-Map（大任务拆分）</h3><p>map就是一次大的任务可以被拆分成细碎的小批次任务进行分布式执行，测试用例代码如下：</p><figure class="highlight java"><figcaption><span>代码块3</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapProcessorDemo</span> <span class="keyword">extends</span> <span class="title class_">MapProcessor</span> &#123; <span class="comment">//继承MapProcessor</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">batchSize</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">//单批发送数据量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">batchNum</span> <span class="operator">=</span> <span class="number">2</span>; <span class="comment">//一共2批，默认上限为200批，再多就要适当调整batchSize大小了</span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ProcessResult <span class="title function_">process</span><span class="params">(TaskContext context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (isRootTask()) &#123; <span class="comment">//如果是根任务（说明map刚被调度到），则触发任务拆分</span></span><br><span class="line">            log.info(<span class="string">&quot;根任务，需要做任务拆分~&quot;</span>);</span><br><span class="line">            List&lt;SubTask&gt; subTasks = Lists.newLinkedList();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; batchNum; j++) &#123;</span><br><span class="line">                <span class="type">SubTask</span> <span class="variable">subTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubTask</span>();</span><br><span class="line">                subTask.siteId = j;</span><br><span class="line">                subTask.itemIds = Lists.newLinkedList();</span><br><span class="line">                subTasks.add(subTask); <span class="comment">//批次入集合</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; batchSize; i++) &#123; <span class="comment">//内部id集合，这里只是举例，实际业务场景可以是从db里获取的业务id集合</span></span><br><span class="line">                    subTask.itemIds.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> map(subTasks, <span class="string">&quot;MAP_TEST_TASK&quot;</span>); <span class="comment">//最后调用map，触发这些批次任务的执行</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//子任务，说明批次已做过拆分，此时被调度到时会触发下方逻辑</span></span><br><span class="line">            <span class="type">SubTask</span> <span class="variable">subTask</span> <span class="operator">=</span> (SubTask) context.getSubTask(); <span class="comment">//直接从上下文对象里拿到批次对象</span></span><br><span class="line">            log.info(<span class="string">&quot;子任务，拿到的批次实体为：&#123;&#125;&quot;</span>, JSON.toJSONString(subTask));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProcessResult</span>(<span class="literal">true</span>, <span class="string">&quot;RESULT:true&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SubTask</span> &#123; <span class="comment">//定义批次实体（业务方可自由发挥）</span></span><br><span class="line">        <span class="keyword">private</span> Integer siteId; <span class="comment">//批次id</span></span><br><span class="line">        <span class="keyword">private</span> List&lt;Integer&gt; itemIds; <span class="comment">//批次内部所携带的id（可以是我们自己的业务id）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码意义注释已给出，发布完成后可在powerjob平台配置，如下：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-16.png?imageView2/0/w/900" alt="图15"></p><p>然后看下运行结果：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-17-1.png?imageView2/0/w/900" alt="图16"></p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-17.png?imageView2/0/w/900" alt="图17"></p><p>上面就是一次map任务触发的演示过程（注：被拆分的map子任务只要有一个失败，即认为整个map任务为失败状态，但不具备事务性）。</p><p>Map任务执行流程如下：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-18.png?imageView2/0/w/500" alt="图18"></p><h3 id="3-4：任务类型-MapReduce（大任务拆分与归并）"><a href="#3-4：任务类型-MapReduce（大任务拆分与归并）" class="headerlink" title="3.4：任务类型-MapReduce（大任务拆分与归并）"></a>3.4：任务类型-MapReduce（大任务拆分与归并）</h3><p>相比普通map，MapReduce在子任务执行完毕后可以知道它们的执行结果，并做出接下来的自定义逻辑处理，测试用例代码如下：</p><figure class="highlight java"><figcaption><span>代码块4</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapReduceProcessorDemo</span> <span class="keyword">extends</span> <span class="title class_">MapReduceProcessor</span> &#123; <span class="comment">//需要继承MapReduceProcessor</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">batchSize</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">batchNum</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ProcessResult <span class="title function_">process</span><span class="params">(TaskContext context)</span> &#123; <span class="comment">//该方法跟普通map方法实现一致，主要用来拆分子任务和执行子任务</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (isRootTask()) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;根任务，需要做任务拆分~&quot;</span>);</span><br><span class="line">            List&lt;SubTask&gt; subTasks = Lists.newLinkedList();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; batchNum; j++) &#123;</span><br><span class="line">                <span class="type">SubTask</span> <span class="variable">subTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubTask</span>();</span><br><span class="line">                subTask.siteId = j;</span><br><span class="line">                subTask.itemIds = Lists.newLinkedList();</span><br><span class="line">                subTasks.add(subTask); <span class="comment">//批次入集合</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; batchSize; i++) &#123;</span><br><span class="line">                    subTask.itemIds.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> map(subTasks, <span class="string">&quot;MAP_TEST_TASK&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">SubTask</span> <span class="variable">subTask</span> <span class="operator">=</span> (SubTask) context.getSubTask();</span><br><span class="line">            log.info(<span class="string">&quot;子任务，拿到的批次实体为：&#123;&#125;&quot;</span>, JSON.toJSONString(subTask));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProcessResult</span>(<span class="literal">true</span>, <span class="string">&quot;RESULT:true&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ProcessResult <span class="title function_">reduce</span><span class="params">(TaskContext context, List&lt;TaskResult&gt; taskResults)</span> &#123; <span class="comment">//相比普通map任务，多出reduce方法，这里将两个参数全部打印出来</span></span><br><span class="line">        log.info(<span class="string">&quot;子任务执行完毕，reduce触发！TaskContext: &#123;&#125;，List&lt;TaskResult&gt;: &#123;&#125;&quot;</span>,</span><br><span class="line">            JSONObject.toJSONString(context), JSONObject.toJSONString(taskResults));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProcessResult</span>(<span class="literal">true</span>, <span class="string">&quot;RESULT:true&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SubTask</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Integer siteId;</span><br><span class="line">        <span class="keyword">private</span> List&lt;Integer&gt; itemIds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码意义注释已给出，发布完成后可在powerjob平台配置，如下：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-19.png?imageView2/0/w/900" alt="图19"></p><p>现在看下运行结果：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-20.png?imageView2/0/w/900" alt="图20"></p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-21.png?imageView2/0/w/900" alt="图21"></p><p>MapReduce的运行流程如下：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-22.png?imageView2/0/w/900" alt="图22"></p><h3 id="3-5：工作流"><a href="#3-5：工作流" class="headerlink" title="3.5：工作流"></a>3.5：工作流</h3><p>工作量，顾名思义，遵循<code>任务A → 任务B → 任务C</code>这个流程，只需要在表单里选中下方选项即可将任务本身设置成一个工作流任务：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-23.png?imageView2/0/w/900" alt="图23"></p><p>需要注意的是，工作流有自己的调度触发器，因此后面框框即便填了CRON表达式，也不会生效。</p><p>现在让我们将前面实验中的所有任务都设置成工作流模式：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-24.png?imageView2/0/w/900" alt="图24"></p><p>现在去工作流编辑里编辑工作流触发顺序：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-25.png?imageView2/0/w/900" alt="图25"></p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-26.png?imageView2/0/w/900" alt="图26"></p><p>任务按照编排好的顺序，执行了下来。</p><p>现在我们把工作流改成下面这样：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-27.png" alt="图27"></p><p>触发顺序就成了下面这样：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-28.png?imageView2/0/w/900" alt="图28"></p><h2 id="四、定时类型-验证"><a href="#四、定时类型-验证" class="headerlink" title="四、定时类型&amp;验证"></a>四、定时类型&amp;验证</h2><h3 id="4-1：CRON表达式"><a href="#4-1：CRON表达式" class="headerlink" title="4.1：CRON表达式"></a>4.1：CRON表达式</h3><p>前面的例子均通过该方式触发，支持一般CRON表达式，但是不支持秒级任务（即便配置了每秒执行一次，实际执行却是<code>15s</code>一次，秒级任务可以通过<code>固定频率</code>或<code>固定延迟</code>来做~），由CRON表达式触发的定时任务，在任务本身超时的情况下，仍然保持对应频率执行，比如，我们让某个简单定时任务每1min执行一次，但实际运行的业务逻辑调成2min，系统调度频率如下：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-29.png?imageView2/0/w/900" alt="图29"></p><p>可以看到，即便是任务需要花费很长时间，任务也是按照每一分钟一次的频率调度，但接下来介绍的延时任务就不一样了。</p><h3 id="4-2：固定频率"><a href="#4-2：固定频率" class="headerlink" title="4.2：固定频率"></a>4.2：固定频率</h3><p>如果你需要让某个任务按照固定某个频率执行，可以尝试使用固定频率来做：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-30.png?imageView2/0/w/900" alt="图30"></p><p>来看下它的调度结果：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-31.png" alt="图31"></p><h3 id="4-3：固定延迟"><a href="#4-3：固定延迟" class="headerlink" title="4.3：固定延迟"></a>4.3：固定延迟</h3><p>如果你需要让某个任务按照固定某个频率延迟执行，沿用<code>4.1</code>的例子，现在配置成延迟任务：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-32.png?imageView2/0/w/900" alt="图32"></p><p>它的调度结果如下：</p><p><img src="http://myblog.sharemer.com/2020/09/03/20200903-1-33.png?imageView2/0/w/900" alt="图33"></p><p>可以看到，现在是2min调度一次，相比CRON和固定频率，这个调度是串行化的，后续的任务需要前面的任务执行完才可以执行。</p><h2 id="五、其他"><a href="#五、其他" class="headerlink" title="五、其他"></a>五、其他</h2><h3 id="5-1：任务表单"><a href="#5-1：任务表单" class="headerlink" title="5.1：任务表单"></a>5.1：任务表单</h3><p>如果对创建任务时表单的每一项不是很了解，请参考官方文档：<a href="https://www.yuque.com/powerjob/guidence/nyio9g#v8uF4">https://www.yuque.com/powerjob/guidence/nyio9g#v8uF4</a></p><h3 id="5-2：如何配置工作流？"><a href="#5-2：如何配置工作流？" class="headerlink" title="5.2：如何配置工作流？"></a>5.2：如何配置工作流？</h3><p>参考文档：<a href="https://www.yuque.com/powerjob/guidence/ysug77#xgylz%EF%BC%88%E4%B8%8D%E5%A4%AA%E5%A5%BD%E7%94%A8%EF%BC%8C%E7%94%A8%E7%9A%84%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%EF%BC%89">https://www.yuque.com/powerjob/guidence/ysug77#xgylz（不太好用，用的时候需要注意）</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近在调研分布式任务如何选型，最终选择了比较年轻的&lt;code&gt;PowerJob&lt;/code&gt;，下面会简单介绍下这个框架的使用以及它的运行流程。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="服务治理" scheme="http://example.com/categories/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    
    
    <category term="分布式任务调度" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/"/>
    
    <category term="PowerJob" scheme="http://example.com/tags/PowerJob/"/>
    
  </entry>
  
  <entry>
    <title>WRR算法验证实验</title>
    <link href="http://example.com/2020/08/28/WRR%E7%AE%97%E6%B3%95%E9%AA%8C%E8%AF%81%E5%AE%9E%E9%AA%8C/"/>
    <id>http://example.com/2020/08/28/WRR%E7%AE%97%E6%B3%95%E9%AA%8C%E8%AF%81%E5%AE%9E%E9%AA%8C/</id>
    <published>2020-08-28T03:21:00.000Z</published>
    <updated>2023-12-04T01:26:15.377Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、实验整理"><a href="#一、实验整理" class="headerlink" title="一、实验整理"></a>一、实验整理</h2><h3 id="1-1：实验服务情报"><a href="#1-1：实验服务情报" class="headerlink" title="1.1：实验服务情报"></a>1.1：实验服务情报</h3><p>参与实验的服务与集群配置，和P2C验证实验里的一致，请参考：<a href="https://exceting.github.io/2020/08/25/P2C%E7%AE%97%E6%B3%95%E9%AA%8C%E8%AF%81%E5%AE%9E%E9%AA%8C/">P2C算法验证实验</a></p><span id="more"></span><h3 id="1-2：实验case整理"><a href="#1-2：实验case整理" class="headerlink" title="1.2：实验case整理"></a>1.2：实验case整理</h3><h4 id="1-2-1：各节点权重值一致"><a href="#1-2-1：各节点权重值一致" class="headerlink" title="1.2.1：各节点权重值一致"></a>1.2.1：各节点权重值一致</h4><p>场景：节点权重值均为10，比例为1:1</p><p>预期：流量均匀分配</p><h4 id="1-2-2：各节点权重值均不一致"><a href="#1-2-2：各节点权重值均不一致" class="headerlink" title="1.2.2：各节点权重值均不一致"></a>1.2.2：各节点权重值均不一致</h4><p>场景：6个节点权重值分别为：10、20、30、40、50、60</p><p>预期：流量分配按照权重值从大到小逐级递减</p><h4 id="1-2-3：各节点整体权重比例1-2"><a href="#1-2-3：各节点整体权重比例1-2" class="headerlink" title="1.2.3：各节点整体权重比例1:2"></a>1.2.3：各节点整体权重比例1:2</h4><p>场景：6个节点中，3个权重值为10，另外3个权重值为20</p><p>预期：权重值为20的3个节点qps比权重为10的3个节点多出一倍</p><h4 id="1-2-4：中途节点变更"><a href="#1-2-4：中途节点变更" class="headerlink" title="1.2.4：中途节点变更"></a>1.2.4：中途节点变更</h4><p>场景：在旧节点均为10的基础上灰度新节点</p><p>预期：新节点被引入，但qps不如旧节点高，最终全部接流后达到新的平衡，且qps一致。</p><h2 id="二、实验结果"><a href="#二、实验结果" class="headerlink" title="二、实验结果"></a>二、实验结果</h2><h3 id="2-1：各节点权重值一致"><a href="#2-1：各节点权重值一致" class="headerlink" title="2.1：各节点权重值一致"></a>2.1：各节点权重值一致</h3><p>可以看到，在各节点权重值一致时，流量分配极度均匀，符合预期。</p><p><img src="http://myblog.sharemer.com/2020/08/28/20200828-1-1.png?imageView2/0/w/1024" alt="图1"></p><h3 id="2-2：各节点权重值均不一致"><a href="#2-2：各节点权重值均不一致" class="headerlink" title="2.2：各节点权重值均不一致"></a>2.2：各节点权重值均不一致</h3><p>共6个节点，当配置权重值为10、20、30、40、50、60时，则流量分配按照权重值从大到小逐级递减，测试结果如下图，符合预期。</p><p><img src="http://myblog.sharemer.com/2020/08/28/20200828-1-2.png?imageView2/0/w/1024" alt="图2"></p><h3 id="2-3：各节点整体权重比例1-2"><a href="#2-3：各节点整体权重比例1-2" class="headerlink" title="2.3：各节点整体权重比例1:2"></a>2.3：各节点整体权重比例1:2</h3><p>6个节点中，3个权重值为10，另外3个权重值为20，测试结果如下图，流量比例1:2，符合预期。</p><p><img src="http://myblog.sharemer.com/2020/08/28/20200828-1-3.png?imageView2/0/w/1024" alt="图3"></p><h3 id="2-4：中途节点变更"><a href="#2-4：中途节点变更" class="headerlink" title="2.4：中途节点变更"></a>2.4：中途节点变更</h3><p>权重值均为10，后期滚动发版service，效果如下图，符合预期。</p><p><img src="http://myblog.sharemer.com/2020/08/28/20200828-1-4.png?imageView2/0/w/1024" alt="图4"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、实验整理&quot;&gt;&lt;a href=&quot;#一、实验整理&quot; class=&quot;headerlink&quot; title=&quot;一、实验整理&quot;&gt;&lt;/a&gt;一、实验整理&lt;/h2&gt;&lt;h3 id=&quot;1-1：实验服务情报&quot;&gt;&lt;a href=&quot;#1-1：实验服务情报&quot; class=&quot;headerlink&quot; title=&quot;1.1：实验服务情报&quot;&gt;&lt;/a&gt;1.1：实验服务情报&lt;/h3&gt;&lt;p&gt;参与实验的服务与集群配置，和P2C验证实验里的一致，请参考：&lt;a href=&quot;https://exceting.github.io/2020/08/25/P2C%E7%AE%97%E6%B3%95%E9%AA%8C%E8%AF%81%E5%AE%9E%E9%AA%8C/&quot;&gt;P2C算法验证实验&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="服务治理" scheme="http://example.com/categories/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    
    
    <category term="负载均衡" scheme="http://example.com/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
    <category term="服务治理" scheme="http://example.com/tags/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>P2C算法验证实验</title>
    <link href="http://example.com/2020/08/25/P2C%E7%AE%97%E6%B3%95%E9%AA%8C%E8%AF%81%E5%AE%9E%E9%AA%8C/"/>
    <id>http://example.com/2020/08/25/P2C%E7%AE%97%E6%B3%95%E9%AA%8C%E8%AF%81%E5%AE%9E%E9%AA%8C/</id>
    <published>2020-08-25T03:00:00.000Z</published>
    <updated>2023-12-05T03:01:07.692Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇文档是针对前篇<a href="https://exceting.github.io/2020/08/13/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-P2C%E7%AE%97%E6%B3%95/">负载均衡-P2C算法</a>进行的实验验证，会利用一个<code>网关</code>和一个<code>服务端</code>的<code>集群</code>来验证P2C在各个业务场景下的表现。</p></blockquote><span id="more"></span><h2 id="一、实验整理"><a href="#一、实验整理" class="headerlink" title="一、实验整理"></a>一、实验整理</h2><h3 id="1-1：实验服务情报"><a href="#1-1：实验服务情报" class="headerlink" title="1.1：实验服务情报"></a>1.1：实验服务情报</h3><p>参与实验的是两套集群，分别是<code>网关系统</code>和<code>基础服务</code>，网关系统在接收到外部请求后会在grpc内部利用P2C算法pick出合适的基础服务节点发起调用，网关系统拥有1台机器，基础服务集群拥有6台机器，初始权重值都是10，如图：</p><p><img src="http://myblog.sharemer.com/2020/08/25/20200825-1-1.png?imageView2/0/w/900" alt="图1"></p><h3 id="1-2：实验case整理"><a href="#1-2：实验case整理" class="headerlink" title="1.2：实验case整理"></a>1.2：实验case整理</h3><p>按照P2C算法的实现，参考<a href="https://exceting.github.io/2020/08/13/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-P2C%E7%AE%97%E6%B3%95/">负载均衡-P2C算法</a>中的<code>P2CLoadBalancer.pick</code>方法，负载率的完整计算方式如下：</p><p><img src="http://myblog.sharemer.com/2020/08/25/20200825-1-2.png?imageView2/0/w/450" alt="负载率的计算"></p><blockquote><p><em>ps：上述公式中参与运算的数据来源也已在<a href="https://exceting.github.io/2020/08/13/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-P2C%E7%AE%97%E6%B3%95/">负载均衡-P2C算法</a>中做过详细介绍，如忘记，可前往查看代码。</em></p></blockquote><h4 id="1-2-1：实验A组，无cpu使用率返回时"><a href="#1-2-1：实验A组，无cpu使用率返回时" class="headerlink" title="1.2.1：实验A组，无cpu使用率返回时"></a>1.2.1：实验A组，无cpu使用率返回时</h4><p>👾 解释：用来模拟对端不支持cpu使用率携带的情况，按照之前P2C算法的代码，此时cpu恒等于默认值500，因此整体负载率取决于其余几个属性。</p><table><thead><tr><th>操作</th><th>目的</th><th>预期</th></tr></thead><tbody><tr><td>正常请求</td><td>分母一致，看下流量分配是否均匀</td><td>6台机器的流量分配大致均匀</td></tr><tr><td>尝试调小其中一台weight的值</td><td>通过调小weight的值来增大其负载率</td><td>被降低weight的机器流量分配较其它几个节点明显降低</td></tr><tr><td>尝试让某台机器的请求错误量飙升</td><td>通过增大错误量来降低client_success的值，从而增大其负载率</td><td>错误率飙升的机器流量分配较其它几个节点明显降低，恢复后流量增大</td></tr></tbody></table><center>表1</center><h4 id="1-2-2：实验B组，有cpu返回，成功率和权重值一致"><a href="#1-2-2：实验B组，有cpu返回，成功率和权重值一致" class="headerlink" title="1.2.2：实验B组，有cpu返回，成功率和权重值一致"></a>1.2.2：实验B组，有cpu返回，成功率和权重值一致</h4><p>👾 解释：此时保持<code>client_success</code>和<code>weight</code>不变，专注分子对负载率的变化，在这种情况下，分母固定，负载率则完全取决于分子，分子越小，负载率越低，被pick的概率就越大。</p><table><thead><tr><th>操作</th><th>目的</th><th>预期</th></tr></thead><tbody><tr><td>正常请求</td><td>不干涉分子分母的情况下，看下流量分配是否均匀</td><td>6台机器的流量分配大致均匀</td></tr><tr><td>尝试调大其中一台机器的cpu使用率</td><td>让该机器分子变大，负载率变小</td><td>cpu使用率变大的机器分配到的流量明显低于其他几个节点，恢复后流量增大</td></tr><tr><td>尝试调大其中一台机器的延迟率</td><td>让该机器分子变大，负载率变小</td><td>延迟率变大的机器分配到的流量明显低于其他几个节点</td></tr><tr><td>尝试无脑增大某台机器的拥塞度</td><td>让该机器分子变大，负载率变小</td><td>拥塞度变大的机器分配到的流量明显低于其他几个节点</td></tr></tbody></table><center>表2</center><h4 id="1-2-3：实验C组，衰减值测试"><a href="#1-2-3：实验C组，衰减值测试" class="headerlink" title="1.2.3：实验C组，衰减值测试"></a>1.2.3：实验C组，衰减值测试</h4><p>👾 解释：调整<code>衰减值</code>（下称<code>k值</code>），查看衰减值对P2C的影响。</p><table><thead><tr><th>操作</th><th>目的</th><th>预期</th></tr></thead><tbody><tr><td>模拟某台机器某段时间内网络延迟</td><td>不干涉分子分母的情况下，看流量是否倾斜</td><td>存在网络延迟的节点流量分配明显低于其他几个节点</td></tr><tr><td>同上，但调整k的值</td><td>测试k值对P2C算法在网络延迟情况下的影响以及它的具体作用</td><td>k值越大，网络延迟恢复后流量分配恢复到正常水平的速度越慢，反之越快</td></tr></tbody></table><center>表3</center><h4 id="1-2-4：实验D组，中途节点变更"><a href="#1-2-4：实验D组，中途节点变更" class="headerlink" title="1.2.4：实验D组，中途节点变更"></a>1.2.4：实验D组，中途节点变更</h4><p>👾 解释：不干涉分子分母，中途发版，查看发版对P2C的影响。</p><table><thead><tr><th>操作</th><th>目的</th><th>预期</th></tr></thead><tbody><tr><td>中途发版</td><td>不干涉分子分母，中途发版，查看发版对P2C的影响</td><td>不影响性能，且新入的节点及时均摊流量</td></tr></tbody></table><center>表4</center><h2 id="二、实验结果"><a href="#二、实验结果" class="headerlink" title="二、实验结果"></a>二、实验结果</h2><p>👽 以下实验均通过ab压测进行，通过开启50个线程并发请求1000w次。</p><h3 id="2-1：实验组A-结论"><a href="#2-1：实验组A-结论" class="headerlink" title="2.1：实验组A-结论"></a>2.1：实验组A-结论</h3><h4 id="2-1-1：正常请求"><a href="#2-1-1：正常请求" class="headerlink" title="2.1.1：正常请求"></a>2.1.1：正常请求</h4><p>实验结果：基本符合预期，每个节点较均匀的访问，至于为什么黄色节点的qps比较低，因为它的平均耗时比较大（配合<code>图3</code>）。</p><p><img src="http://myblog.sharemer.com/2020/08/25/20200825-1-3.png?imageView2/0/w/1024" alt="图2"></p><p>节点平均耗时（将其作为<code>latency</code>代入之前的公式，基本符合上图的qps分配，即latency越小，被pick的概率越大）：</p><p><img src="http://myblog.sharemer.com/2020/08/25/20200825-1-4.png?imageView2/0/w/1024" alt="图3"></p><h4 id="2-1-2：调小其中一个节点的weight"><a href="#2-1-2：调小其中一个节点的weight" class="headerlink" title="2.1.2：调小其中一个节点的weight"></a>2.1.2：调小其中一个节点的weight</h4><p>将其中某个节点的权重改成<code>5</code>，其余仍为<code>10</code>，可以看到，权重值为5的节点（橙色线）qps相比其他权重值为10的节点，少了一半。</p><p><img src="http://myblog.sharemer.com/2020/08/25/20200825-1-5.png?imageView2/0/w/1024" alt="图4"></p><h4 id="2-1-3：尝试让某台机器的请求错误量飙升"><a href="#2-1-3：尝试让某台机器的请求错误量飙升" class="headerlink" title="2.1.3：尝试让某台机器的请求错误量飙升"></a>2.1.3：尝试让某台机器的请求错误量飙升</h4><p>让其中某个节点在某时刻故障，一段时间后恢复，测试结果如下图，可以看到，在某节点（橙色线）发生网络故障时，qps会以一定的速度下降，然后到达最低值（此时按照3s一次的概率被pick，可以理解成该节点当前处于”半熔断“状态），期间其他节点qps加大，故障恢复后，又以一定的速度恢复至原qps。</p><p><img src="http://myblog.sharemer.com/2020/08/25/20200825-1-6.png?imageView2/0/w/1024" alt="图5"></p><h3 id="2-2：实验组B-结论"><a href="#2-2：实验组B-结论" class="headerlink" title="2.2：实验组B-结论"></a>2.2：实验组B-结论</h3><h4 id="2-2-1：正常请求"><a href="#2-2-1：正常请求" class="headerlink" title="2.2.1：正常请求"></a>2.2.1：正常请求</h4><p>让对端传送cpu使用率，公式中的其余数据不做干涉，得出下图，跟<code>2.1.1</code>一致，大致平均：</p><p><img src="http://myblog.sharemer.com/2020/08/25/20200825-1-7.png?imageView2/0/w/1024" alt="图6"></p><p><img src="http://myblog.sharemer.com/2020/08/25/20200825-1-8.png?imageView2/0/w/1024" alt="图7"></p><h4 id="2-2-2：尝试调大其中一台机器的cpu使用率"><a href="#2-2-2：尝试调大其中一台机器的cpu使用率" class="headerlink" title="2.2.2：尝试调大其中一台机器的cpu使用率"></a>2.2.2：尝试调大其中一台机器的cpu使用率</h4><p>让其中某个节点在某时刻<code>cpu使用率</code>飙升，一段时间后恢复，测试结果如下图，可以看到，在某节点（黄色线）cpu使用率飙升时，qps会以一定的速度下降，然后到达最低值，期间其他节点qps加大，故障恢复后，又以一定的速度恢复至原qps。</p><p><img src="http://myblog.sharemer.com/2020/08/25/20200825-1-9.png?imageView2/0/w/1024" alt="图8"></p><h4 id="2-2-3：调大其中一台机器的延迟率"><a href="#2-2-3：调大其中一台机器的延迟率" class="headerlink" title="2.2.3：调大其中一台机器的延迟率"></a>2.2.3：调大其中一台机器的延迟率</h4><p>让其中某个节点在某时刻<code>延迟率</code>飙升，一段时间后恢复，测试结果如下图，可以看到，在某节点（橙色线）延迟率飙升时，qps会以一定的速度下降，然后到达最低值，期间其他节点qps加大，延迟恢复后，又以一定的速度恢复至原qps。</p><p><img src="http://myblog.sharemer.com/2020/08/25/20200825-1-10.png?imageView2/0/w/1024" alt="图9"></p><h4 id="2-2-4：调大其中一台机器的拥塞度"><a href="#2-2-4：调大其中一台机器的拥塞度" class="headerlink" title="2.2.4：调大其中一台机器的拥塞度"></a>2.2.4：调大其中一台机器的拥塞度</h4><p><code>省略...</code></p><p>不再实验，同样作为分子，调大和恢复它也一样能达到上图的效果。</p><h3 id="2-3：实验组C-结论"><a href="#2-3：实验组C-结论" class="headerlink" title="2.3：实验组C-结论"></a>2.3：实验组C-结论</h3><p>同样模拟网络延迟，此时让2个节点发生网络延迟，但是衰减值不同（橙色节点为5，青色节点使用600），可以看到，衰减值越大，感知问题的速度相对越慢，恢复速度也相对越慢。</p><p><img src="http://myblog.sharemer.com/2020/08/25/20200825-1-11.png?imageView2/0/w/1024" alt="图10"></p><h3 id="2-4：实验组D-结论"><a href="#2-4：实验组D-结论" class="headerlink" title="2.4：实验组D-结论"></a>2.4：实验组D-结论</h3><p>在service运行中灰度新节点（注：图中新节点被接入后qps明显比旧节点大的原因是新节点耗时明显更低，请结合<code>图12</code>看）</p><p><img src="http://myblog.sharemer.com/2020/08/25/20200825-1-12.png?imageView2/0/w/1024" alt="图11"></p><p><img src="http://myblog.sharemer.com/2020/08/25/20200825-1-13.png?imageView2/0/w/1024" alt="图12"></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本篇文档是针对前篇&lt;a href=&quot;https://exceting.github.io/2020/08/13/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-P2C%E7%AE%97%E6%B3%95/&quot;&gt;负载均衡-P2C算法&lt;/a&gt;进行的实验验证，会利用一个&lt;code&gt;网关&lt;/code&gt;和一个&lt;code&gt;服务端&lt;/code&gt;的&lt;code&gt;集群&lt;/code&gt;来验证P2C在各个业务场景下的表现。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="服务治理" scheme="http://example.com/categories/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    
    
    <category term="负载均衡" scheme="http://example.com/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
    <category term="服务治理" scheme="http://example.com/tags/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡-P2C算法</title>
    <link href="http://example.com/2020/08/13/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-P2C%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2020/08/13/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-P2C%E7%AE%97%E6%B3%95/</id>
    <published>2020-08-13T06:56:00.000Z</published>
    <updated>2023-12-04T02:31:41.341Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>P2C</code>算法全称<code>Pick of 2 choices</code>，相比<code>WRR</code>，P2C有着更科学的LB策略，它通过随机选择两个节点后在这俩节点里选择优胜者来避免<code>羊群效应</code>，并通过<code>指数加权移动平均算法</code>统计服务端的实时状态，从而做出最优选择。</p></blockquote><span id="more"></span><h2 id="一、工作流程"><a href="#一、工作流程" class="headerlink" title="一、工作流程"></a>一、工作流程</h2><p>P2C算法下的每个节点（下称<code>Node</code>）必须含有下方图中几个指标，它们的计算方法已经标出：</p><p><img src="http://myblog.sharemer.com/2020/08/13/20200813-1-1.png?imageView2/0/w/750" alt="图1"></p><p>因此最终loadbalancer里保存的节点就会变成下图的结构，pick节点时需要做如下比较：</p><p><img src="http://myblog.sharemer.com/2020/08/13/20200813-1-2.png?imageView2/0/w/800" alt="图2"></p><p>通过上面的流程可以看到，大体流程还是随机，相比普通的随机LB，它是随机选择两个node，然后比较它们的负载率，然后选出当前负载率最小的node。</p><h2 id="二、数据统计"><a href="#二、数据统计" class="headerlink" title="二、数据统计"></a>二、数据统计</h2><p>通过上面的简单介绍，可以知道P2C算法的大体流程，那么现在问题就变得简单多了，只需要知道<code>负载率</code>，就可以完成这个“简单”的负载均衡器，但是负载率是由上图<code>五个指标</code>共同参与计算完成的，那现在问题的关键就是如何完成这五个指标的统计，下面来介绍下这五个指标如何计算。</p><h3 id="2-1：weight"><a href="#2-1：weight" class="headerlink" title="2.1：weight"></a>2.1：weight</h3><p>这个很简单，主要是人为配置的定制，用于给不同的机器按照机器配置分配上不同的权重，权重越高，越容易被pick到。这个值可以做在服务注册与发现里，进行为每个节点分配一个权重值。</p><h3 id="2-2：server-cpu"><a href="#2-2：server-cpu" class="headerlink" title="2.2：server_cpu"></a>2.2：server_cpu</h3><p>这个值可以通过服务端回写元数据来搞定，比如一次请求：</p><p><img src="http://myblog.sharemer.com/2020/08/13/20200813-1-3.png?imageView2/0/w/800" alt="图3"></p><p>所以这个值可以通过服务端埋点的方式解决掉。</p><h3 id="2-3：inflight"><a href="#2-3：inflight" class="headerlink" title="2.3：inflight"></a>2.3：inflight</h3><p>这个代表节点请求<code>拥塞度</code>，代表着当前节点有多少个请求未完成或者正开始请求，它的统计也很简单：</p><p><img src="http://myblog.sharemer.com/2020/08/13/20200813-1-4.png?imageView2/0/w/800" alt="图4"></p><p>按照这种，每次pick到发送请求前先<code>原子+1</code>，response后说明一次请求完成，这时再<code>原子-1</code>，这样<code>一增一减</code>，在超多线程pick下（即高qps），当前线程获取到的<code>inflight</code>瞬间值，就是在这个时段的<code>拥塞度</code>，比如一个节点如果很闲，响应速度也快，那么它的拥塞度肯定极低（因为一增一减的操作很快就完成，不会淤积过多）。</p><h3 id="2-4：latency-client-success"><a href="#2-4：latency-client-success" class="headerlink" title="2.4：latency &amp; client_success"></a>2.4：latency &amp; client_success</h3><p>前面的都很好了理解，这俩属性比较麻烦，它们分别代表请求<code>延迟率</code>和<code>成功率</code>。</p><p>这俩值该怎么计算？一般来说是通过平均数的方式来计算，但计算平均数的方式有很多，可以先用我们最熟悉的算术平均数来计算，它的计算公式如下：</p><p><img src="http://myblog.sharemer.com/2020/08/13/gs1-m.png" alt="img"></p><p>利用此算法套入我们的场景后，请求总耗时比上请求总次数，就是latency：</p><p><img src="http://myblog.sharemer.com/2020/08/13/gs2-m.png" alt="img"></p><p>请求总成功数比上请求总次数，就是client_success：</p><p><img src="http://myblog.sharemer.com/2020/08/13/gs3-m.png" alt="img"></p><p>整个过程可以抽象成下面这样：</p><p><img src="http://myblog.sharemer.com/2020/08/13/20200813-1-7.png?imageView2/0/w/800" alt="图5"></p><p>根据<code>图5</code>的流程，可以通过每次请求，累加总请求数、总耗时、总成功数，然后利用<code>算术平均法</code>更新<code>latency</code>和<code>client_success</code>的值，这一切可以运作的很好，可是算术平均有个很大的缺陷，不够敏感，出现的网络波动一下就被平均了，是不是想到了你和马云放在一起统计资产时被平均的悲哀？</p><h4 id="2-4-1：算术平均数模拟"><a href="#2-4-1：算术平均数模拟" class="headerlink" title="2.4.1：算术平均数模拟"></a>2.4.1：算术平均数模拟</h4><p>首先模拟<code>1000次请求</code>，让每次请求在<code>0~25</code>之间产生随机数用来作为本次请求的耗时（为了模拟真实情况，让一些请求耗时过高），每次请求计算当前的算术平均数，然后可以得到下面的统计图：</p><p><img src="http://myblog.sharemer.com/2020/08/13/20200813-1-8.png?imageView2/0/w/900" alt="图6"></p><p>可以看到，正常情况下，算术平均数表现出很好的稳定性，红线一致维持在黑线的中间，且浮动不大。</p><p>现在让我们搞点事情，假设在第100次请求到第200次请求间，模拟下网络抖动，让这期间的响应时间变成125ms（相比正常情况翻<code>五倍</code>），得到统计图如下：</p><p><img src="http://myblog.sharemer.com/2020/08/13/20200813-1-9.png?imageView2/0/w/900" alt="图7"></p><p>可以看到平均数受到这次抖动的影响，需要非常长的时间才能感知到，恢复时又需要很长时间才能恢复到抖动前的较正常的水平。</p><p>也就是说，第100~200间的100次慢请求，不光要到140次请求后才能较明显的感知平均值的上涨，还导致网络恢复后，到第1000次请求时，平均值还没有恢复到正常水平（但其实从第200次请求后，响应时间就正常了），算术平均是所有数据的总平均，受过往值的影响非常深，以至于不能很好的反应某个时段的平均趋势，那么有没有更好的统计办法来避免这类问题呢？</p><h4 id="2-4-2：指数加权移动平均算法（EWMA）模拟"><a href="#2-4-2：指数加权移动平均算法（EWMA）模拟" class="headerlink" title="2.4.2：指数加权移动平均算法（EWMA）模拟"></a>2.4.2：指数加权移动平均算法（EWMA）模拟</h4><blockquote><p>参考资料：<a href="https://blog.csdn.net/m0_38106113/article/details/81542863">深入解析TensorFlow中滑动平均模型与代码实现</a></p></blockquote><p>公式如下：</p><p><img src="http://myblog.sharemer.com/2020/08/13/gs4-m.png" alt="img"></p><p>解释：<code>vt</code>代表第t次请求的指数加权平均耗时，<code>vt-1</code>代表上次请求的指数加权平均耗时，<code>θt</code>代表第t次请求的实际耗时。</p><p><code>β值</code>的定义如下：</p><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vt ≈ <span class="number">1</span>/(<span class="number">1</span> - β) 次的平均耗时</span><br></pre></td></tr></table></figure><p>例：假设β等于0.9，1&#x2F;(1 - β) 就等于10，vt约等于前10次请求的平均耗时；假设把β值调大至0.98，1&#x2F;(1-β)&#x3D;50，就是当前请求的前50次请求的平均耗时。</p><p>由此可以推导出：</p><p>β值越大，移动平均区间越大，当前平均值的计算受到之前平均值的影响也就越大</p><p>β值越小，移动平均区间越小，当前平均值的计算受到之前平均值的影响也就越小</p><p>eg：假设现在有两次请求，第一次耗时25ms，第二次耗时50ms，代入公式，计算出第一次和第二次的指数加权平均值为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">v1</span> <span class="operator">=</span> β * <span class="number">0</span> + (<span class="number">1</span> - β) * <span class="number">25</span></span><br><span class="line"><span class="type">double</span> <span class="variable">v2</span> <span class="operator">=</span> β * v1 + (<span class="number">1</span> - β) * <span class="number">50</span> <span class="comment">// β值越小，意味着本次请求的实际耗时占比越大，β值越大，之前计算得到的平均值占比越大</span></span><br></pre></td></tr></table></figure><p>这个结论在下面的实验中会有所体现。</p></blockquote><p>相比普通平均值的计算，EWMA算法更在乎<code>历史平均值</code>对统计结果的影响，通过控制β的值就可以调整历史均值对统计趋势的影响程度。</p><p>现在用EWMA模拟下1000次请求，为了模拟真实情况，我会让一些请求耗时过高，β取值<code>0.9</code>，代表最新请求时的平均值计算会受到最近<code>10次</code>耗时的影响进行平滑过渡，运行结果绘制如下图（渲染采用Echarts）：</p><p><img src="http://myblog.sharemer.com/2020/08/13/20200813-1-11.png?imageView2/0/w/900" alt="图8"></p><p>最终得到的数据曲线没有算术平均那么稳定，但可以看出，每次网络波动会提升其加权均值，不会像算术平均那样不受网络波动影响。</p><p>接下来假设第100~200次请求，发生了网络延迟，延时<code>5倍</code>，再次利用EWMA做下模拟：</p><p><img src="http://myblog.sharemer.com/2020/08/13/20200813-1-12.png?imageView2/0/w/900" alt="图9"></p><p>请将这张图跟<code>图7</code>进行对比，你会发现，利用指数加权平均算法计算出的平均值在网络恢复时，以极快的速度恢复到了正常水平。</p><p>相比算术平均，EWMA更重要的是它平滑的模拟了平均值的趋势。</p><p>现在把<code>图9</code>里的β值调整为0.98，此时在计算当前平均值时则受到前面(1&#x2F;0.02) &#x3D; 50个平均值的影响，便得到下图：</p><p><img src="http://myblog.sharemer.com/2020/08/13/20200813-1-13.png?imageView2/0/w/901" alt="图10"></p><p>因为β值变大，后续每个平均值都会受到更多历史均值的影响，而当前耗时仅占很少影响，跟之前的结论一样，β越大，移动窗口越大，当前平均数受到历史平均值的影响就越大，反之越小，所以相比<code>图9</code>，在出现网络抖动后，更缓慢的恢复为正常均值（波形跟算术平均接近）。</p><p>还可以将β调小试试，比如将其设为0.32，那么计算均值时仅受到前面(1&#x2F;0.68) &#x3D; 1.47个均值影响，此时平均值轨迹几乎和正常响应时间重叠：</p><p><img src="http://myblog.sharemer.com/2020/08/13/20200813-1-14.png?imageView2/0/w/900" alt="图11"></p><p>可以看到，当β很小时，受影响因子无限趋近于1，越趋近于1则越贴近原本值。</p><h4 id="2-4-3：结论"><a href="#2-4-3：结论" class="headerlink" title="2.4.3：结论"></a>2.4.3：结论</h4><table><thead><tr><th>实验组</th><th>对照组</th><th>目的</th><th>结论</th></tr></thead><tbody><tr><td>图6</td><td>图8（β&#x3D;0.9）</td><td>模拟网络正常情况下，两种算法对均值的统计区别</td><td>算术平均值非常稳定，对单次网络抖动完全无感知，EWMA均值则会随着响应时间动态变化，因此单次网络抖动后会稍微提升均值，之后便很快恢复</td></tr><tr><td>图7</td><td>图9（β&#x3D;0.9）</td><td>模拟一段网络延迟，看两种算法的均值变化</td><td>算术平均值会缓慢提升，之后再次以极慢的速度下降，对网络延迟反映迟钝，网络延迟结束后仍然要花很长时间才能恢复到正常均值水平，EWMA均值则迅速提升，恢复后迅速下降至正常水平</td></tr><tr><td>图9（β&#x3D;0.9）</td><td>图10（β&#x3D;0.98）</td><td>调大EWMA的β值</td><td>β值越大，每次计算均值时受到之前均值影响越大，则平均曲线更加平滑，因此<code>图10</code>的曲线要比<code>图9</code>表现更加平滑，但付出的代价是对网络延迟反应也变的迟钝</td></tr><tr><td>图9（β&#x3D;0.9）</td><td>图11（β&#x3D;0.32）</td><td>调小EWMA的β值</td><td>β值越小，每次计算均值时受到之前均值影响越小，则平均曲线更加趋近于每次的实际耗时，因此<code>图11</code>的曲线要比<code>图9</code>表现的更加趋近于每次的实际耗时，顺理成章的，它对网络延迟的反映极迅速</td></tr></tbody></table><center>表1</center><p>通过实验，可以看出EWMA的优势巨大，但β的取值需要仔细斟酌，若β太小，则无法很好的体现出平均值，若β太大，很好的体现了平均值，但对网络波动的反应相对迟钝，这里就考虑到一个折中的方案：</p><blockquote><p>实时调整β值，比如EWMA可以在网络波动时适当<code>降低β的值</code>，使其快速感知到波动的存在，当网络波动结束后，适当<code>提升β的值</code>，这样就可以在网络稳定的情况下较好的反映一个区段内的均值情况，这样等于结合了<code>图10</code>和<code>图11</code>各自的优点，实现后将达到一种效果：快速感知网络延迟并迅速提高其均值，当网络恢复后，慢慢降回正常水平（均值恢复需要慢慢进行，因为刚恢复的节点稳定性不可信，慢慢恢复到正常水平，以信任其稳定性）</p></blockquote><h4 id="2-4-4：利用衰减函数动态调整β值"><a href="#2-4-4：利用衰减函数动态调整β值" class="headerlink" title="2.4.4：利用衰减函数动态调整β值"></a>2.4.4：利用衰减函数动态调整β值</h4><p>通过上面的要求，我们需要完善这个变化的β，那么它该如何变化呢？如何能达到碰到网络波动时迅速感知，当波动过后慢慢恢复的效果呢？慢慢恢复需要多慢？可不可以通过调整某个阈值来控制恢复的速率？</p><p>带着上面的问题，需要了解一下：衰减函数（<a href="http://www.ruanyifeng.com/blog/2012/03/ranking_algorithm_newton_s_law_of_cooling.html">牛顿冷却定律</a>）</p><p>公式为：</p><p><img src="http://myblog.sharemer.com/2020/08/13/gs5-m.png" alt="img"></p><p><code>e</code>是常量，<code>Δt</code>表示第t次请求的耗时，<code>k</code>表示<code>衰减系数</code>，它的函数图如下：</p><p><img src="http://myblog.sharemer.com/2020/08/13/20200813-1-15.png" alt="图12"></p><p>我们把<code>k*Δt</code>看做<code>x的取值</code>，那么<code>k</code>和<code>Δt</code>成正比，即：<code>k</code>和<code>Δt</code>取值越大，β就越小</p><p>现在来看看这个结论支不支持我们要实现的功能：</p><ol><li>网络抖动时，假设<code>Δt</code>非常大，即便不乘<code>k值</code>，β值也会变得很小，这是符合我们预期的，我们需要的就是在网络抖动时，迅速感知</li><li>网络恢复时，<code>Δt</code>迅速降低，假设此时<code>Δt</code>非常小，则<code>k值</code>越大，<code>图12</code>里对应的<code>x</code>越大，β的值就越小，事实上通过实验可以得出，如果<code>k</code>值很大，得出的曲线近乎等于<code>图11</code>。</li></ol><p>经过上面的梳理，发现k值似乎没有起到衰减作用，反而因为它的存在导致β值降低，它的取值在网络抖动恢复后依旧在<code>削弱</code>β的值，导致网络恢复后迅速降低到正常水平，这是我们不愿意看到的，那么上面的函数需要做下变体，即让<code>Δt和k值成反比</code>即可：</p><p><img src="http://myblog.sharemer.com/2020/08/13/gs6-m.png" alt="img"></p><p>此时结论如下：</p><ol><li>网络抖动时，假设<code>Δt</code>非常大，即便<code>k值</code>起到中和作用，β值较之前也会明显变小，这是符合我们预期的，我们需要的就是在网络抖动时，迅速感知</li><li>网络恢复时，即使<code>Δt</code>迅速降低，那么由于<code>k值</code>的中和（<code>Δt/k</code>的值大小和<code>k值</code>成反比），k越大，β越大，则均值计算受之前波动期的均值影响越大，曲线恢复越缓慢。</li></ol><p>这点可以通过下方的验证得到证实，调整衰减系数k，的确可以控制在遇到波动时恢复到正常水平时的速度，衰减系数设置越大，波幅越大（恢复越慢），反之越小（恢复越快）。</p><h4 id="2-4-5：衰减系数验证"><a href="#2-4-5：衰减系数验证" class="headerlink" title="2.4.5：衰减系数验证"></a>2.4.5：衰减系数验证</h4><p>第一组：随机次数的网络抖动，衰减系数分别为<code>600</code>和<code>50</code></p><p><img src="http://myblog.sharemer.com/2020/08/13/20200813-1-16.png?imageView2/0/w/900" alt="衰减系数为600时的走势图，可以看出，网络恢复后均值变化衰减速度很慢"></p><p><img src="http://myblog.sharemer.com/2020/08/13/20200813-1-17.png?imageView2/0/w/900" alt="衰减系数为50时的走势图，可以看出，网络恢复后均值变化衰减速度很快"></p><p>第二组：第<code>100~200次</code>请求响应时间<code>扩大5倍</code>，衰减系数仍然是<code>600</code>和<code>50</code></p><p><img src="http://myblog.sharemer.com/2020/08/13/20200813-1-18.png?imageView2/0/w/900" alt="衰减系数为600时的走势图，可以看出在抖动发生时，仍然可以迅速感知，后续恢复时的衰减速度跟上面结果一样慢"></p><p><img src="http://myblog.sharemer.com/2020/08/13/20200813-1-19.png?imageView2/0/w/900" alt="衰减系数为50时的走势图，可以看出在抖动发生时，可以非常迅速的感知，后续恢复时的衰减速度跟上面结果一样快"></p><h2 id="三、利用JAVA实现P2C算法"><a href="#三、利用JAVA实现P2C算法" class="headerlink" title="三、利用JAVA实现P2C算法"></a>三、利用JAVA实现P2C算法</h2><p>首先定义Node类：</p><figure class="highlight java"><figcaption><span>代码块1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//惩罚值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">penalty</span> <span class="operator">=</span> <span class="number">250_000_000_000L</span>; <span class="comment">//单位：纳秒（250s）</span></span><br><span class="line">    <span class="comment">//衰减系数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">tau</span> <span class="operator">=</span> <span class="number">600_000_000L</span>; <span class="comment">//单位：纳秒（600ms）</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String host;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> weight; <span class="comment">//权重</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// client统计数据</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">lag</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(); <span class="comment">//加权移动平均算法计算出的请求延迟度</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">success</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">1000</span>); <span class="comment">// 加权移动平均算法计算出的请求成功率（只记录grpc内部错误，比如context deadline）</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">inflight</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">1</span>); <span class="comment">// 当前客户端正在发送并等待response的请求数（pending request）</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">svrCPU</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">500</span>); <span class="comment">//对应服务端的CPU使用率</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 最近一次resp时间戳</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">stamp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>();</span><br><span class="line">    <span class="comment">// 最近被pick的时间戳，利用该值可以统计被选中后，一次请求的耗时</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">pick</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(String host, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.host = host;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">valid</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> health() &gt; <span class="number">500</span> &amp;&amp; svrCPU.get() &lt; <span class="number">900</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">health</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> success.get(); <span class="comment">//成功率</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">load</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">lag</span> <span class="operator">=</span> (<span class="type">long</span>) (Math.sqrt((<span class="type">double</span>) <span class="built_in">this</span>.lag.get()) + <span class="number">1</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">load</span> <span class="operator">=</span> <span class="built_in">this</span>.svrCPU.get() * lag * <span class="built_in">this</span>.inflight.get(); <span class="comment">//根据cpu使用率、延迟率、拥塞度计算出负载率</span></span><br><span class="line">        <span class="keyword">if</span> (load == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// penalty是初始化没有数据时的惩罚值，默认为1e9 * 250</span></span><br><span class="line">            load = penalty;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> load;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//被pick后，完成请求后触发逻辑</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">responseTrigger</span><span class="params">(<span class="type">long</span> pickTime, <span class="type">long</span> cpu, <span class="type">boolean</span> error)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.inflight.decrementAndGet();</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> <span class="built_in">this</span>.stamp.getAndSet(now);</span><br><span class="line">        <span class="type">long</span> <span class="variable">td</span> <span class="operator">=</span> now - stamp; <span class="comment">//计算距离上次response的时间差，节点本身闲置越久，这个值越大</span></span><br><span class="line">        <span class="keyword">if</span> (td &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            td = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//实时计算β值，利用衰减函数计算，公式为：β = e^(-t/k)，相比前文给出的衰减公式这里是按照k值的反比计算的，即k值和β值成正比</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">w</span> <span class="operator">=</span> Math.exp((<span class="type">double</span>) -td / (<span class="type">double</span>) tau);</span><br><span class="line"> </span><br><span class="line">        <span class="type">long</span> <span class="variable">lag</span> <span class="operator">=</span> now - pickTime; <span class="comment">//实际耗时</span></span><br><span class="line">        <span class="keyword">if</span> (lag &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            lag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">oldLag</span> <span class="operator">=</span> <span class="built_in">this</span>.lag.get();</span><br><span class="line">        <span class="keyword">if</span> (oldLag == <span class="number">0</span>) &#123;</span><br><span class="line">            w = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//计算指数加权移动平均响应时间</span></span><br><span class="line">        lag = (<span class="type">int</span>) ((<span class="type">double</span>) oldLag * w + (<span class="type">double</span>) lag * (<span class="number">1.0</span> - w));</span><br><span class="line">        <span class="built_in">this</span>.lag.set(lag); <span class="comment">//更新</span></span><br><span class="line"> </span><br><span class="line">        <span class="type">int</span> <span class="variable">success</span> <span class="operator">=</span> error ? <span class="number">0</span> : <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">//计算指数加权移动平均成功率</span></span><br><span class="line">        success = (<span class="type">int</span>) ((<span class="type">double</span>) <span class="built_in">this</span>.success.get() * w + (<span class="type">double</span>) success * (<span class="number">1.0</span> - w));</span><br><span class="line">        <span class="built_in">this</span>.success.set(success); <span class="comment">//更新</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//更新本次请求服务端返回的cpu使用率</span></span><br><span class="line">        <span class="keyword">if</span> (cpu &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.svrCPU.set(cpu);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来定义LoadBalancer：</p><figure class="highlight java"><figcaption><span>代码块2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">P2CLoadBalancer</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//闲置时间的最大容忍值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">forceGap</span> <span class="operator">=</span> <span class="number">3000_000_000L</span>; <span class="comment">//单位：纳秒（3s）</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Node&gt; nodes; <span class="comment">//保存了参与lb的节点集合</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">P2CLoadBalancer</span><span class="params">(List&lt;Node&gt; nodes)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nodes = nodes;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">pick</span><span class="params">(<span class="type">long</span> start)</span> &#123; <span class="comment">//外界给入start，值为当前时间，resp后应给recycle传同样的值</span></span><br><span class="line">        Node pc, upc;</span><br><span class="line">        <span class="keyword">if</span> (nodes == <span class="literal">null</span> || nodes.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;no node!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nodes.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        Node[] randomPair = prePick();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里根据各自当前指标，计算出谁更合适被pick</span></span><br><span class="line"><span class="comment">         * 计算方式：</span></span><br><span class="line"><span class="comment">         *        nodeA.load                           nodeB.load</span></span><br><span class="line"><span class="comment">         * ----------------------------   :   ----------------------------</span></span><br><span class="line"><span class="comment">         * nodeA.health * nodeA.weight        nodeB.health * nodeB.weight</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * health和weight都是提权用的，而load是降权用的，所以用load除以heal和weight的乘积，计算出的值越大，越不容易被pick</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (randomPair[<span class="number">0</span>].load() * randomPair[<span class="number">1</span>].health() * randomPair[<span class="number">1</span>].weight &gt;</span><br><span class="line">                randomPair[<span class="number">1</span>].load() * randomPair[<span class="number">0</span>].health() * randomPair[<span class="number">0</span>].weight) &#123;</span><br><span class="line">            pc = randomPair[<span class="number">1</span>];</span><br><span class="line">            upc = randomPair[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pc = randomPair[<span class="number">0</span>];</span><br><span class="line">            upc = randomPair[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 如果落选的节点，在forceGap期间内没有被选中一次，那么强制选中一次，利用强制的机会，来触发成功率、延迟的衰减</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">pick</span> <span class="operator">=</span> upc.pick.get();</span><br><span class="line">        <span class="keyword">if</span> ((start - pick) &gt; forceGap &amp;&amp; upc.pick.compareAndSet(pick, start)) &#123;</span><br><span class="line">            pc = upc; <span class="comment">//强制选中</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 节点未发生切换才更新pick时间</span></span><br><span class="line">        <span class="keyword">if</span> (pc != upc) &#123;</span><br><span class="line">            pc.pick.set(start);</span><br><span class="line">        &#125;</span><br><span class="line">        pc.inflight.incrementAndGet();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> pc;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//pick出去后，等来了response后，应触发该方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recycle</span><span class="params">(Node node, <span class="type">long</span> pickTime, <span class="type">long</span> cpu, <span class="type">boolean</span> error)</span> &#123;</span><br><span class="line">        node.responseTrigger(pickTime, cpu, error);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 随机选择俩节点</span></span><br><span class="line">    <span class="keyword">public</span> Node[] prePick() &#123;</span><br><span class="line">        Node[] randomPair = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> r.nextInt(nodes.size());</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> r.nextInt(nodes.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (b &gt;= a) &#123;</span><br><span class="line">                b += <span class="number">1</span>; <span class="comment">//防止随机出的节点相同</span></span><br><span class="line">            &#125;</span><br><span class="line">            randomPair[<span class="number">0</span>] = nodes.get(a);</span><br><span class="line">            randomPair[<span class="number">1</span>] = nodes.get(b);</span><br><span class="line">            <span class="keyword">if</span> (randomPair[<span class="number">0</span>].valid() || randomPair[<span class="number">1</span>].valid()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> randomPair;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、算法验证"><a href="#四、算法验证" class="headerlink" title="四、算法验证"></a>四、算法验证</h2><p>算法的验证会以实际压测的方式来进行，请前往：<a href="https://exceting.github.io/2020/08/25/P2C%E7%AE%97%E6%B3%95%E9%AA%8C%E8%AF%81%E5%AE%9E%E9%AA%8C/">P2C算法验证实验</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;P2C&lt;/code&gt;算法全称&lt;code&gt;Pick of 2 choices&lt;/code&gt;，相比&lt;code&gt;WRR&lt;/code&gt;，P2C有着更科学的LB策略，它通过随机选择两个节点后在这俩节点里选择优胜者来避免&lt;code&gt;羊群效应&lt;/code&gt;，并通过&lt;code&gt;指数加权移动平均算法&lt;/code&gt;统计服务端的实时状态，从而做出最优选择。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="服务治理" scheme="http://example.com/categories/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    
    
    <category term="负载均衡" scheme="http://example.com/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
    <category term="服务治理" scheme="http://example.com/tags/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡-WRR算法</title>
    <link href="http://example.com/2020/08/07/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-WRR%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2020/08/07/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-WRR%E7%AE%97%E6%B3%95/</id>
    <published>2020-08-06T22:27:00.000Z</published>
    <updated>2023-12-04T02:37:15.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、工作流程"><a href="#一、工作流程" class="headerlink" title="一、工作流程"></a>一、工作流程</h2><h3 id="1-1：实现加权轮询的方式"><a href="#1-1：实现加权轮询的方式" class="headerlink" title="1.1：实现加权轮询的方式"></a>1.1：实现加权轮询的方式</h3><p>WRR叫做加权轮询算法，相比普通的轮询算法，它支持给每个节点配置权重，权重越大，越容易被访问，且符合轮询的特点。</p><span id="more"></span><p>一般情况下，我们会按照下方逻辑设计算法的实现：</p><p><img src="http://myblog.sharemer.com/2020/08/07/20200807-1-1.png?imageView2/0/w/900" alt="图1"></p><p>如<code>图1</code>中流程执行完毕，接下来就跟普通RR算法一样做轮询即可，保证每个虚拟节点都被均匀访问到，而被访问概率也与权重值成正比。</p><p>但正如上图所说，乱序那一步是比较容易出问题的，可能会出现下面这样的情况：</p><p><img src="http://myblog.sharemer.com/2020/08/07/20200807-1-2.png?imageView2/0/w/500" alt="图2"></p><h3 id="1-2：SWRR算法"><a href="#1-2：SWRR算法" class="headerlink" title="1.2：SWRR算法"></a>1.2：SWRR算法</h3><p>如果不足够散列，意味着轮询窗口内访问不足够均匀，基于此，便有了<code>SWRR算法</code>，它是一种可以平滑访问的、nginx默认的加权轮询算法，相比普通加权轮询，它在轮询访问节点时表现的更加散列。</p><p>在该算法中，每个节点有如下基本属性：</p><p><img src="http://myblog.sharemer.com/2020/08/07/20200807-1-3.png?imageView2/0/w/900" alt="图3"></p><p>结合上面几个属性，来看下SWRR算法下，选举流程是怎样的：</p><p>首先是Node信息的初始化，按照<code>图3</code>的描述，每个Node在初始化的那一刻，<code>effective_weight</code>跟它的<code>weight</code>值相等，<code>current_weight</code>都为0：</p><p><img src="http://myblog.sharemer.com/2020/08/07/20200807-1-4.png?imageView2/0/w/300" alt="图4"></p><p>然后开始pick，来看下pick的流程：</p><p><img src="http://myblog.sharemer.com/2020/08/07/20200807-1-5.png?imageView2/0/w/550" alt="图5"></p><p>每次pick，都会经历上面的流程，这样来模拟一下这个轮询过程，假设现在有三个节点，节点名为a、b、c，对应权重值为：<code>4:2:1</code>，结合上面的pick流程，它的轮询流程如下：</p><p><img src="http://myblog.sharemer.com/2020/08/07/20200807-table.png?imageView2/0/w/1024" alt="表1"></p><p>上表为<code>SWRR</code>两次轮询的执行效果，可以看到pick出来的节点<code>非常散列</code>，而且每一次轮询得到的顺序是<code>一致</code>的，且每次轮询完成后，各项指标会还原为初始状态，以此类推，它的数学推导&amp;证明请参考：<a href="http://claude-ray.com/2019/08/10/nginx-swrr/">Nginx SWRR 算法解读</a></p><h3 id="1-3：SWRR存在的问题"><a href="#1-3：SWRR存在的问题" class="headerlink" title="1.3：SWRR存在的问题"></a>1.3：SWRR存在的问题</h3><p>上面的按照SWRR模拟的pick过程很完美，但该算法依然有一些漏洞，请参考：<a href="https://www.infoq.cn/article/SEbuh0K6jI*yTfqzcihB">QPS 比 Nginx 提升 60%，阿里 Tengine 负载均衡算法揭秘</a></p><p>简单来理解，SWRR有以下缺陷：</p><ol><li>算法复杂度为<code>O(N)</code>，而且在pick节点时为了保证准确性，需要加<code>锁</code></li><li>如果<code>刷新</code>某节点的权重值，会导致该节点流量值瞬间<code>暴增</code></li></ol><p>第一点很好理解，因为每次都要选出<code>current_weight</code>最大的那个节点，必然要循环一次所有的节点。<code>第二点存疑</code>，参考上方文章评论区：</p><p><img src="http://myblog.sharemer.com/2020/08/07/20200807-1-6.png?imageView2/0/w/875" alt="图6"></p><p>我在自测过程中，在算法启动后动态调整<code>weight</code>和<code>effective_weight</code>的值是不存在这个问题的，访问依旧均匀，并不会出现大规模pick到加权节点上的情况，个人猜测他们可能是在探听到<code>weight</code>变化后，把对应节点的<code>current_weight</code>也给改掉了才可能出现这个问题。</p><h3 id="1-4：优化SWRR"><a href="#1-4：优化SWRR" class="headerlink" title="1.4：优化SWRR"></a>1.4：优化SWRR</h3><p>按照上方文章里描述，我们现在需要将<code>O(N)</code>的算法变成<code>O(1)</code>，这样不仅仅性能迅速提升，pick时也<code>无需加锁</code>，对于使用SWRR算法来说是个不错的选择，那如何实现O(1)呢？<code>表1</code>告诉我们，按照算法pick出的节点是有规律性的，以权重和为模来界定一次轮询，而每个轮询窗口内的节点散列顺序完全一致，那么这样优化起来就简单多了：</p><p><img src="http://myblog.sharemer.com/2020/08/07/20200807-1-7.png?imageView2/0/w/1024" alt="图7"></p><p>经过上图里展示的方法，做一层转换，即可达成<code>O(1)</code>成就，这样在高QPS时的效率会显著提升，后续如果有节点信息变更，只需要以同样的方式，刷新虚拟节点有序集合即可。</p><h2 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h2><p>这里采用JAVA语言来实现：</p><figure class="highlight java"><figcaption><span>代码块1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WrrLoadBalancer</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> effectiveWeightSum; <span class="comment">//总权重值</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Node[] virtualNodes; <span class="comment">//虚拟节点有序集</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> AtomicLong pointer; <span class="comment">//pick次数</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WrrLoadBalancer</span><span class="params">(Node... nodes)</span> &#123;</span><br><span class="line">        refreshVirtual(nodes);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//刷新虚拟节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refreshVirtual</span><span class="params">(Node... nodes)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node node : nodes) &#123;</span><br><span class="line">            total += node.getEffectiveWeight(); <span class="comment">//累加total</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newEffectiveWeightSum</span> <span class="operator">=</span> total;</span><br><span class="line">        Node[] newVirtualNodes = <span class="keyword">new</span> <span class="title class_">Node</span>[newEffectiveWeightSum];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; newEffectiveWeightSum; i++) &#123;</span><br><span class="line">            newVirtualNodes[i] = pickInit(newEffectiveWeightSum, nodes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.virtualNodes = newVirtualNodes;</span><br><span class="line">        <span class="built_in">this</span>.effectiveWeightSum = newEffectiveWeightSum;</span><br><span class="line">        pointer = <span class="keyword">new</span> <span class="title class_">AtomicLong</span>((<span class="type">long</span>) (Math.random() * effectiveWeightSum)); <span class="comment">//随机开始位置</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">pickInit</span><span class="params">(<span class="type">int</span> effectiveWeightSum, Node... nodes)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">picked</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node node : nodes) &#123;</span><br><span class="line">            node.refreshCurrentWeight();</span><br><span class="line">            <span class="keyword">if</span> (picked == <span class="literal">null</span>) &#123;</span><br><span class="line">                picked = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (picked.getCurrentWeight() &lt; node.getCurrentWeight()) &#123;</span><br><span class="line">                    picked = node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (picked == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;wrr pick error!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> picked.pick(effectiveWeightSum);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">pick</span><span class="params">()</span> &#123; <span class="comment">//注：更新节点时，可能下标溢出</span></span><br><span class="line">        <span class="keyword">return</span> virtualNodes[(<span class="type">int</span>) (pointer.incrementAndGet() % effectiveWeightSum)];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String host;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 用户所配的权重</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">weight</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 有效权重，正常情况下，该值等于weight，但是当node本身发生错误时，</span></span><br><span class="line">        <span class="comment">// 会适当降低该值，后面被选中一次，若不报错，则累加该值，顺利的话最后会再次恢复到weight</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">effectiveWeight</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//后端目前的权重，一开始为0，后期动态调整，选节点的依据，谁这个值最大就选谁</span></span><br><span class="line">        <span class="comment">//计算方式，每次被选中，</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">currentWeight</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(String host, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.host = host;</span><br><span class="line">            <span class="built_in">this</span>.weight.set(weight);</span><br><span class="line">            <span class="built_in">this</span>.effectiveWeight.set(weight);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> Node <span class="title function_">pick</span><span class="params">(<span class="type">int</span> total)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//节点被选中后，需要&quot;降权&quot;，即减去Sum(effective_weight)</span></span><br><span class="line">                <span class="built_in">this</span>.currentWeight.addAndGet(total * -<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//刷新currentWeight值，使其累加当前的effectiveWeight值</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refreshCurrentWeight</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.currentWeight.getAndAdd(<span class="built_in">this</span>.effectiveWeight.get());</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//刷新effectiveWeight值</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getEffectiveWeight</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.effectiveWeight.get();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCurrentWeight</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.currentWeight.get();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getHost</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> host;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、算法验证"><a href="#四、算法验证" class="headerlink" title="四、算法验证"></a>四、算法验证</h2><p>算法的验证会以实际压测的方式来进行，请前往：<a href="https://exceting.github.io/2020/08/28/WRR%E7%AE%97%E6%B3%95%E9%AA%8C%E8%AF%81%E5%AE%9E%E9%AA%8C/">WRR算法验证实验</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、工作流程&quot;&gt;&lt;a href=&quot;#一、工作流程&quot; class=&quot;headerlink&quot; title=&quot;一、工作流程&quot;&gt;&lt;/a&gt;一、工作流程&lt;/h2&gt;&lt;h3 id=&quot;1-1：实现加权轮询的方式&quot;&gt;&lt;a href=&quot;#1-1：实现加权轮询的方式&quot; class=&quot;headerlink&quot; title=&quot;1.1：实现加权轮询的方式&quot;&gt;&lt;/a&gt;1.1：实现加权轮询的方式&lt;/h3&gt;&lt;p&gt;WRR叫做加权轮询算法，相比普通的轮询算法，它支持给每个节点配置权重，权重越大，越容易被访问，且符合轮询的特点。&lt;/p&gt;</summary>
    
    
    
    <category term="服务治理" scheme="http://example.com/categories/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    
    
    <category term="负载均衡" scheme="http://example.com/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
    <category term="服务治理" scheme="http://example.com/tags/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>定制grpc负载均衡器</title>
    <link href="http://example.com/2020/08/06/%E5%AE%9A%E5%88%B6grpc%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8/"/>
    <id>http://example.com/2020/08/06/%E5%AE%9A%E5%88%B6grpc%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8/</id>
    <published>2020-08-06T13:46:00.000Z</published>
    <updated>2023-12-04T02:40:38.083Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、负载均衡器是如何被grpc加载的"><a href="#一、负载均衡器是如何被grpc加载的" class="headerlink" title="一、负载均衡器是如何被grpc加载的"></a>一、负载均衡器是如何被grpc加载的</h2><h3 id="1-1：提供provider类"><a href="#1-1：提供provider类" class="headerlink" title="1.1：提供provider类"></a>1.1：提供provider类</h3><p>每个<code>LoadBalancer</code>对象都是通过一个对象来实例化的，不同的<code>LoadBalancerProvider</code>对象会实例化出不同的<code>LoadBalancer</code>对象，而<code>LoadBalancerProvider</code>对象会通过<code>SPI机制</code>载入到grpc的客户端中，比如在<code>grpc-core</code>里的<code>MATE-INF</code>下：</p><span id="more"></span><p><img src="http://myblog.sharemer.com/2020/08/06/20200806-1-1.png?imageView2/0/w/1024" alt="图1"></p><p>由此可知，grpc原生共提供了两种LoadBalancerProvider，那看看它有关核心方法的实现：</p><p>首先是<code>PickFirstLoadBalancerProvider</code>：</p><figure class="highlight java"><figcaption><span>代码块1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">PickFirstLoadBalancerProvider</span> <span class="keyword">extends</span> <span class="title class_">LoadBalancerProvider</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NO_CONFIG</span> <span class="operator">=</span> <span class="string">&quot;no service config&quot;</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAvailable</span><span class="params">()</span> &#123; <span class="comment">//是否有效（若置为false，即便你在grpc client指定了该lb算法，那么它也不会生效）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPriority</span><span class="params">()</span> &#123; <span class="comment">//优先级</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getPolicyName</span><span class="params">()</span> &#123; <span class="comment">//lb算法的名称</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;pick_first&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> LoadBalancer <span class="title function_">newLoadBalancer</span><span class="params">(LoadBalancer.Helper helper)</span> &#123; <span class="comment">//提供对应的LoadBalancer对象，可以看到，这个实现类为PickFirstLoadBalancer</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PickFirstLoadBalancer</span>(helper);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> ConfigOrError <span class="title function_">parseLoadBalancingPolicyConfig</span><span class="params">(Map&lt;String, ?&gt; rawLoadBalancingPolicyConfig)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ConfigOrError.fromConfig(NO_CONFIG);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次是<code>SecretRoundRobinLoadBalancerProvider.Provider</code>：</p><figure class="highlight java"><figcaption><span>代码块2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SecretRoundRobinLoadBalancerProvider</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">SecretRoundRobinLoadBalancerProvider</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Provider</span> <span class="keyword">extends</span> <span class="title class_">LoadBalancerProvider</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NO_CONFIG</span> <span class="operator">=</span> <span class="string">&quot;no service config&quot;</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAvailable</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPriority</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPolicyName</span><span class="params">()</span> &#123; <span class="comment">//这里则是返回round robin的lb算法名称</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;round_robin&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> LoadBalancer <span class="title function_">newLoadBalancer</span><span class="params">(LoadBalancer.Helper helper)</span> &#123; <span class="comment">//提供对应的LoadBalancer对象，可以看到，这个实现类为RoundRobinLoadBalancer</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RoundRobinLoadBalancer</span>(helper);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ConfigOrError <span class="title function_">parseLoadBalancingPolicyConfig</span><span class="params">(</span></span><br><span class="line"><span class="params">        Map&lt;String, ?&gt; rawLoadBalancingPolicyConfig)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ConfigOrError.fromConfig(NO_CONFIG);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了不同的LoadBalancerProvider类去实例化不同的LB算法，就可以扩展并指定不同的LB算法了，我们也可以效仿这种做法，来搞一套我们自己的LB算法做替换。</p><h3 id="1-2：提供LoadBalancer的实现"><a href="#1-2：提供LoadBalancer的实现" class="headerlink" title="1.2：提供LoadBalancer的实现"></a>1.2：提供LoadBalancer的实现</h3><p>上面是LB算法的实例提供方，那必定存在LB算法的实现方，上面两个Provider分别提供了一个对应的LB算法实现类，即：<code>RoundRobinLoadBalancer</code> &amp; <code>PickFirstLoadBalancer</code></p><p>因为我们使用的是轮询，因此只说明下RoundRobinLoadBalancer即可。</p><p>因为源代码过于复杂，这里仅展示出关键步骤（感兴趣可以直接查看<code>io.grpc.util.RoundRobinLoadBalancer</code>，嫌看代码麻烦，可以调到下方<code>图2</code>，快速浏览其过程）：</p><figure class="highlight java"><figcaption><span>代码块3</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoundRobinLoadBalancer</span> <span class="keyword">extends</span> <span class="title class_">LoadBalancer</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@VisibleForTesting</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Attributes.Key&lt;Ref&lt;ConnectivityStateInfo&gt;&gt; STATE_INFO = Attributes.Key.create(<span class="string">&quot;state-info&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Status</span> <span class="variable">EMPTY_OK</span> <span class="operator">=</span> Status.OK.withDescription(<span class="string">&quot;no subchannels ready&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Helper helper; <span class="comment">//负责创建channel、将picker传出去</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;EquivalentAddressGroup, Subchannel&gt; subchannels = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">//保存channel用的</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> ConnectivityState currentState; <span class="comment">//最近一次建连的连接状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">WeightRoundRobinPicker</span> <span class="variable">currentPicker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmptyPicker</span>(EMPTY_OK); <span class="comment">//最近一次建连后的picker对象，正常情况下会被刷成ReadyPicker</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeightRoundRobinLoadBalancer</span><span class="params">(Helper helper)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.helper = checkNotNull(helper, <span class="string">&quot;helper&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 刷新节点，每当服务发现更新了节点，都会通知到该方法，用来更新现有参与LB的节点信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resolvedAddresses 新节点集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleResolvedAddresses</span><span class="params">(ResolvedAddresses resolvedAddresses)</span> &#123;</span><br><span class="line">        List&lt;EquivalentAddressGroup&gt; servers = resolvedAddresses.getAddresses();</span><br><span class="line">        Set&lt;EquivalentAddressGroup&gt; currentAddrs = subchannels.keySet(); <span class="comment">//当前节点集合</span></span><br><span class="line">        Map&lt;EquivalentAddressGroup, EquivalentAddressGroup&gt; latestAddrs = stripAttrs(servers); <span class="comment">//最新节点集合</span></span><br><span class="line">        <span class="comment">//因为是更新address，所以这里需要过滤出来旧版需要被移除的部分</span></span><br><span class="line">        Set&lt;EquivalentAddressGroup&gt; removedAddrs = setsDifference(currentAddrs, latestAddrs.keySet());</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//遍历新节点</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;EquivalentAddressGroup, EquivalentAddressGroup&gt; latestEntry : latestAddrs.entrySet()) &#123;</span><br><span class="line">            <span class="type">EquivalentAddressGroup</span> <span class="variable">strippedAddressGroup</span> <span class="operator">=</span> latestEntry.getKey(); <span class="comment">//新节点的节点信息（参考stripAttrs方法）</span></span><br><span class="line">            <span class="type">EquivalentAddressGroup</span> <span class="variable">originalAddressGroup</span> <span class="operator">=</span> latestEntry.getValue(); <span class="comment">//新节点的完整信息</span></span><br><span class="line">            <span class="type">Subchannel</span> <span class="variable">existingSubchannel</span> <span class="operator">=</span> subchannels.get(strippedAddressGroup); <span class="comment">//尝试在老节点查找新入的节点</span></span><br><span class="line">            <span class="keyword">if</span> (existingSubchannel != <span class="literal">null</span>) &#123; <span class="comment">//若老节点原本就存在该节点，则触发下方逻辑</span></span><br><span class="line">                <span class="comment">// 新拉取到的节点，它的Attributes可能被改变（附带信息，比如服务发现上节点的权重值前后发生变化），这里需要刷新</span></span><br><span class="line">                existingSubchannel.updateAddresses(Collections.singletonList(originalAddressGroup));</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若老节点不存在，则说明需要new一个新的subchannel</span></span><br><span class="line">            Attributes.<span class="type">Builder</span> <span class="variable">subchannelAttrs</span> <span class="operator">=</span> Attributes.newBuilder().set(STATE_INFO,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Ref</span>&lt;&gt;(ConnectivityStateInfo.forNonError(IDLE))); <span class="comment">//设置节点初始状态，通过Ref可以修改状态引用</span></span><br><span class="line"> </span><br><span class="line">            <span class="keyword">final</span> <span class="type">Subchannel</span> <span class="variable">subchannel</span> <span class="operator">=</span> checkNotNull(</span><br><span class="line">                helper.createSubchannel(CreateSubchannelArgs.newBuilder()</span><br><span class="line">                    .setAddresses(originalAddressGroup)</span><br><span class="line">                    .setAttributes(subchannelAttrs.build())</span><br><span class="line">                    .build()),</span><br><span class="line">                <span class="string">&quot;subchannel&quot;</span>);</span><br><span class="line">            subchannel.start(<span class="keyword">new</span> <span class="title class_">SubchannelStateListener</span>() &#123; <span class="comment">//异步建连，收到建连成功的通知后，触发onSubchannelState</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSubchannelState</span><span class="params">(ConnectivityStateInfo state)</span> &#123;</span><br><span class="line">                    processSubchannelState(subchannel, state); <span class="comment">//建连完成，更新连接状态为可用（若建连没问题，则state应为READY，即就绪状态）</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            subchannels.put(strippedAddressGroup, subchannel); <span class="comment">//将连接放进集合里</span></span><br><span class="line">            subchannel.requestConnection(); <span class="comment">//触发建连的动作（建连动作处理完毕后，会通知上方onSubchannelState）</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        ArrayList&lt;Subchannel&gt; removedSubchannels = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (EquivalentAddressGroup addressGroup : removedAddrs) &#123;</span><br><span class="line">            <span class="comment">//去除掉需要摘除的节点</span></span><br><span class="line">            removedSubchannels.add(subchannels.remove(addressGroup));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 更新loadbalance状态</span></span><br><span class="line">        updateBalancingState();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (Subchannel removedSubchannel : removedSubchannels) &#123;</span><br><span class="line">            <span class="comment">//将需要摘除掉的节点逐个shutdown</span></span><br><span class="line">            shutdownSubchannel(removedSubchannel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleNameResolutionError</span><span class="params">(Status error)</span> &#123;</span><br><span class="line">        updateBalancingState(TRANSIENT_FAILURE, currentPicker <span class="keyword">instanceof</span> ReadyPicker ? currentPicker : <span class="keyword">new</span> <span class="title class_">EmptyPicker</span>(error));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Subchannel subchannel : getSubchannels()) &#123;</span><br><span class="line">            shutdownSubchannel(subchannel); <span class="comment">//逐个关闭所持有的连接</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//这里传入的是服务发现推给的节点集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;EquivalentAddressGroup, EquivalentAddressGroup&gt; <span class="title function_">stripAttrs</span><span class="params">(List&lt;EquivalentAddressGroup&gt; groupList)</span> &#123;</span><br><span class="line">        Map&lt;EquivalentAddressGroup, EquivalentAddressGroup&gt; addrs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(groupList.size() * <span class="number">2</span>); <span class="comment">//为什么要扩2倍？</span></span><br><span class="line">        <span class="keyword">for</span> (EquivalentAddressGroup group : groupList) &#123;</span><br><span class="line">            <span class="comment">//一个map，k是包含了相同address的一个全新EquivalentAddressGroup对象，v是原始的EquivalentAddressGroup对象</span></span><br><span class="line">            addrs.put(stripAttrs(group), group);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> addrs;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EquivalentAddressGroup <span class="title function_">stripAttrs</span><span class="params">(EquivalentAddressGroup eag)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EquivalentAddressGroup</span>(eag.getAddresses());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//用来更新连接状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processSubchannelState</span><span class="params">(Subchannel subchannel, ConnectivityStateInfo stateInfo)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (subchannels.get(stripAttrs(subchannel.getAddresses())) != subchannel) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stateInfo.getState() == IDLE) &#123;</span><br><span class="line">            subchannel.requestConnection(); <span class="comment">//如果是闲置状态，则触发建连操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拿到当前channel的state</span></span><br><span class="line">        Ref&lt;ConnectivityStateInfo&gt; subchannelStateRef = getSubchannelStateInfoRef(subchannel);</span><br><span class="line">        <span class="keyword">if</span> (subchannelStateRef.value.getState().equals(TRANSIENT_FAILURE)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stateInfo.getState().equals(CONNECTING) || stateInfo.getState().equals(IDLE)) &#123;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">//若连接处于故障状态，则不允许改成&quot;连接中&quot;和&quot;闲置&quot;状态</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        subchannelStateRef.value = stateInfo; <span class="comment">//修改状态</span></span><br><span class="line">        updateBalancingState(); <span class="comment">//更新loadbalance状态</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//每次建连事件被异步触发后，都会触发一次该方法，用来刷新picker</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateBalancingState</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Subchannel&gt; activeList = filterNonFailingSubchannels(getSubchannels()); <span class="comment">//将当前就绪状态的channel过滤出来</span></span><br><span class="line">        <span class="keyword">if</span> (activeList.isEmpty()) &#123; <span class="comment">//建连触发才会走到这里，因此只要建连没出问题，一般情况下都不为空，除非这批节点没一个可用的</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isConnecting</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">Status</span> <span class="variable">aggStatus</span> <span class="operator">=</span> EMPTY_OK;</span><br><span class="line">            <span class="keyword">for</span> (Subchannel subchannel : getSubchannels()) &#123;</span><br><span class="line">                <span class="type">ConnectivityStateInfo</span> <span class="variable">stateInfo</span> <span class="operator">=</span> getSubchannelStateInfoRef(subchannel).value;</span><br><span class="line">                <span class="keyword">if</span> (stateInfo.getState() == CONNECTING || stateInfo.getState() == IDLE) &#123;</span><br><span class="line">                    isConnecting = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (aggStatus == EMPTY_OK || !aggStatus.isOk()) &#123;</span><br><span class="line">                    aggStatus = stateInfo.getStatus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            updateBalancingState(isConnecting ? CONNECTING : TRANSIENT_FAILURE, <span class="keyword">new</span> <span class="title class_">EmptyPicker</span>(aggStatus));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            updateBalancingState(READY, <span class="keyword">new</span> <span class="title class_">ReadyPicker</span>(activeList)); <span class="comment">//可以看到，最后会将建连成功的节点丢到ReadyPicker里，用来做lb</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//更新picker的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateBalancingState</span><span class="params">(ConnectivityState state, WeightRoundRobinPicker picker)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (state != currentState || !picker.isEquivalentTo(currentPicker)) &#123;</span><br><span class="line">            helper.updateBalancingState(state, picker); <span class="comment">//非常重要的一步，负责将当前的picker送出去，给ManagedChannelImpl使用，client请求时会触发picker的pickSubchannel方法</span></span><br><span class="line">            currentState = state; <span class="comment">//刷新连接状态</span></span><br><span class="line">            currentPicker = picker; <span class="comment">//刷新picker对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程简图（不同方法已用不同颜色标出）：</p><p><img src="http://myblog.sharemer.com/2020/08/06/20200806-1-2.png?imageView2/0/w/1024" alt="图2"></p><h3 id="1-3：提供LoadBalancer-SubchannelPicker实现"><a href="#1-3：提供LoadBalancer-SubchannelPicker实现" class="headerlink" title="1.3：提供LoadBalancer.SubchannelPicker实现"></a>1.3：提供LoadBalancer.SubchannelPicker实现</h3><p>上面说了那么多，都只是在为真正的LB做准备，实际的LB算法保存在Picker类里，我们来看下上文中出现的<code>ReadyPicker</code>的主要方法实现：</p><figure class="highlight java"><figcaption><span>代码块4</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ReadyPicker</span> <span class="keyword">extends</span> <span class="title class_">RoundRobinPicker</span> &#123; <span class="comment">//RoundRobinPicker继承了LoadBalancer.SubchannelPicker</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicIntegerFieldUpdater&lt;ReadyPicker&gt; indexUpdater =</span><br><span class="line">            AtomicIntegerFieldUpdater.newUpdater(ReadyPicker.class, <span class="string">&quot;index&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Subchannel&gt; list; <span class="comment">// 这里保存的就是当前已就绪的channel（结合图2里ReadyPicker的初始化理解）</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> index;</span><br><span class="line"> </span><br><span class="line">    ReadyPicker(List&lt;Subchannel&gt; list, <span class="type">int</span> startIndex) &#123;</span><br><span class="line">        Preconditions.checkArgument(!list.isEmpty(), <span class="string">&quot;empty list&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">        <span class="built_in">this</span>.index = startIndex - <span class="number">1</span>; <span class="comment">//轮询算法开始的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PickResult <span class="title function_">pickSubchannel</span><span class="params">(PickSubchannelArgs args)</span> &#123; <span class="comment">//实现了pickSubchannel方法，该方法就是对外pick节点的核心方法</span></span><br><span class="line">        <span class="keyword">return</span> PickResult.withSubchannel(nextSubchannel()); <span class="comment">//nextSubchannel里放的就是轮询算法的核心代码了</span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> Subchannel <span class="title function_">nextSubchannel</span><span class="params">()</span> &#123; <span class="comment">//轮询算法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexUpdater.incrementAndGet(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">oldi</span> <span class="operator">=</span> i;</span><br><span class="line">            i %= size;</span><br><span class="line">            indexUpdater.compareAndSet(<span class="built_in">this</span>, oldi, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isEquivalentTo</span><span class="params">(RoundRobinPicker picker)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(picker <span class="keyword">instanceof</span> ReadyPicker)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ReadyPicker</span> <span class="variable">other</span> <span class="operator">=</span> (ReadyPicker) picker;</span><br><span class="line">        <span class="keyword">return</span> other == <span class="built_in">this</span></span><br><span class="line">                || (list.size() == other.list.size() &amp;&amp; <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(list).containsAll(other.list));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是LB的核心算法，重点是pickSubchannel方法，它是LB算法的触发类。</p><h3 id="1-4：grpc-client指定LB算法"><a href="#1-4：grpc-client指定LB算法" class="headerlink" title="1.4：grpc client指定LB算法"></a>1.4：grpc client指定LB算法</h3><p>正常一个client channel的创建方式如下：</p><figure class="highlight java"><figcaption><span>代码块5</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ChannelBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> ChannelBuilder.forTarget(<span class="string">&quot;这里填服务的discovery_id&quot;</span>)</span><br><span class="line">            <span class="comment">//这个方法用来设置一个继承了io.grpc.NameResolverProvider的服务发现，可以定制</span></span><br><span class="line">            .nameResolverFactory(<span class="keyword">new</span> <span class="title class_">RPCNamingClientNameResolverFactory</span>(zone, resolver, cluster))</span><br><span class="line">            .disableRetry() <span class="comment">//禁止重试</span></span><br><span class="line">            <span class="comment">//这里就是用来启用对应的LB模块了，还记得xxxProvider里的getPolicyName方法吗？这里跟那里面返回的名称匹配，匹配后即可启用对应的LB服务</span></span><br><span class="line">            .defaultLoadBalancingPolicy(<span class="string">&quot;round_robin&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="type">ManagedChannel</span> <span class="variable">channel</span> <span class="operator">=</span> builder.build(); <span class="comment">//这样一个grpc的channel client就被创建出来了</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到grpc client通过<code>defaultLoadBalancingPolicy</code>方法利用LB的名称指定了一个默认负载均衡器。</p><h2 id="二、在grpc里定制自己的LB算法"><a href="#二、在grpc里定制自己的LB算法" class="headerlink" title="二、在grpc里定制自己的LB算法"></a>二、在grpc里定制自己的LB算法</h2><p>经过对第一部分的理解，想要在grpc里定制自己的LB算法就变得简单多了，只需要以下几步：</p><ol><li>定义一个继承了<code>LoadBalancer.SubchannelPicker</code>类的XXXPicker，然后通过实现<code>pickSubchannel方法</code>实现自己的LB逻辑</li><li>定义一个继承了<code>LoadBalancer</code>的XXXLoadBalancer，用来管理连接以及提供对应的<code>Picker对象</code></li><li>定义一个继承了<code>LoadBalancerProvider</code>的Provider，然后将其按照<code>SPI规范</code>放到自己项目的<code>META-INF</code>下，通过<code>newLoadBalancer方法</code>提供对应的LoadBalancer对象</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、负载均衡器是如何被grpc加载的&quot;&gt;&lt;a href=&quot;#一、负载均衡器是如何被grpc加载的&quot; class=&quot;headerlink&quot; title=&quot;一、负载均衡器是如何被grpc加载的&quot;&gt;&lt;/a&gt;一、负载均衡器是如何被grpc加载的&lt;/h2&gt;&lt;h3 id=&quot;1-1：提供provider类&quot;&gt;&lt;a href=&quot;#1-1：提供provider类&quot; class=&quot;headerlink&quot; title=&quot;1.1：提供provider类&quot;&gt;&lt;/a&gt;1.1：提供provider类&lt;/h3&gt;&lt;p&gt;每个&lt;code&gt;LoadBalancer&lt;/code&gt;对象都是通过一个对象来实例化的，不同的&lt;code&gt;LoadBalancerProvider&lt;/code&gt;对象会实例化出不同的&lt;code&gt;LoadBalancer&lt;/code&gt;对象，而&lt;code&gt;LoadBalancerProvider&lt;/code&gt;对象会通过&lt;code&gt;SPI机制&lt;/code&gt;载入到grpc的客户端中，比如在&lt;code&gt;grpc-core&lt;/code&gt;里的&lt;code&gt;MATE-INF&lt;/code&gt;下：&lt;/p&gt;</summary>
    
    
    
    <category term="gRPC" scheme="http://example.com/categories/gRPC/"/>
    
    
    <category term="微服务" scheme="http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="gRPC" scheme="http://example.com/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>【旅行】济源游记-20200517</title>
    <link href="http://example.com/2020/06/08/%E3%80%90%E6%97%85%E8%A1%8C%E3%80%91%E6%B5%8E%E6%BA%90%E6%B8%B8%E8%AE%B0-20200517/"/>
    <id>http://example.com/2020/06/08/%E3%80%90%E6%97%85%E8%A1%8C%E3%80%91%E6%B5%8E%E6%BA%90%E6%B8%B8%E8%AE%B0-20200517/</id>
    <published>2020-06-08T12:24:00.000Z</published>
    <updated>2023-12-05T02:42:27.563Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>⏱ 旅行时间线：2020-05-15 ~ 2020-05-17</p><p>🌏 地点：河南省 · 济源市</p><p>🌿 景点：黄河三峡、王屋山</p><p>⚜️ 级别：AAAA</p></blockquote><span id="more"></span><h2 id="出发（2020-05-15）"><a href="#出发（2020-05-15）" class="headerlink" title="出发（2020.05.15）"></a>出发（2020.05.15）</h2><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-1.jpg" alt="高铁沿途1"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-2.jpg" alt="高铁沿途2"></p><h2 id="留宿（2020-05-15）"><a href="#留宿（2020-05-15）" class="headerlink" title="留宿（2020.05.15）"></a>留宿（2020.05.15）</h2><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-3.jpg" alt="到站"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-4.jpg" alt="焦作农家乐，已是傍晚"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-5.jpg" alt="第二天清早，前往济源"></p><h2 id="黄河三峡（2020-05-16）"><a href="#黄河三峡（2020-05-16）" class="headerlink" title="黄河三峡（2020.05.16）"></a>黄河三峡（2020.05.16）</h2><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-6.jpg" alt="索道"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-7.jpg" alt="导游说这是个展翅的凤凰😂"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-8.jpg" alt="远处的亭子"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-9.jpg" alt="岩壁"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-10.jpg" alt="溶洞1"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-11.jpg" alt="溶洞2"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-12.jpg" alt="古人类の骨"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-13.jpg" alt="水库远眺"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-14.jpg" alt="悬崖"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-15.jpg" alt="玻璃桥"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-16.jpg" alt="即将到达玻璃桥"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-17.jpg" alt="黄河三峡1"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-18.jpg" alt="黄河三峡2"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-19.jpg" alt="玻璃桥上看整座山"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-20.jpg" alt="黄河三峡3"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-21.jpg" alt="远观玻璃桥"></p><h2 id="老街（2020-05-16）"><a href="#老街（2020-05-16）" class="headerlink" title="老街（2020.05.16）"></a>老街（2020.05.16）</h2><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-22.jpg" alt="傍晚，即将前往古城"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-23.jpg" alt="+1s"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-24.jpg" alt="道德经"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-25.jpg" alt="老街的塔"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-26.jpg" alt="老街一角"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-27.jpg" alt="楝树"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-28.jpg" alt="楝树花"></p><h2 id="王屋山（2020-05-17）"><a href="#王屋山（2020-05-17）" class="headerlink" title="王屋山（2020.05.17）"></a>王屋山（2020.05.17）</h2><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-29.jpg" alt="次日上午，前往王屋山"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-30.jpg" alt="爬山中..."></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-31.jpg" alt="爬山中..."></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-32.jpg" alt="爬山中..."></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-33.jpg" alt="快到山顶了~"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-34.jpg" alt="山顶！！"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-35.jpg" alt="顶部观景台"></p><p><img src="http://myblog.sharemer.com/2020/06/05/20200605-36.jpg" alt="天坛极顶"></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;⏱ 旅行时间线：2020-05-15 ~ 2020-05-17&lt;/p&gt;
&lt;p&gt;🌏 地点：河南省 · 济源市&lt;/p&gt;
&lt;p&gt;🌿 景点：黄河三峡、王屋山&lt;/p&gt;
&lt;p&gt;⚜️ 级别：AAAA&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="旅行" scheme="http://example.com/tags/%E6%97%85%E8%A1%8C/"/>
    
    <category term="摄影" scheme="http://example.com/tags/%E6%91%84%E5%BD%B1/"/>
    
    <category term="日常" scheme="http://example.com/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>详解JDBC的Loadbalance模式</title>
    <link href="http://example.com/2020/06/02/%E8%AF%A6%E8%A7%A3JDBC%E7%9A%84Loadbalance%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2020/06/02/%E8%AF%A6%E8%A7%A3JDBC%E7%9A%84Loadbalance%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-02T12:21:00.000Z</published>
    <updated>2023-12-04T02:49:27.898Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基于依赖程序的版本信息：<img src="https://img.shields.io/badge/mysql--connector--java-v8.0.17-green"/></p></blockquote><h2 id="一、认识loadbalance模式"><a href="#一、认识loadbalance模式" class="headerlink" title="一、认识loadbalance模式"></a>一、认识loadbalance模式</h2><p>首先回忆下jdbc协议头都有哪些，下面总结下：</p><p><img src="http://myblog.sharemer.com/2020/06/02/20200602-1-1.png" alt="表1"></p><span id="more"></span><p>通过<code>表1</code>，可以知道在loadblance模式下允许配置多个mysql节点信息，而我们每次建连时，驱动程序就会按照配置的节点，选中一个，然后完成连接的创建，下面我们来探索下它的实现。</p><h2 id="二、基本使用"><a href="#二、基本使用" class="headerlink" title="二、基本使用"></a>二、基本使用</h2><p>它的基本用法跟其他模式没有区别：</p><figure class="highlight java"><figcaption><span>代码块1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql:loadbalance://127.0.0.1:3306,127.0.0.2:3306,127.0.0.3:3306/mydb&quot;</span>;</span><br><span class="line">    <span class="type">LoadBalancedConnection</span> <span class="variable">connection</span> <span class="operator">=</span> (LoadBalancedConnection) DriverManager.getConnection(url, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (statement.execute(<span class="string">&quot;select * from t_season&quot;</span>)) &#123;</span><br><span class="line">            rs = statement.getResultSet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rs != <span class="literal">null</span>) &#123;</span><br><span class="line">            rs.close();</span><br><span class="line">        &#125;</span><br><span class="line">        statement.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、驱动加载流程"><a href="#三、驱动加载流程" class="headerlink" title="三、驱动加载流程"></a>三、驱动加载流程</h2><p>jdbc是如何知道我们启用了loadbalance模式的？先来了解下<code>DriverManager</code>的<code>getConnection</code>方法，注意这里的DriverManager在java.sql包内，它属于jdk自带的类，目的是扫描所有实现了java.sql.Driver的类，而我们所使用的<code>mysql-connector-java</code>程序就实现了Driver接口，所以很容易被DriverManager载入，下面来看它是如何完成驱动程序扫描与加载的：</p><figure class="highlight java"><figcaption><span>代码块2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">(String url,</span></span><br><span class="line"><span class="params">                                       String user, String password)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    java.util.<span class="type">Properties</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.util.Properties();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">        info.put(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (password != <span class="literal">null</span>) &#123;</span><br><span class="line">        info.put(<span class="string">&quot;password&quot;</span>, password);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//说明：Reflection.getCallerClass()是个本地方法，会返回调用当前这个方法的那个类的名字（后续我们称其为callerClass）</span></span><br><span class="line">    <span class="keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">(</span></span><br><span class="line"><span class="params">        String url, java.util.Properties info, Class&lt;?&gt; caller)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//获取callerClass的类加载器</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">callerCL</span> <span class="operator">=</span> caller != <span class="literal">null</span> ? caller.getClassLoader() : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (callerCL == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//若找不到对应的类加载器，则默认为当前线程的类加载器</span></span><br><span class="line">        callerCL = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (url == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(<span class="string">&quot;The url cannot be null&quot;</span>, <span class="string">&quot;08001&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    println(<span class="string">&quot;DriverManager.getConnection(\&quot;&quot;</span> + url + <span class="string">&quot;\&quot;)&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//这个方法会通过SPI机制加载可以加载的实现了JDBC协议的驱动程序，我们通常用的是mysql-connector-java里的驱动类，某些连接池技术也会搞一个自己的驱动类（比如Druid的DruidDriver）</span></span><br><span class="line">    <span class="comment">//在里面会完成Driver实现类的类加载，而驱动程序只需要在静态块里将自己的实例new出来，注册到DriverManager里即可（可以去mysql-connector-java的Driver类里确认是否有该逻辑）</span></span><br><span class="line">    <span class="comment">//所以现在我们根本不需要跟以前写jdbc程序那样写一次Class.forName的代码，这个方法已经帮我们做了（参考图1，驱动程序已经满足SPI加载配置的条件）</span></span><br><span class="line">    ensureDriversInitialized();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Walk through the loaded registeredDrivers attempting to make a connection.</span></span><br><span class="line">    <span class="comment">// Remember the first exception that gets raised so we can reraise it.</span></span><br><span class="line">    <span class="type">SQLException</span> <span class="variable">reason</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (DriverInfo aDriver : registeredDrivers) &#123; <span class="comment">//循环已经成功加载到的驱动实现</span></span><br><span class="line">        <span class="comment">// If the caller does not have permission to load the driver then</span></span><br><span class="line">        <span class="comment">// skip it.</span></span><br><span class="line">        <span class="keyword">if</span> (isDriverAllowed(aDriver.driver, callerCL)) &#123; <span class="comment">//这个解释在下面对应的方法里，还是挺有意思的一个方法</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                println(<span class="string">&quot;    trying &quot;</span> + aDriver.driver.getClass().getName());</span><br><span class="line">                <span class="comment">//这里是利用驱动程序获取到一个Connection对象，后面会详细讲</span></span><br><span class="line">                <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> aDriver.driver.connect(url, info);</span><br><span class="line">                <span class="keyword">if</span> (con != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Success!</span></span><br><span class="line">                    println(<span class="string">&quot;getConnection returning &quot;</span> + aDriver.driver.getClass().getName());</span><br><span class="line">                    <span class="keyword">return</span> (con);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (reason == <span class="literal">null</span>) &#123;</span><br><span class="line">                    reason = ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            println(<span class="string">&quot;    skipping: &quot;</span> + aDriver.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// if we got here nobody could connect.</span></span><br><span class="line">    <span class="keyword">if</span> (reason != <span class="literal">null</span>)    &#123;</span><br><span class="line">        println(<span class="string">&quot;getConnection failed: &quot;</span> + reason);</span><br><span class="line">        <span class="keyword">throw</span> reason;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    println(<span class="string">&quot;getConnection: no suitable driver found for &quot;</span>+ url);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(<span class="string">&quot;No suitable driver found for &quot;</span>+ url, <span class="string">&quot;08001&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isDriverAllowed</span><span class="params">(Driver driver, Class&lt;?&gt; caller)</span> &#123;</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">callerCL</span> <span class="operator">=</span> caller != <span class="literal">null</span> ? caller.getClassLoader() : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> isDriverAllowed(driver, callerCL);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//该方法主要用来做驱动加载，以及判断加载了驱动Driver对象的类加载器跟callerClass的类加载器是否一致，若一致才返回true，反之为false</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isDriverAllowed</span><span class="params">(Driver driver, ClassLoader classLoader)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (driver != <span class="literal">null</span>) &#123;</span><br><span class="line">        Class&lt;?&gt; aClass = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//这里算是给驱动类调整了类加载器，将第一次进行类加载时加载到的Class对象里的类加载器统一成callerClass的</span></span><br><span class="line">            aClass =  Class.forName(driver.getClass().getName(), <span class="literal">true</span>, classLoader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            result = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里会再确认一次driver对象此时对应的Class是否跟被调整了类加载器的Class一致（如果不出意外，这里应该是一致的）</span></span><br><span class="line">        result = ( aClass == driver.getClass() ) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>驱动程序的<code>SPI</code>支持：</p><p><img src="http://myblog.sharemer.com/2020/06/02/20200602-1-2.png" alt="图1"></p><p>通过上述代码，可以确认最终是通过<code>驱动程序Driver实现类</code>的<code>connect方法</code>产生的<code>Connection对象</code>，下面来看下驱动程序Driver里的实现：</p><figure class="highlight java"><figcaption><span>代码块3</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码所属类：com.mysql.cj.jdbc.NonRegisteringDriver</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> java.sql.Connection <span class="title function_">connect</span><span class="params">(String url, Properties info)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//验证传入的url是否符合jdbc连接规范</span></span><br><span class="line">        <span class="keyword">if</span> (!ConnectionUrl.acceptsUrl(url)) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * According to JDBC spec:</span></span><br><span class="line"><span class="comment">             * The driver should return &quot;null&quot; if it realizes it is the wrong kind of driver to connect to the given URL. This will be common, as when the</span></span><br><span class="line"><span class="comment">             * JDBC driver manager is asked to connect to a given URL it passes the URL to each loaded driver in turn.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//根据传入的信息，获得一个包装了连接信息的对象</span></span><br><span class="line">        <span class="type">ConnectionUrl</span> <span class="variable">conStr</span> <span class="operator">=</span> ConnectionUrl.getConnectionUrlInstance(url, info);</span><br><span class="line">        <span class="keyword">switch</span> (conStr.getType()) &#123; <span class="comment">//这个Type是根据jdbc协议头分析出来的，应该给一个对应协议头类型的Connection实例</span></span><br><span class="line">            <span class="keyword">case</span> SINGLE_CONNECTION: <span class="comment">//jdbc:mysql:开头的url会命中下方逻辑</span></span><br><span class="line">                <span class="keyword">return</span> com.mysql.cj.jdbc.ConnectionImpl.getInstance(conStr.getMainHost());</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">case</span> LOADBALANCE_CONNECTION: <span class="comment">//jdbc:mysql:loadbalance:开头的url会命中下方逻辑（负载均衡），也是本节要讲的重点</span></span><br><span class="line">                <span class="keyword">return</span> LoadBalancedConnectionProxy.createProxyInstance((LoadbalanceConnectionUrl) conStr);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">case</span> FAILOVER_CONNECTION: <span class="comment">//jdbc:mysql:开头且配置了多个节点的情况会命中下方逻辑（故障转移）</span></span><br><span class="line">                <span class="keyword">return</span> FailoverConnectionProxy.createProxyInstance(conStr);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">case</span> REPLICATION_CONNECTION: <span class="comment">//jdbc:mysql:replication:开头的url会命中下方逻辑（主从）</span></span><br><span class="line">                <span class="keyword">return</span> ReplicationConnectionProxy.createProxyInstance((ReplicationConnectionUrl) conStr);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedConnectionStringException e) &#123;</span><br><span class="line">        <span class="comment">// when Connector/J can&#x27;t handle this connection string the Driver must return null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">catch</span> (CJException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionFactory.createException(UnableToConnectException.class,</span><br><span class="line">                Messages.getString(<span class="string">&quot;NonRegisteringDriver.17&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; ex.toString() &#125;), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，可以看到驱动程序之所以会知道我们启用了loadbalance模式，是因为我们所配置的<code>jdbc连接协议头</code>，根据协议头的不同，会被路由进不同的Connection实现，然后最终将Connection对象返回给用户。</p><h2 id="四、驱动程序对LoadBalance的支持"><a href="#四、驱动程序对LoadBalance的支持" class="headerlink" title="四、驱动程序对LoadBalance的支持"></a>四、驱动程序对LoadBalance的支持</h2><p>下面重点看下命中<code>LOADBALANCE_CONNECTION</code>条件的<code>LoadBalancedConnectionProxy.createProxyInstance</code>的内部逻辑：</p><figure class="highlight java"><figcaption><span>代码块4</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建LoadBalancedConnection对象，并为其加上动态代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LoadBalancedConnection <span class="title function_">createProxyInstance</span><span class="params">(LoadbalanceConnectionUrl connectionUrl)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="type">LoadBalancedConnectionProxy</span> <span class="variable">connProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoadBalancedConnectionProxy</span>(connectionUrl);</span><br><span class="line">    <span class="comment">//返回的是一个被LoadBalancedConnectionProxy代理了的LoadBalancedConnection对象</span></span><br><span class="line">    <span class="keyword">return</span> (LoadBalancedConnection) java.lang.reflect.Proxy.newProxyInstance(LoadBalancedConnection.class.getClassLoader(), INTERFACES_TO_PROXY, connProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1：LoadBalance模式相关的类关系图"><a href="#4-1：LoadBalance模式相关的类关系图" class="headerlink" title="4.1：LoadBalance模式相关的类关系图"></a>4.1：LoadBalance模式相关的类关系图</h3><p>到这里为止，我们已经进入了loadblance模式内部，这里返回的是一个被代理了的<code>LoadBalancedConnection</code>对象，下面来梳理下它们的继承和代理关系（之后重点分析的字段和方法字体均已<code>标红</code>）：</p><p><img src="http://myblog.sharemer.com/2020/06/02/20200602-1-3-fix.png?imageView2/0/w/1100" alt="图2"></p><p>理清关系后，来看下最主要的几个属性和方法的实现。</p><p><code>代码块4</code>里直接new出了LoadBalancedConnectionProxy类，并且代理的目标类为LoadBalancedConnection，通过上图，可以知道就是最终返回给用户的那个Connection对象，意味着用户拿着这个Connection做任何操作都会触发LoadBalancedConnectionProxy的invokeMore方法（通过图中展示，其父类实现了<code>InvocationHandler接口</code>，其<code>invoke</code>会触发<code>invokeMore</code>方法，而<code>invokeMore方法的实现在LoadBalancedConnectionProxy里</code>）</p><h3 id="4-2：LoadBalancedConnectionProxy-balancer属性"><a href="#4-2：LoadBalancedConnectionProxy-balancer属性" class="headerlink" title="4.2：LoadBalancedConnectionProxy.balancer属性"></a>4.2：LoadBalancedConnectionProxy.balancer属性</h3><p>这是个属性，它包装了一个<code>Balancer</code>对象，内部有自己的<code>LB算法</code>，它的初始化如下：</p><figure class="highlight java"><figcaption><span>代码块4</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拿到指定的LB算法，不配置的话默认是random，如果你想要指定，可以在jdbc连接后面追加haLoadBalanceStrategy参数，让其等于你指定的LB算法类型即可</span></span><br><span class="line"><span class="comment">//LB算法类型可选值在下面的switch内部，当然，你也可以自定义，自定义的话就需要传实现类的路径给这个参数了</span></span><br><span class="line"><span class="type">String</span> <span class="variable">strategy</span> <span class="operator">=</span> props.getProperty(PropertyKey.ha_loadBalanceStrategy.getKeyName(), <span class="string">&quot;random&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (strategy) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;random&quot;</span>:</span><br><span class="line">            <span class="built_in">this</span>.balancer = <span class="keyword">new</span> <span class="title class_">RandomBalanceStrategy</span>(); <span class="comment">//random算法的实现类，默认算法</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;bestResponseTime&quot;</span>:</span><br><span class="line">            <span class="built_in">this</span>.balancer = <span class="keyword">new</span> <span class="title class_">BestResponseTimeBalanceStrategy</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;serverAffinity&quot;</span>:</span><br><span class="line">            <span class="built_in">this</span>.balancer = <span class="keyword">new</span> <span class="title class_">ServerAffinityStrategy</span>(props.getProperty(PropertyKey.serverAffinityOrder.getKeyName(), <span class="literal">null</span>));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">//你可以按需自定义LB算法，这里是通过反射的方式初始化你给定的LB算法类的</span></span><br><span class="line">            <span class="built_in">this</span>.balancer = (BalanceStrategy) Class.forName(strategy).newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="keyword">throw</span> SQLError.createSQLException(Messages.getString(<span class="string">&quot;InvalidLoadBalanceStrategy&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; strategy &#125;),</span><br><span class="line">            MysqlErrorNumbers.SQL_STATE_ILLEGAL_ARGUMENT, t, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只关注<code>Random</code>即可，它的内部实现就是简单的从<code>LoadBalancedConnectionProxy.liveConnections</code>里随机选一个节点，然后返回出去，为了更加清晰，不再贴代码，大致流程如下（绿色框逻辑都属于<code>RandomBalancer</code>本身的逻辑，除此之外，图中标注了<code>hostList</code>属性的数据来源）：</p><p><img src="http://myblog.sharemer.com/2020/06/02/20200602-1-4.png?imageView2/0/w/900" alt="图3"></p><p>它的触发点就是在<code>LoadBalancedConnectionProxy.pickNewConnection</code>方法（参考下方<code>4.3</code>），即发生在选取节点时。</p><h3 id="4-3：LoadBalancedConnectionProxy-pickNewConnection方法"><a href="#4-3：LoadBalancedConnectionProxy-pickNewConnection方法" class="headerlink" title="4.3：LoadBalancedConnectionProxy.pickNewConnection方法"></a>4.3：LoadBalancedConnectionProxy.pickNewConnection方法</h3><p>这个方法是非常核心的功能，每次变换节点时都会触发的一个方法，下面来看下其内部逻辑：</p><figure class="highlight java"><figcaption><span>代码块5</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pick节点核心方法，利用balancer对象刷新currentConnection的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">pickNewConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isClosed &amp;&amp; <span class="built_in">this</span>.closedExplicitly) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    List&lt;String&gt; hostPortList = Collections.unmodifiableList(<span class="built_in">this</span>.hostsList.stream().map(hi -&gt; hi.getHostPortPair()).collect(Collectors.toList()));</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.currentConnection == <span class="literal">null</span>) &#123; <span class="comment">// startup</span></span><br><span class="line">        <span class="comment">//如果currentConnection为空，则开始利用balancer选取节点</span></span><br><span class="line">        <span class="built_in">this</span>.currentConnection = <span class="built_in">this</span>.balancer.pickConnection(<span class="built_in">this</span>, hostPortList, Collections.unmodifiableMap(<span class="built_in">this</span>.liveConnections),</span><br><span class="line">                <span class="built_in">this</span>.responseTimes.clone(), <span class="built_in">this</span>.retriesAllDown);</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//终止</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.currentConnection.isClosed()) &#123;</span><br><span class="line">        invalidateCurrentConnection(); <span class="comment">//若发现当前连接已经被关闭了，则抛弃这个连接</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> <span class="variable">pingTimeout</span> <span class="operator">=</span> <span class="built_in">this</span>.currentConnection.getPropertySet().getIntegerProperty(PropertyKey.loadBalancePingTimeout).getValue();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">pingBeforeReturn</span> <span class="operator">=</span> <span class="built_in">this</span>.currentConnection.getPropertySet().getBooleanProperty(PropertyKey.loadBalanceValidateConnectionOnSwapServer).getValue();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//重试逻辑，若pick不成功，则在有限的次数内重试（这个次数就是hostsList的size）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">hostsTried</span> <span class="operator">=</span> <span class="number">0</span>, hostsToTry = <span class="built_in">this</span>.hostsList.size(); hostsTried &lt; hostsToTry; hostsTried++) &#123;</span><br><span class="line">        <span class="type">ConnectionImpl</span> <span class="variable">newConn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//pick节点</span></span><br><span class="line">            newConn = (ConnectionImpl) <span class="built_in">this</span>.balancer.pickConnection(<span class="built_in">this</span>, hostPortList, Collections.unmodifiableMap(<span class="built_in">this</span>.liveConnections),</span><br><span class="line">                    <span class="built_in">this</span>.responseTimes.clone(), <span class="built_in">this</span>.retriesAllDown);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.currentConnection != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pingBeforeReturn) &#123; <span class="comment">//ping检查，检查失败会抛SQLException，下方异常处理里会把它抛弃掉</span></span><br><span class="line">                    newConn.pingInternal(<span class="literal">true</span>, pingTimeout);</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="comment">//同步旧currentConnection节点的属性给这个新pick出来的节点，比如read-only、auto-commit什么的</span></span><br><span class="line">                syncSessionState(<span class="built_in">this</span>.currentConnection, newConn);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//刷新currentConnection的值为新pick出来的这个连接</span></span><br><span class="line">            <span class="built_in">this</span>.currentConnection = newConn;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//终止</span></span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (shouldExceptionTriggerConnectionSwitch(e) &amp;&amp; newConn != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// connection error, close up shop on current connection</span></span><br><span class="line">                invalidateConnection(newConn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// no hosts available to swap connection to, close up.</span></span><br><span class="line">    <span class="built_in">this</span>.isClosed = <span class="literal">true</span>; <span class="comment">//如果将hostsList集合pick了一遍都没有找到可用的连接，则认为pick失败，标记isClosed为true</span></span><br><span class="line">    <span class="built_in">this</span>.closedReason = <span class="string">&quot;Connection closed after inability to pick valid new connection during load-balance.&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4：MultiHostConnectionProxy-invoke方法"><a href="#4-4：MultiHostConnectionProxy-invoke方法" class="headerlink" title="4.4：MultiHostConnectionProxy.invoke方法"></a>4.4：MultiHostConnectionProxy.invoke方法</h3><p>这是<code>MultiHostConnectionProxy</code>对<code>InvocationHandler</code>接口的实现，通过<code>图2</code>可以知道，它的子类<code>LoadBalancedConnectionProxy</code>是返回给用户的<code>LoadBalancedConnection</code>的代理类，意味着用户利用Connection做的每一步操作，都会命中这个<code>invoke</code>方法的调用，下面来看下这个方法的实现：</p><figure class="highlight java"><figcaption><span>代码块6</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getName();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//若被调用的方法是getMultiHostSafeProxy，则直接返回代理对象本身（也即是用户正在使用的那个Connection对象）</span></span><br><span class="line">    <span class="keyword">if</span> (METHOD_GET_MULTI_HOST_SAFE_PROXY.equals(methodName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.thisAsConnection;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//被调用的方法是equals所执行的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (METHOD_EQUALS.equals(methodName)) &#123;</span><br><span class="line">        <span class="comment">// Let args[0] &quot;unwrap&quot; to its InvocationHandler if it is a proxy.</span></span><br><span class="line">        <span class="keyword">return</span> args[<span class="number">0</span>].equals(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//被调用的方法是hashCode所执行的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (METHOD_HASH_CODE.equals(methodName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//若被调用的方法是close，则关闭并清理掉所有的连接（liveConnections.clear）</span></span><br><span class="line">    <span class="keyword">if</span> (METHOD_CLOSE.equals(methodName)) &#123;</span><br><span class="line">        doClose();</span><br><span class="line">        <span class="built_in">this</span>.isClosed = <span class="literal">true</span>; <span class="comment">//标记isClosed为true</span></span><br><span class="line">        <span class="built_in">this</span>.closedReason = <span class="string">&quot;Connection explicitly closed.&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.closedExplicitly = <span class="literal">true</span>; <span class="comment">//标记closedExplicitly为true，意思是说这是由用户&quot;显式关闭&quot;的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//被调用的方法是abortInternal所执行的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (METHOD_ABORT_INTERNAL.equals(methodName)) &#123;</span><br><span class="line">        doAbortInternal();</span><br><span class="line">        <span class="built_in">this</span>.currentConnection.abortInternal();</span><br><span class="line">        <span class="built_in">this</span>.isClosed = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">this</span>.closedReason = <span class="string">&quot;Connection explicitly closed.&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//被调用的方法是abort所执行的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (METHOD_ABORT.equals(methodName) &amp;&amp; args.length == <span class="number">1</span>) &#123;</span><br><span class="line">        doAbort((Executor) args[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">this</span>.isClosed = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">this</span>.closedReason = <span class="string">&quot;Connection explicitly closed.&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//被调用的方法是isClosed所执行的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (METHOD_IS_CLOSED.equals(methodName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.isClosed;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//若调用的方法不是上面的任意一种，则直接触发其子类的invokeMore方法（下面分析）</span></span><br><span class="line">        <span class="keyword">return</span> invokeMore(proxy, method, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.getCause() != <span class="literal">null</span> ? e.getCause() : e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// Check if the captured exception must be wrapped by an unchecked exception.</span></span><br><span class="line">        Class&lt;?&gt;[] declaredException = method.getExceptionTypes();</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; declEx : declaredException) &#123;</span><br><span class="line">            <span class="keyword">if</span> (declEx.isAssignableFrom(e.getClass())) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5：LoadBalancedConnectionProxy-invokeMore方法"><a href="#4-5：LoadBalancedConnectionProxy-invokeMore方法" class="headerlink" title="4.5：LoadBalancedConnectionProxy.invokeMore方法"></a>4.5：LoadBalancedConnectionProxy.invokeMore方法</h3><p>紧接着上面的代码来看，了解下<code>invokMore</code>方法（根据<code>图2</code>可知，此方法为抽象方法，由子类实现，所以它的<code>实现逻辑</code>在<code>LoadBalancedConnectionProxy</code>里）</p><figure class="highlight java"><figcaption><span>代码块7</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title function_">invokeMore</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getName();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//重连机制判断，如果当前连接状态已被关闭，这里的关闭是指currentConnection的isClosed为true，而使isClosed为true的地方为：</span></span><br><span class="line">    <span class="comment">//① 用户手动调用Connection.close，这种被称为&quot;显式关闭&quot;，这种关闭方式连同closedExplicitly也会被置为true</span></span><br><span class="line">    <span class="comment">//② abort连接、ping检查失败、pickNewConnection时pick不出可用节点，都会使isClosed为true，但closedExplicitly依然为false</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isClosed &amp;&amp; !allowedOnClosedConnection(method) &amp;&amp; method.getExceptionTypes().length &gt; <span class="number">0</span>) &#123; <span class="comment">// TODO remove method.getExceptionTypes().length ?</span></span><br><span class="line">        <span class="comment">//结合上方说的②，如果你设置了autoReconnect机制（自动重连），那么就可以在任意&quot;非显式&quot;close的情况下，刷新currentConnection的值，使其可用</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.autoReconnect &amp;&amp; !<span class="built_in">this</span>.closedExplicitly) &#123;</span><br><span class="line">            <span class="built_in">this</span>.currentConnection = <span class="literal">null</span>;</span><br><span class="line">            pickNewConnection(); <span class="comment">//在自动重连开启的情况下，当你的连接被非正常关闭后，会尝试重新pick节点，确保其可用</span></span><br><span class="line">            <span class="built_in">this</span>.isClosed = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">this</span>.closedReason = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果没有开启重连模式，那么在isClose为true时，就直接抛出错误</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">reason</span> <span class="operator">=</span> <span class="string">&quot;No operations allowed after connection closed.&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.closedReason != <span class="literal">null</span>) &#123;</span><br><span class="line">                reason += <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.closedReason;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; excls : method.getExceptionTypes()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (SQLException.class.isAssignableFrom(excls)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> SQLError.createSQLException(reason, MysqlErrorNumbers.SQL_STATE_CONNECTION_NOT_OPEN,</span><br><span class="line">                            <span class="literal">null</span> <span class="comment">/* no access to an interceptor here... */</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> ExceptionFactory.createException(CJCommunicationsException.class, reason);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.inTransaction) &#123;</span><br><span class="line">        <span class="built_in">this</span>.inTransaction = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">this</span>.transactionStartTime = System.nanoTime();</span><br><span class="line">        <span class="built_in">this</span>.transactionCount++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//触发实际的方法逻辑</span></span><br><span class="line">        result = method.invoke(<span class="built_in">this</span>.thisAsConnection, args);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (result <span class="keyword">instanceof</span> com.mysql.cj.jdbc.JdbcStatement) &#123;</span><br><span class="line">                ((com.mysql.cj.jdbc.JdbcStatement) result).setPingTarget(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里是给方法返回的对象加一层代理（跟本次重点无关，不再详述）</span></span><br><span class="line">            result = proxyIfReturnTypeIsJdbcInterface(method.getReturnType(), result);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        dealWithInvocationException(e);</span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//重点是，当发现触发的方法是commit或rollback时，会刷新一下currentConnection的值，重新pick出一个</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;commit&quot;</span>.equals(methodName) || <span class="string">&quot;rollback&quot;</span>.equals(methodName)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.inTransaction = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// Update stats</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> <span class="built_in">this</span>.connectionsToHostsMap.get(<span class="built_in">this</span>.currentConnection);</span><br><span class="line">            <span class="comment">// avoid NPE if the connection has already been removed from connectionsToHostsMap in invalidateCurrenctConnection()</span></span><br><span class="line">            <span class="keyword">if</span> (host != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>.responseTimes) &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">hostIndex</span> <span class="operator">=</span> (<span class="built_in">this</span>.hostsToListIndexMap.get(host));</span><br><span class="line"> </span><br><span class="line">                    <span class="keyword">if</span> (hostIndex != <span class="literal">null</span> &amp;&amp; hostIndex &lt; <span class="built_in">this</span>.responseTimes.length) &#123;</span><br><span class="line">                        <span class="comment">//更新对应节点执行事务所花费的时间</span></span><br><span class="line">                        <span class="built_in">this</span>.responseTimes[hostIndex] = System.nanoTime() - <span class="built_in">this</span>.transactionStartTime;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//刷新currentConnection的值</span></span><br><span class="line">            pickNewConnection();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这块代码可以知道，一个LoadBalance模式下的连接被创建出来后，除非是<code>commit</code>或<code>rollback</code>事务，否则该Connection对象里的<code>currentConnection</code>永远都<code>不会变</code>，当然，通过上述代码看，还有一种情况是会变的，那就是当前连接坏掉，然后<code>ping</code>检查失败<code>isClose</code>被标记为<code>true</code>，你的配置里恰好又<code>开启</code>了<code>autoReconnect</code>，这时才会<code>重新pick</code>新的节点。</p><h2 id="五、猜想"><a href="#五、猜想" class="headerlink" title="五、猜想"></a>五、猜想</h2><p>通过对其代码实现的分析，可以得出如下猜想：</p><ol><li><code>不配autoReconnect</code>的情况下，只有在利用该连接对象<code>提交</code>、<code>回滚</code>事务时才会<code>pick</code>新的节点。</li><li><code>配置autoReconnect</code>的情况下，在节点<code>坏掉</code>后，会<code>pick</code>一次节点，事务<code>提交</code>、<code>回滚</code>一样会<code>pick</code>节点。</li><li>综上，如果我要实现一个<code>select查询</code>也需要<code>pick</code>节点实现负载均衡的情况下，不可以用<code>单例Connection</code>，因为普通select<code>并不会</code>触发<code>pick</code>操作。</li><li>综合3，想要实现全部意义的LB，必须要使用<code>多实例模式</code>，这样虽然实现了我想要的LB效果，但代价是巨大的，因为每次都会<code>建连</code>。</li><li>利用<code>连接池</code>可以一定程度上解决这种问题，连接池可以预先建连一堆Connection对象，这些对象如果在创建时启用jdbc LoadBalance模式，那么意味着每个连接都是<code>随机节点</code>。</li></ol><h2 id="六、验证"><a href="#六、验证" class="headerlink" title="六、验证"></a>六、验证</h2><p>为了验证<code>第五节</code>的结论，我们简单做个试验验证下。</p><h3 id="6-1：单例模式下的Query操作"><a href="#6-1：单例模式下的Query操作" class="headerlink" title="6.1：单例模式下的Query操作"></a>6.1：单例模式下的Query操作</h3><figure class="highlight java"><figcaption><span>代码块8</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql:loadbalance://172.22.119.38:4000,172.22.119.8:4000,172.22.119.30:4000/tidb_test&quot;</span>;</span><br><span class="line">        <span class="type">LoadBalancedConnection</span> <span class="variable">connection</span> <span class="operator">=</span> (LoadBalancedConnection) DriverManager.getConnection(url, <span class="string">&quot;tidb_test&quot;</span>, <span class="string">&quot;lPoK3QMSWY1BhSa3WCT1IWOXYkMc3Aqd&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123; <span class="comment">//利用同一个connection对象执行100次查询操作</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                test.triggerQuery(connection);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//为了保证是单例模式，这里不再close</span></span><br><span class="line">                <span class="comment">//connection.close();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">triggerQuery</span><span class="params">(LoadBalancedConnection connection)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//这里打印下当前参与执行sql的连接host</span></span><br><span class="line">            System.out.println(<span class="string">&quot;current conn host: &quot;</span> + connection.getHost());</span><br><span class="line">            <span class="keyword">if</span> (statement.execute(<span class="string">&quot;select * from t_student where id = 1&quot;</span>)) &#123;</span><br><span class="line">                rs = statement.getResultSet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (rs != <span class="literal">null</span>) &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125;</span><br><span class="line">            statement.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码运行结果打印如下：</p><figure class="highlight shell"><figcaption><span>代码块9</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">current conn host: 172.22.119.30</span><br><span class="line">current conn host: 172.22.119.30</span><br><span class="line">current conn host: 172.22.119.30</span><br><span class="line">current conn host: 172.22.119.30</span><br><span class="line">current conn host: 172.22.119.30</span><br><span class="line">current conn host: 172.22.119.30</span><br><span class="line">current conn host: 172.22.119.30</span><br><span class="line">...省略，共100条...</span><br></pre></td></tr></table></figure><p>可以看到，如果一直用同一个Connection对象去createStatement，然后执行Query，那么节点始终是一开始pick好的那个，且<code>永远不会变</code>。</p><h3 id="6-2：多实例下的Query操作"><a href="#6-2：多实例下的Query操作" class="headerlink" title="6.2：多实例下的Query操作"></a>6.2：多实例下的Query操作</h3><p>这个其实根本没有测试的必要，多实例意味着每次Query前都会<code>新建一个连接</code>对象，新建一个意味着会<code>pick</code>一次，那肯定是<code>random</code>的，我们改下main方法的代码：</p><figure class="highlight java"><figcaption><span>代码块10</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql:loadbalance://172.22.119.38:4000,172.22.119.8:4000,172.22.119.30:4000/tidb_test&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//将创建connection连接放到循环体里面，使每次传给triggerQuery方法的都是不同的Connection对象</span></span><br><span class="line">        <span class="type">LoadBalancedConnection</span> <span class="variable">connection</span> <span class="operator">=</span> (LoadBalancedConnection) DriverManager.getConnection(url, <span class="string">&quot;tidb_test&quot;</span>, <span class="string">&quot;lPoK3QMSWY1BhSa3WCT1IWOXYkMc3Aqd&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test.triggerQuery(connection);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//别忘了close资源</span></span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次运行结果如下：</p><figure class="highlight shell"><figcaption><span>代码块11</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">current conn host: 172.22.119.8</span><br><span class="line">current conn host: 172.22.119.8</span><br><span class="line">current conn host: 172.22.119.8</span><br><span class="line">current conn host: 172.22.119.38</span><br><span class="line">current conn host: 172.22.119.30</span><br><span class="line">current conn host: 172.22.119.38</span><br><span class="line">current conn host: 172.22.119.8</span><br><span class="line">current conn host: 172.22.119.8</span><br><span class="line">current conn host: 172.22.119.38</span><br><span class="line">...省略，共100条...</span><br></pre></td></tr></table></figure><p>可以看到，已经触发了LB算法了（这是预料之中的）。</p><p>你可能会问，如果调用了<code>close</code>呢？会不会close不是真的close，而是<code>触发pick</code>呢？正常情况下肯定会这样实现的吧？其实并不会，close的逻辑是把里面<code>所有的liveConnections清空</code>，然后<code>close一遍</code>，所以下面的代码会报错：</p><figure class="highlight java"><figcaption><span>代码块12</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql:loadbalance://172.22.119.38:4000,172.22.119.8:4000,172.22.119.30:4000/tidb_test&quot;</span>;</span><br><span class="line">    <span class="comment">//仍然是单例的Connection对象</span></span><br><span class="line">    <span class="type">LoadBalancedConnection</span> <span class="variable">connection</span> <span class="operator">=</span> (LoadBalancedConnection) DriverManager.getConnection(url, <span class="string">&quot;tidb_test&quot;</span>, <span class="string">&quot;lPoK3QMSWY1BhSa3WCT1IWOXYkMc3Aqd&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test.triggerQuery(connection);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            connection.close(); <span class="comment">//这里close掉</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="http://myblog.sharemer.com/2020/06/02/20200602-1-5.png" alt="图4"></p><p>是的。。它直接报错了，也就是说，在select这种语句的执行下，要么你用<code>多实例</code>，每次都<code>建连</code>，实现你心目中的LB，要么你就用<code>单例</code>，然后<code>一个连接用到底</code>。。</p><p>但是它并非一无是处，比如，你可以结合<code>连接池</code>来用它，这样既可以保证<code>连接复用</code>，也可以保证池内每个连接对象的host在最大限度上不是同一个。</p><h3 id="6-3：单例模式下的事务操作"><a href="#6-3：单例模式下的事务操作" class="headerlink" title="6.3：单例模式下的事务操作"></a>6.3：单例模式下的事务操作</h3><p>按照源码上的理解，理论上即便是<code>单例</code>，<code>开启事务</code>并提交的时候也会<code>切换</code>一次host，现在将前面的测试代码改成下面这样：</p><figure class="highlight java"><figcaption><span>代码块13</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql:loadbalance://172.22.119.38:4000,172.22.119.8:4000,172.22.119.30:4000/tidb_test&quot;</span>;</span><br><span class="line">    <span class="comment">//仍然是单例的Connection对象</span></span><br><span class="line">    <span class="type">LoadBalancedConnection</span> <span class="variable">connection</span> <span class="operator">=</span> (LoadBalancedConnection) DriverManager.getConnection(url, <span class="string">&quot;tidb_test&quot;</span>, <span class="string">&quot;lPoK3QMSWY1BhSa3WCT1IWOXYkMc3Aqd&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test.triggerTransaction(connection);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//为了保证是单例模式，这里不再close</span></span><br><span class="line">            <span class="comment">//connection.close();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//开启事务的方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">triggerTransaction</span><span class="params">(LoadBalancedConnection connection)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    connection.setAutoCommit(<span class="literal">false</span>); <span class="comment">//关闭自动提交</span></span><br><span class="line">    <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//这里打印下当前参与执行sql的连接host</span></span><br><span class="line">        System.out.println(<span class="string">&quot;current conn host: &quot;</span> + connection.getHost());</span><br><span class="line">        <span class="keyword">if</span> (statement.execute(<span class="string">&quot;select * from t_student where id = 1&quot;</span>)) &#123;</span><br><span class="line">            rs = statement.getResultSet();</span><br><span class="line">        &#125;</span><br><span class="line">        connection.commit(); <span class="comment">//事务提交</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rs != <span class="literal">null</span>) &#123;</span><br><span class="line">            rs.close();</span><br><span class="line">        &#125;</span><br><span class="line">        statement.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight shell"><figcaption><span>代码块14</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">current conn host: 172.22.119.8</span><br><span class="line">current conn host: 172.22.119.30</span><br><span class="line">current conn host: 172.22.119.8</span><br><span class="line">current conn host: 172.22.119.30</span><br><span class="line">current conn host: 172.22.119.38</span><br><span class="line">current conn host: 172.22.119.30</span><br><span class="line">current conn host: 172.22.119.38</span><br><span class="line">current conn host: 172.22.119.30</span><br><span class="line">current conn host: 172.22.119.8</span><br><span class="line">current conn host: 172.22.119.30</span><br><span class="line">...省略，共100条...</span><br></pre></td></tr></table></figure><p>这是符合预期的，因为即便是单实例，每次处理事务的节点也发生了变换。</p><p>多实例就不再试了，没有必要。</p><h3 id="6-4：开启autoReconnect时，单例执行Query操作"><a href="#6-4：开启autoReconnect时，单例执行Query操作" class="headerlink" title="6.4：开启autoReconnect时，单例执行Query操作"></a>6.4：开启autoReconnect时，单例执行Query操作</h3><p>按照我们的结论，这个只有在节点坏掉时才会重新pick节点，以保证可用性，那么我们现在来开启它，然后依然用单例模式操作Query，代码改写如下：</p><figure class="highlight java"><figcaption><span>代码块15</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql:loadbalance://172.22.119.38:4000,172.22.119.8:4000,172.22.119.30:4000/tidb_test?autoReconnect=true&quot;</span>; <span class="comment">//带上autoReconnect参数，使其为true</span></span><br><span class="line">    <span class="comment">//仍然是单例的Connection对象</span></span><br><span class="line">    <span class="type">LoadBalancedConnection</span> <span class="variable">connection</span> <span class="operator">=</span> (LoadBalancedConnection) DriverManager.getConnection(url, <span class="string">&quot;tidb_test&quot;</span>, <span class="string">&quot;lPoK3QMSWY1BhSa3WCT1IWOXYkMc3Aqd&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test.triggerQuery(connection);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//为了保证是单例模式，这里不再close</span></span><br><span class="line">            <span class="comment">//connection.close();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果打印如下：</p><figure class="highlight shell"><figcaption><span>代码块16</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">current conn host: 172.22.119.8</span><br><span class="line">current conn host: 172.22.119.8</span><br><span class="line">current conn host: 172.22.119.8</span><br><span class="line">current conn host: 172.22.119.8</span><br><span class="line">current conn host: 172.22.119.8</span><br><span class="line">current conn host: 172.22.119.8</span><br><span class="line">current conn host: 172.22.119.8</span><br><span class="line">...省略，共100条...</span><br></pre></td></tr></table></figure><p>符合我们的预期，因为它的作用不是干这个的。</p><h2 id="七、结论"><a href="#七、结论" class="headerlink" title="七、结论"></a>七、结论</h2><p>JDBC驱动程序的LoadBalance模式，是针对<code>每一个</code>被新建出来的Connection对象的LB，它<code>并非</code>很多人第一眼看到它协议头时所理解的那种将jdbc连接里配置的所有节点视作一个整体，每次利用Connection对象做一些操作时都会pick出来一个节点使用，以达到某种意义上的负载均衡，<code>而是</code>每次新建Connection对象时，从那堆host里pick出来其中一个，创建对应的Connection对象，这跟我们第一眼看到它的感觉不太一样，但是实现上确实没什么太大的问题，因为单纯使用JDBC时本就不提倡Connection单例复用，若想要复用，需要结合各类连接池一起使用，通过对JDBC的LB模式的了解可以知道，结合某种连接池技术来支撑，就可以达到我们想象中的LB效果，因为池内每一个Connection对象在创建时，总会触发JDBC的LB策略。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;基于依赖程序的版本信息：&lt;img src=&quot;https://img.shields.io/badge/mysql--connector--java-v8.0.17-green&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、认识loadbalance模式&quot;&gt;&lt;a href=&quot;#一、认识loadbalance模式&quot; class=&quot;headerlink&quot; title=&quot;一、认识loadbalance模式&quot;&gt;&lt;/a&gt;一、认识loadbalance模式&lt;/h2&gt;&lt;p&gt;首先回忆下jdbc协议头都有哪些，下面总结下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://myblog.sharemer.com/2020/06/02/20200602-1-1.png&quot; alt=&quot;表1&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
    <category term="JDBC" scheme="http://example.com/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>JVM基础回顾记录（四）：类文件</title>
    <link href="http://example.com/2020/05/06/JVM%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE%E8%AE%B0%E5%BD%95%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%B1%BB%E6%96%87%E4%BB%B6/"/>
    <id>http://example.com/2020/05/06/JVM%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE%E8%AE%B0%E5%BD%95%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%B1%BB%E6%96%87%E4%BB%B6/</id>
    <published>2020-05-06T14:56:00.000Z</published>
    <updated>2023-12-04T10:54:23.151Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、JAVA的平台无关性"><a href="#一、JAVA的平台无关性" class="headerlink" title="一、JAVA的平台无关性"></a>一、JAVA的平台无关性</h2><p>我们最开始学习java的时候了解到java代码文件必须经过<code>javac</code>的编译，生成字节码文件才可以被JVM识别并运行，而JVM则拥有多种操作系统的版本：</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-1-fixed.png?imageView2/0/w/700" alt="图1"></p><p>正是因为这些不同操作系统下的JVM版本，使得我们被编译后的字节码文件可以被不同操作系统上的JVM识别并运行，继而实现跨平台。</p><span id="more"></span><h2 id="二、字节码文件组成"><a href="#二、字节码文件组成" class="headerlink" title="二、字节码文件组成"></a>二、字节码文件组成</h2><p>字节码文件是经过编译器编译后的class文件，所以也可以称为<code>Class类文件</code>，这个文件内的内容你是看不懂的，它是以某种顺序堆叠的<code>二进制流</code>组成的文件，以<code>字节（byte）</code>为基本单位，我们学习java基础时知道，单字节占有8个bit位，虽然你很难看懂，但对于JVM来说却可以很容易的解析这类文件，这里先不谈它如何解析，我们本次只说明这个文件里都放了些什么东西，接下来会结合实例来详细说明。</p><p>上面刚说过，文件内部的基本单位是字节（8bit），利用这些字节数据所处的先后顺序，来决定Class文件里不同的数据项，JVM在做字节码加载分析的时候也是按照这个顺序来进行的，这就像是一种序列化的方式，而JVM加载解析它的时候，相当于在做反序列化，这个在本节不做探讨，留到类加载章节会详细说明。</p><p>字节码文件里存储的数据类型分为两大类，一种是基本的<code>无符号数字</code>类型，另外一种则是类似C语言中<code>结构体</code>的一种东西，我们管它叫<code>表</code>，表可能包含无符号数字，也可能包含另外一个表，也可能由无符号数字和其他表共同组成（其实也很像java里的类对吧？可能只包含基本类型的属性，也可能包含另外一个类的对象属性，虽然它跟类完全不是一回事，但为了便于理解，可以这样想）</p><p>由于字节码文件的“反序列化”过程非常的单纯，就是从前往后读，那么Class文件中的无符号数和表的堆叠顺序就显得非常重要，这其实是一种java虚拟机约定好的协议，比如Class文件读进来的二进制流，前4个字节一定是某个具体的字段，紧接着往后2个字节一定是另外一个字段，就这样，这个二进制字节流被协议切分成了具体的组，每一个组都代表着不同含义的字段。</p><h2 id="三、前三个字节组：魔数、次版本号、主版本号"><a href="#三、前三个字节组：魔数、次版本号、主版本号" class="headerlink" title="三、前三个字节组：魔数、次版本号、主版本号"></a>三、前三个字节组：魔数、次版本号、主版本号</h2><p>通过<code>第二节</code>的了解，我们知道了Class文件就是字节与字节的顺序堆叠排列，然后按照字节码约定协议进行以字节为单位分组，每一组的数据代表着不同的含义，接下来让我们看下字节码文件的头部三个组都分别代表什么吧：</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-2.png?imageView2/0/w/1024" alt="图2"></p><p>上图展示的就是Class文件开头几个字节被约定分组的情况，其实后面更复杂的表也是按照类似的方式做的。</p><p>无符号数按照不同数量的字节分组，形成了不同的<code>数据类型</code>，需要占用4个字节才能存下的字段的类型被称为<code>u4</code>，而只需要占用2个字节的字段类型被称为<code>u2</code>，<code>图2</code>中“魔数”就可以被说成是一个u4类型的数字，而次版本号和主版本号则为<code>u2</code>。</p><p><strong>魔数（magic）：</strong>确定当前文件是否是一个可以被jvm加载的Class文件（像mp3、pdf等文件，开头一样也会有类似的魔数）</p><p><strong>主版本号（major_version）&amp;次版本号（minor_version）：</strong>用来记录当前Class文件的版本号，每个版本的jdk编译过的Class文件，会保有其版本号信息，学习java基础的时候都了解过，java是<code>自上向下兼容</code>的，比如jdk1.8编译出来的Class文件不可以被1.7版本的虚拟机加载运行，但jdk1.7编译出来的Class文件却可以被1.8版本的虚拟机加载运行，至于能不能被加载的第一道坎，就是按照这俩版本号进行判断的。</p><h2 id="四、常量池"><a href="#四、常量池" class="headerlink" title="四、常量池"></a>四、常量池</h2><p><code>图2</code>里我们至少已经知道了<code>魔数</code>、<code>次版本号</code>、<code>主版本号</code>这三个字段，往后的则被省略了。往后是什么呢？它是非常复杂且庞大的一个分组集合，被称为常量池（注意，这个常量池是指Class文件内的常量池，他们会被Class文件内一些索引项给索引到，准确的说并不是运行期的那个JVM方法区内的<code>运行时常量池</code>，但随着JVM的类加载，类里的这个常量池会被加载进运行时常量池，顺便说下，到了那个时候，很多<code>符号引用</code>也会转变为<code>直接引用</code>）它们位于主版本号后面，第一项是一个u2类型的数字，表示有几个常量表如图：</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-3-fixed.png?imageView2/0/w/1024" alt="图3"></p><h3 id="4-1：池里常量的分类"><a href="#4-1：池里常量的分类" class="headerlink" title="4.1：池里常量的分类"></a>4.1：池里常量的分类</h3><p>常量池里的常量按照类型被分为了两大类：字面量和符号引用，而符号引用又往下细分了几个分类，如图：</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-3-1.png?imageView2/0/w/600" alt="图4"></p><h4 id="4-1-1：字面量"><a href="#4-1-1：字面量" class="headerlink" title="4.1.1：字面量"></a>4.1.1：字面量</h4><p>很简单的概念，类似于常量，下面的分节将会详细介绍，主要是类似语言层面的基本类型，比如<code>int</code>、<code>float</code>、<code>double</code>这些，都有对应的字面量常量表：<code>CONSTANT_Integer_info</code>、<code>CONSTANT_Float_info</code>、<code>CONSTANT_Double_info</code></p><h4 id="4-1-2：符号引用"><a href="#4-1-2：符号引用" class="headerlink" title="4.1.2：符号引用"></a>4.1.2：符号引用</h4><p>符号引用都是以字符串的方式存储在常量池里的，它们通常用来描述类的全限定名、方法和字段的名称以及描述符，因此被分了三类.</p><h5 id="类和接口的全限定名"><a href="#类和接口的全限定名" class="headerlink" title="类和接口的全限定名"></a>类和接口的全限定名</h5><p>第一类叫全限定名，例如，一个类叫：<code>com.bilibili.test.Test</code>，则它的全限定名为：<code>com/bilibili/test/Test</code></p><h5 id="字段、方法的简单名称和描述符"><a href="#字段、方法的简单名称和描述符" class="headerlink" title="字段、方法的简单名称和描述符"></a>字段、方法的简单名称和描述符</h5><p>相对来说，字段和方法的描述符更为复杂，我们得通过实际的例子来说明问题。</p><p>我们知道，一个类里面有字段以及方法，字段有它自己声明的类型以及名称，而方法则更加复杂，它存在入参、返回、名称，因此要想用描述符这样的字符串来描述一个字段或者一个方法，往往需要一定的格式，让我们来看看其格式吧。</p><p>先说字段，假如我的类里有个字段是int型，名称为num，名称没什么好说的就是num，但它的类型描述符却是：<code>I</code></p><p>为什么int型的数据的类型描述符是<code>I</code>？那double呢？下面我们就列出所有类型对应的描述符的映射关系表，后面更复杂的方法描述符也可以用到这个表：</p><table><thead><tr><th align="left">类型</th><th align="left">描述符</th></tr></thead><tbody><tr><td align="left">byte</td><td align="left">B</td></tr><tr><td align="left">char</td><td align="left">C</td></tr><tr><td align="left">double</td><td align="left">D</td></tr><tr><td align="left">float</td><td align="left">F</td></tr><tr><td align="left">int</td><td align="left">I</td></tr><tr><td align="left">long</td><td align="left">J</td></tr><tr><td align="left">short</td><td align="left">S</td></tr><tr><td align="left">boolean</td><td align="left">Z</td></tr><tr><td align="left">reference（引用类型）</td><td align="left">L，格式为<code>L类型全限定名;</code>，例如Object类型的引用变量可表示为：<code>Ljava/lang/Object;</code></td></tr><tr><td align="left">array（数组）</td><td align="left">[，格式为：<code>[类型描述符</code>，比如<code>int[]</code>可以表示为<code>[I</code>，再比如<code>Object[]</code>可以表示为<code>[Ljava/lang/Object;</code>，高维数组，只需要多加一个<code>[</code>即可，比如<code>int[][]</code>可以表示为<code>[[I</code></td></tr><tr><td align="left">void（方法描述符独有，用于形容方法的无参数返回类型）</td><td align="left">V</td></tr></tbody></table><center>表1</center><p>ok，了解完各种类型的描述符规则，再来一遍开始那个字段描述符为<code>I</code>就可以很容易理解了，下面来继续了解下方法的描述符，这个就更为复杂，其格式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(参数1类型描述符 参数2类型描述符...)返回值类型描述符</span><br></pre></td></tr></table></figure><p>下面通过几个例子来说明方法描述符，希望可以帮助你理解：</p><table><thead><tr><th align="left">方法定义</th><th align="left">描述符</th></tr></thead><tbody><tr><td align="left">int getId()</td><td align="left">()I</td></tr><tr><td align="left">double getPrice(Object[] o, double price)</td><td align="left">([Ljava&#x2F;lang&#x2F;Object;D)D</td></tr><tr><td align="left">void setId()</td><td align="left">()V</td></tr><tr><td align="left">void setId(int id)</td><td align="left">(I)V</td></tr></tbody></table><center>表2</center><p>那么字段或方法的名称及描述符存在哪个地方呢？接下来要介绍的一个叫做<code>CONSTANT_NameAndType_info</code>的常量表就是专门存放这俩数据的，它的内部结构请参考&#96;&#96;里对它的介绍。</p><p>常量池里的每一项都是个表，下面，我们来深层次探讨下常量池里的每一个表的结构~</p><h3 id="4-2：CONSTANT-Utf8-info（UTF-8编码的字符串）"><a href="#4-2：CONSTANT-Utf8-info（UTF-8编码的字符串）" class="headerlink" title="4.2：CONSTANT_Utf8_info（UTF-8编码的字符串）"></a>4.2：CONSTANT_Utf8_info（UTF-8编码的字符串）</h3><p>这个表的详细结构如下：</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-4.png?imageView2/0/w/600" alt="图5"></p><p>即便是表，也是按照类似的方式堆叠的，后续几种类型也是类似。</p><p>基本上常量池里的表第一个字节都是<code>tag</code>，tag在<code>图4</code>中已经解释过了，它用来区分当前表属于什么类型的表，比如本节里tag&#x3D;1，规范里tag为1的表就是<code>CONSTANT_Utf8_info</code>，当虚拟机知道了表为CONSTANT_Utf8_info，那么很自然的后面两个字节肯定是<code>length</code>，至于其内容，肯定就是length后面的字节了，然后截取length长度的字节，就是这个CONSTANT_Utf8_info所存放的实际内容。</p><h3 id="4-3：CONSTANT-Integer-info（整型字面量）"><a href="#4-3：CONSTANT-Integer-info（整型字面量）" class="headerlink" title="4.3：CONSTANT_Integer_info（整型字面量）"></a>4.3：CONSTANT_Integer_info（整型字面量）</h3><p>直接上图：</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-5.png?imageView2/0/w/500" alt="图6"></p><p>我们都知道int型数据占4字节，32位，现在通过上图字节码的分配可以证实，下面的字面量也大体相同。</p><h3 id="4-4：CONSTANT-Float-info（浮点型字面量）"><a href="#4-4：CONSTANT-Float-info（浮点型字面量）" class="headerlink" title="4.4：CONSTANT_Float_info（浮点型字面量）"></a>4.4：CONSTANT_Float_info（浮点型字面量）</h3><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-6.png?imageView2/0/w/500" alt="图7"></p><h3 id="4-5：CONSTANT-Long-info（长整型字面量）"><a href="#4-5：CONSTANT-Long-info（长整型字面量）" class="headerlink" title="4.5：CONSTANT_Long_info（长整型字面量）"></a>4.5：CONSTANT_Long_info（长整型字面量）</h3><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-7.png?imageView2/0/w/800" alt="图8"></p><h3 id="4-6：CONSTANT-Double-info（双精浮点型字面量）"><a href="#4-6：CONSTANT-Double-info（双精浮点型字面量）" class="headerlink" title="4.6：CONSTANT_Double_info（双精浮点型字面量）"></a>4.6：CONSTANT_Double_info（双精浮点型字面量）</h3><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-8.png?imageView2/0/w/800" alt="图9"></p><blockquote><p>到这里，基本类型就介绍完了，通过对<code>2.3.2 ~ 2.3.5</code>的了解，可以发现，基本类型是很简单的类型，而且其实际内容符合java里基本类型所占位数。</p></blockquote><h3 id="4-7：CONSTANT-Class-info（类、接口的符号引用）"><a href="#4-7：CONSTANT-Class-info（类、接口的符号引用）" class="headerlink" title="4.7：CONSTANT_Class_info（类、接口的符号引用）"></a>4.7：CONSTANT_Class_info（类、接口的符号引用）</h3><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-9.png?imageView2/0/w/400" alt="图10"></p><p>这里要详细介绍下index这个属性，因为在后面的表中，这个字段出现的频率会非常高。</p><p>这个字段代表了一个内容的索引，它索的谁的引呢？答案还是常量池，举个例子吧，Class_info是一个用来描述类或者接口<code>全限定名</code>的表，既然是全限定名，那肯定是个字符串，那么index指向的肯定是常量池里一张<code>CONSTANT_Utf8_info</code>的表，现在让我们假设一个常量池，里面已经排列好了各种表数据，按照常量池索引值从1开始，因此按照规则，绘制出下图：</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-10.png?imageView2/0/w/1024" alt="图11"></p><p>当Class_info的index属性就是用来指向常量池中某一个表的，例如上图里index&#x3D;2，则意味着常量池里索引下标为2的表的内容，就是Class_info的内容，开头说过，就是类或接口的全限定名。</p><h3 id="4-8：CONSTANT-String-info（字符串类型字面量）"><a href="#4-8：CONSTANT-String-info（字符串类型字面量）" class="headerlink" title="4.8：CONSTANT_String_info（字符串类型字面量）"></a>4.8：CONSTANT_String_info（字符串类型字面量）</h3><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-11.png?imageView2/0/w/320" alt="图12"></p><h3 id="4-9：CONSTANT-NameAndType-info（字段、方法的部分符号引用）"><a href="#4-9：CONSTANT-NameAndType-info（字段、方法的部分符号引用）" class="headerlink" title="4.9：CONSTANT_NameAndType_info（字段、方法的部分符号引用）"></a>4.9：CONSTANT_NameAndType_info（字段、方法的部分符号引用）</h3><p>之前介绍了常量池里存放的字段、方法都是存在名称以及描述符的，本节介绍的这个结构就是用来存放这两项内容的（对字段或方法的名称及描述符不熟悉的话，建议加强理解下<code>图4</code>、<code>表1</code>、<code>表2</code>里的内容）</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-15.png?imageView2/0/w/550" alt="图13"></p><p>该结构存储了某个字段或方法的<code>名称索引</code>和<code>描述符索引</code>，那肯定有具体的某个字段或方法的表里会索引向它，接下来要介绍的<code>CONSTANT_Fieldref_info</code>和<code>CONSTANT_Methodref_info</code>，均有指向它的索引字段。</p><h3 id="4-10：CONSTANT-Fieldref-info（类中引用字段的符号引用）"><a href="#4-10：CONSTANT-Fieldref-info（类中引用字段的符号引用）" class="headerlink" title="4.10：CONSTANT_Fieldref_info（类中引用字段的符号引用）"></a>4.10：CONSTANT_Fieldref_info（类中引用字段的符号引用）</h3><p>这个常量专门用来描述<code>类内被引用到的属性</code>，包含你<code>自定义</code>的出现在该类的属性，也包含该类里方法调用时使用的<code>别的类的属性</code>。</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-12-fixed.png?imageView2/0/w/500" alt="图14"></p><p>字段的符号引用表，除了要描述声明自己的类或接口，还需要索引到具体的<code>CONSTANT_NameAndType_info</code>，这个表里上面介绍过，内含一个<code>名称</code>和具体的<code>描述符</code>，下方的方法符号引用也是同样的结构，即一个字段或方法的符号引用等于：<code>声明该字段或方法的类或接口的全限定名</code> + <code>该字段或方法的名称</code> + <code>该字段或方法的描述符</code></p><h3 id="4-11：CONSTANT-Methodref-info（类中引用方法的符号引用）"><a href="#4-11：CONSTANT-Methodref-info（类中引用方法的符号引用）" class="headerlink" title="4.11：CONSTANT_Methodref_info（类中引用方法的符号引用）"></a>4.11：CONSTANT_Methodref_info（类中引用方法的符号引用）</h3><p>这个常量专门用来描述<code>类内被引用到的方法</code>，比如你在<code>A类</code>里定义了一个叫<code>test()</code>的方法，这个test方法<code>并不会</code>在常量池存在一个<code>CONSTANT_Methodref_info</code>，如果你再定义一个方法<code>test2()</code>，让它调用test方法，这时test方法相当于被引用，这时就拥有了对应的Methodref_info.</p><p>再比如，你方法里经常会调用一些依赖包的类方法，比如最常用的<code>System.out.println</code>，这个过程相当于你使用了<code>out对象</code>的<code>println方法</code>，此时当前类的字节码常量池便会有一个<code>println</code>的Methodref_info出现，同时也会有一个叫<code>out</code>的Fieldref_info出现。（这些均会在<code>实战篇</code>讲解）</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-13-fixed.png?imageView2/0/w/500" alt="图15"></p><blockquote><p>纠错，图里第一个info块里的内容应该是“Methodref_info的tag值为10”</p></blockquote><h3 id="4-12：CONSTANT-InterfaceMethodref-info（接口中方法的符号引用）"><a href="#4-12：CONSTANT-InterfaceMethodref-info（接口中方法的符号引用）" class="headerlink" title="4.12：CONSTANT_InterfaceMethodref_info（接口中方法的符号引用）"></a>4.12：CONSTANT_InterfaceMethodref_info（接口中方法的符号引用）</h3><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-14.png?imageView2/0/w/500" alt="图16"></p><p>截止到目前，常见的11种常量已经介绍完了，下面再介绍3种<code>JDK1.7</code>引入的新常量。</p><h3 id="4-13：CONSTANT-MethodHandle-info（表示方法句柄）"><a href="#4-13：CONSTANT-MethodHandle-info（表示方法句柄）" class="headerlink" title="4.13：CONSTANT_MethodHandle_info（表示方法句柄）"></a>4.13：CONSTANT_MethodHandle_info（表示方法句柄）</h3><p>这个常量是<code>1.7</code>新增的特性，即方法句柄，可以和下方<code>MethodType</code>结合使用，用法这里暂时不说，你可以简单理解，它是类似<code>反射</code>的功能，可以指定调用哪个对象的哪个方法。但不同于反射，它可以在编译期就指定好方法调用，而不是运行期，这相比反射要安全的多。</p><h3 id="4-14：CONSTANT-MethodType-info（标识方法类型）"><a href="#4-14：CONSTANT-MethodType-info（标识方法类型）" class="headerlink" title="4.14：CONSTANT_MethodType_info（标识方法类型）"></a>4.14：CONSTANT_MethodType_info（标识方法类型）</h3><p>待补全…</p><h3 id="4-15：CONSTANT-InvokeDynamic-info（动态方法调用点）"><a href="#4-15：CONSTANT-InvokeDynamic-info（动态方法调用点）" class="headerlink" title="4.15：CONSTANT_InvokeDynamic_info（动态方法调用点）"></a>4.15：CONSTANT_InvokeDynamic_info（动态方法调用点）</h3><p>待补全…</p><h2 id="五、访问标志"><a href="#五、访问标志" class="headerlink" title="五、访问标志"></a>五、访问标志</h2><p>紧挨着常量池后面的两个字节，代表<code>访问标志</code>（<code>access_flags</code>），因为其具备2个字节，所以它有16个bit位可以利用，每个位置的0或1代表不同的含义，当前只定义了8个，如下：</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-16.png?imageView2/0/w/1100" alt="图17"></p><h2 id="六、继承关系"><a href="#六、继承关系" class="headerlink" title="六、继承关系"></a>六、继承关系</h2><p>接着access_flag后面，有描述本类继承关系的几个变量，分别如下：</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-17.png?imageView2/0/w/1024" alt="图18"></p><p>学过java的人都知道，java类允许<code>单继承</code>和<code>多实现</code>，因此图中<code>super_class</code>只有一个，<code>interface</code>却对应了一个集合，当然，它们都只是u2类型的索引而已，指向常量池里的<code>CONSTANT_Class_info</code>（参考<code>4.7</code>）</p><h2 id="七、字段表集合"><a href="#七、字段表集合" class="headerlink" title="七、字段表集合"></a>七、字段表集合</h2><p>我们离开了继承关系后，紧挨着的就是字段表集合。字段表，即类（或接口）里声明的变量，变量分为<code>静态变量</code>（类变量）以及<code>成员变量</code>（实例变量）。</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-18-fix2.png?imageView2/0/w/1024" alt="图19"></p><p>现在详细介绍下图中<code>虚线</code>部分，这四个u2类型的字段以及<code>属性表</code>（<code>attribute_info</code>）集合代表了一个<code>field_info</code>表，它的这些字段解释如下：</p><h3 id="7-1：access-flags"><a href="#7-1：access-flags" class="headerlink" title="7.1：access_flags"></a>7.1：access_flags</h3><p>这个字段也叫<code>access_flags</code>，跟之前Class本身的access_flags所具备的意义一样，它是用来描述<code>字段</code>的<code>访问标志</code>，让我们来看看它每一位代表什么意思吧：</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-19-fix.png?imageView2/0/w/1100" alt="图20"></p><h3 id="7-2：name-index-descriptor-index"><a href="#7-2：name-index-descriptor-index" class="headerlink" title="7.2：name_index &amp; descriptor_index"></a>7.2：name_index &amp; descriptor_index</h3><p><code>name_index</code>和<code>descriptor_index</code>都是索引值，前者指向<code>常量池</code>里一个<code>CONSTANT_Utf8_info</code>，用来表示该字段的<code>简单名称</code>，后者也是指向<code>常量池</code>里一个<code>CONSTANT_Utf8_info</code>，但它用来表示字段的<code>描述符</code>（什么是简单名称，什么是描述符？请参考<code>4.1.2</code>）</p><h3 id="7-3：attributes-count-attribute-infos"><a href="#7-3：attributes-count-attribute-infos" class="headerlink" title="7.3：attributes_count &amp; attribute_infos"></a>7.3：attributes_count &amp; attribute_infos</h3><p>这段信息很复杂，代表属性表，<code>attributes_count</code>代表后面跟几个属性表，<code>attribute_infos</code>代表<code>属性表集合</code>，属性表是很复杂的一块内容，Class文件、字段表、方法表，甚至Code属性表都可以携带自己的属性表集合，属性表的种类很繁多，在<code>9.1节</code>会列举一个与本节（方法表）相关的属性表<code>ConstantValue</code>的结构。</p><h2 id="八、方法表集合"><a href="#八、方法表集合" class="headerlink" title="八、方法表集合"></a>八、方法表集合</h2><p>离开字段表后，紧挨着的就是方法表集合，它几乎跟字段表结构一致。方法表，即类（或接口）里声明的方法，同样的，方法分为<code>静态方法</code>（类方法）以及<code>成员方法</code>（实例方法）。</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-20-fix2.png?imageView2/0/w/1024" alt="图21"></p><p>同样的，来介绍下图中虚线部分，这四个u2类型的字段以及<code>属性表</code>（<code>attribute_info</code>）集合代表了一个<code>method_info</code>表，它的这些字段解释如下：</p><h3 id="8-1：access-flags"><a href="#8-1：access-flags" class="headerlink" title="8.1：access_flags"></a>8.1：access_flags</h3><p>不多说了，前面遇到很多次了，它用来描述<code>方法</code>的<code>访问标志</code>，让我们来看看它每一位代表什么意思吧：</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-21.png?imageView2/0/w/1100" alt="图22"></p><h3 id="8-2：name-index-descriptor-index"><a href="#8-2：name-index-descriptor-index" class="headerlink" title="8.2：name_index &amp; descriptor_index"></a>8.2：name_index &amp; descriptor_index</h3><p>跟字段表对应的字段作用相同，<code>name_index</code>和<code>descriptor_index</code>都是索引值，前者指向<code>常量池</code>里一个<code>CONSTANT_Utf8_info</code>，用来表示该方法的<code>简单名称</code>，后者也是指向<code>常量池</code>里一个<code>CONSTANT_Utf8_info</code>，但它用来表示方法的<code>描述符</code>（什么是简单名称，什么是描述符？请参考<code>4.1.2</code>）</p><h3 id="8-3：attributes-count-attribute-infos"><a href="#8-3：attributes-count-attribute-infos" class="headerlink" title="8.3：attributes_count &amp; attribute_infos"></a>8.3：attributes_count &amp; attribute_infos</h3><p>属性表，在<code>7.3节</code>提到过，这里的俩属性跟字段表里的意思一样，但在本节你可能会好奇，方法表定义了方法的名称和描述符，那么方法的代码跑哪里去了？其实方法本身的代码会被编译成字节码指令，存放在每个方法后面的某个属性表里，而这个属性表就是<code>Code</code>，在后续的<code>9.2</code>里会详细介绍，这里只需要记住它是出现在本节（方法表）这个位置的即可。</p><h2 id="九、属性表"><a href="#九、属性表" class="headerlink" title="九、属性表"></a>九、属性表</h2><p>前面两节或多或少提到过属性表，这是很复杂也很重要的一个表结构，下面来看下它的基本组成：</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-22.png?imageView2/0/w/1024" alt="图23"></p><p>不管属性表多么复杂，它开始的两个属性总是<code>attribute_name_index</code>和<code>attribute_length</code>，具体含义如图所示。</p><p>本节只少量介绍几个很重要的属性表，更详细的属性表可以查阅<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.7">https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.7</a></p><h3 id="9-1：ConstantValue"><a href="#9-1：ConstantValue" class="headerlink" title="9.1：ConstantValue"></a>9.1：ConstantValue</h3><p>先回看下<code>7.3</code>，该属性表仅作用在<code>字段表</code>上，用来表示一个<code>static final</code>字段的初始值，且要求该字段必须是<code>基本类型</code>或<code>String类型</code>才可以用该表表示初始值，为什么？我们来看下该表的结构：</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-23.png?imageView2/0/w/800" alt="图24"></p><p>因为<code>constantvalue_index</code>指向的一定常量池里某字面量，因此它只能是<code>CONSTANT_Long_info</code>、<code>CONSTANT_Float_info</code>、<code>CONSTANT_Double_info</code>、<code>CONSTANT_Integer_info</code>、<code>CONSTANT_String_info</code>里的一种，所以只有被声明为static final的基本类型和String类型的字段，才可能存在此属性表，用来代表其初始化值。</p><h3 id="9-2：Code"><a href="#9-2：Code" class="headerlink" title="9.2：Code"></a>9.2：Code</h3><p>这绝对是最高能的一个属性表，我们详细来解析下，从它的名字就可以看出来，它代表的是一个方法的<code>代码</code>属性，属于<code>方法表</code>（这点请牢记），这在<code>8.3</code>里提到过，我们写的程序代码最终会被<code>javac</code>编译成<code>字节码指令</code>，而这些指令就存储在Code属性表内，它的结构是怎样的呢？看图：</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-24.png?imageView2/0/w/1024" alt="图25"></p><p>这里面有很多细节，我们来逐一介绍下，就从<code>max_stack</code>开始吧~</p><h4 id="9-2-1：max-stack"><a href="#9-2-1：max-stack" class="headerlink" title="9.2.1：max_stack"></a>9.2.1：max_stack</h4><p>这个值跟<code>操作数栈</code>有关系，代表它的<code>最大深度</code>，当jvm处于运行期的时候，会根据这个值来分配<code>栈帧</code>中<code>操作数栈</code>的深度。（<code>栈帧</code>是后续文章将会介绍的概念，运行期时每一个Code模块，都会与之对应一个栈帧结构，可通过<code>10.2.5.1</code>节了解其基本概念）</p><h4 id="9-2-2：max-locals"><a href="#9-2-2：max-locals" class="headerlink" title="9.2.2：max_locals"></a>9.2.2：max_locals</h4><p>这个值也是围绕着运行期<code>栈帧</code>来生效的，它代表栈帧里<code>局部变量表</code>所需的存储空间。什么是局部变量表？早期接触java时就知道，每个方法内产生的对象、变量我们都称之为<code>局部变量</code>，它们会在运行期被暂存入方法所属栈帧里的局部变量表中，方便操作数栈存取与操作，而它需要多少存储大小呢？就是靠这个值来决定的，结合<code>9.2.1</code>可以知道，一个java方法的<code>局部变量表大小</code>、<code>操作数栈最大深度</code>都是在<code>编译期</code>就已经确定了的。</p><p>那么，存储大小的单位又是什么呢？是字节（byte）吗？比如max_locals为5，代表的是5byte的存储空间吗？</p><p>并不是，它是一个叫做<code>Slot</code>的东西，max_locals&#x3D;5，代表需要分配5个Slot。下面来介绍下Slot。</p><p>Slot有<code>32个bit位</code>，意思就是说每个Slot占<code>4字节</code>，因此，如果你有一个局部变量是int型，那么它就占1个Slot空间，如果是float或者long之类的，那就需要两个Slot。</p><p>那现在我们就可以很容易推算出一个方法的局部变量表的容量到底需要多大了：<em>总Slot量 &#x3D; 所有局部变量所用的字节量 &#x2F; 4</em></p><p>但是，这样是不对的！因为根据每个局部变量的作用域不同，Slot是可以被<code>复用</code>的，这点很重要，让我们来看个例子：</p><figure class="highlight java"><figcaption><span>代码块1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">slot</span><span class="params">(<span class="type">int</span> a)</span> &#123; <span class="comment">//入参a，为a分配一个Slot</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">//为b分配一个Slot</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b; <span class="comment">//为c分配一个Slot，但是注意，c的作用域只有if域</span></span><br><span class="line">        b = c;</span><br><span class="line">    &#125; <span class="comment">//离开if域，为c分配那个Slot会被完全闲置出来，因为c在之后的逻辑中再也无法使用了</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> b; <span class="comment">//反正c的那个Slot闲着也是浪费，不如给接下来的变量用，这里d就可以复用c的Slot</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码一共有a、b、c、d四个int型变量，理论上需要分配<code>4个</code>Slot存储，但实际只分配了<code>3个</code>，具体原因请参考代码中的注释，这种利用java语法来节省Slot的做法还是相当聪明的。</p><h4 id="9-2-3：字节码指令"><a href="#9-2-3：字节码指令" class="headerlink" title="9.2.3：字节码指令"></a>9.2.3：字节码指令</h4><p>参考<code>图25</code>，离开了<code>max_stack</code>和<code>max_locals</code>，紧接着就进入了一个非常冗长的区域，那就是<code>code</code>区域，它是你写的java程序被翻译成的一个个<code>指令码</code>，是最重要的一部分，也是直接可以被java程序员操控的部分。</p><p>字节码指令大全：<a href="https://luisstruggle.github.io/blog/javaSE7-JVM.html">https://luisstruggle.github.io/blog/javaSE7-JVM.html</a></p><p>后续会以某个实例的字节码指令集来分析这些指令是如何在<code>栈帧</code>里运行的（虽然是运行期的东西，但还是想在这一节做下简单的说明）</p><h2 id="十、实战"><a href="#十、实战" class="headerlink" title="十、实战"></a>十、实战</h2><h3 id="10-1：快速回顾"><a href="#10-1：快速回顾" class="headerlink" title="10.1：快速回顾"></a>10.1：快速回顾</h3><p>终于把字节码的详细内容讲完了，太多太长，上面是详细介绍，下面就通过一张图简单回顾一下字节码文件的堆叠顺序和内容种类：</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-25.png?imageView2/0/w/1024" alt="图26"></p><h3 id="10-2：字节码分析实战"><a href="#10-2：字节码分析实战" class="headerlink" title="10.2：字节码分析实战"></a>10.2：字节码分析实战</h3><h4 id="10-2-1：源代码"><a href="#10-2-1：源代码" class="headerlink" title="10.2.1：源代码"></a>10.2.1：源代码</h4><p>本篇会通过以下实例来具体解析字节码组成：</p><figure class="highlight java"><figcaption><span>代码块2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sun.juwin.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> j; <span class="comment">//声明一个类变量j，其在静态块里进行初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">5</span>; <span class="comment">//再声明一个类变量k，并直接初始化为5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> i; <span class="comment">//包含一个成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123; <span class="comment">//静态块，相当于类本身的构造器</span></span><br><span class="line">        j = <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span> &#123; <span class="comment">//包含两个重载构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Test init !&quot;</span>); <span class="comment">//注意，这里调用了out对象的println方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(); <span class="comment">//在这里主动触发一次无参构造器</span></span><br><span class="line">        <span class="built_in">this</span>.i = i; <span class="comment">//给i属性赋值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getK</span><span class="params">()</span> &#123; <span class="comment">//类方法，返回类属性k的值（静态方法的入参不会隐式传入this作为参数）</span></span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum_i</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="comment">//成员方法，这个方法传俩值，返回i和这俩值之和的和（成员方法的入参会隐式传入this作为参数）</span></span><br><span class="line">        <span class="keyword">return</span> i + sum(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; <span class="comment">//成员方法，计算两个数的和</span></span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; <span class="comment">//成员方法，作用跟上面的sum一样，但这个方法会多出一个Slot来存result这个局部变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> x + y;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-2-2：字节码信息"><a href="#10-2-2：字节码信息" class="headerlink" title="10.2.2：字节码信息"></a>10.2.2：字节码信息</h4><p>首先我们利用<code>javac</code>将其编译成字节码文件（我这里使用<code>jdk11</code>版本做的编译），然后利用<code>javap</code>指令，输出其字节码信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javac&amp;javap指令</span><br><span class="line"></span><br><span class="line">javac -g Test.java   //编译(-g会帮忙把调试信息也编译进去，为了说明Slot，我们需要这个)</span><br><span class="line">javap -v -p Test //输出字节码详细信息，-v表示输出详细信息，-p表示输出所有的字段和方法(不加这个的话public以下的字段方法无法展示)</span><br></pre></td></tr></table></figure><p>javap这个指令是干嘛的呢？它实际上是将编译好的字节码文件<code>反编译</code>，然后输出字节码文件里各数据项的详细信息，相比直接去读二进制的字节码文件，javap输出的字节码详细信息更加通俗易读。</p><p>现在来看下<code>代码块2</code>的字节码详细信息（太冗长了，后面会拆解说明）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">&quot;Test.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">sun</span>.juwin.test.Test</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">55</span></span><br><span class="line">  flags: (<span class="number">0x0021</span>) ACC_PUBLIC, ACC_SUPER</span><br><span class="line">  this_class: #<span class="number">7</span>                          <span class="comment">// sun/juwin/test/Test</span></span><br><span class="line">  super_class: #<span class="number">10</span>                        <span class="comment">// java/lang/Object</span></span><br><span class="line">  interfaces: <span class="number">0</span>, fields: <span class="number">3</span>, methods: <span class="number">7</span>, attributes: <span class="number">1</span></span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">10.</span>#<span class="number">39</span>        <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">40.</span>#<span class="number">41</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">3</span> = String             #<span class="number">42</span>            <span class="comment">// Test init !</span></span><br><span class="line">   #<span class="number">4</span> = Methodref          #<span class="number">43.</span>#<span class="number">44</span>        <span class="comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">   #<span class="number">5</span> = Methodref          #<span class="number">7.</span>#<span class="number">39</span>         <span class="comment">// sun/juwin/test/Test.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">6</span> = Fieldref           #<span class="number">7.</span>#<span class="number">45</span>         <span class="comment">// sun/juwin/test/Test.i:I</span></span><br><span class="line">   #<span class="number">7</span> = Class              #<span class="number">46</span>            <span class="comment">// sun/juwin/test/Test</span></span><br><span class="line">   #<span class="number">8</span> = Methodref          #<span class="number">7.</span>#<span class="number">47</span>         <span class="comment">// sun/juwin/test/Test.sum:(II)I</span></span><br><span class="line">   #<span class="number">9</span> = Fieldref           #<span class="number">7.</span>#<span class="number">48</span>         <span class="comment">// sun/juwin/test/Test.j:I</span></span><br><span class="line">  #<span class="number">10</span> = Class              #<span class="number">49</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">  #<span class="number">11</span> = Utf8               j</span><br><span class="line">  #<span class="number">12</span> = Utf8               I</span><br><span class="line">  #<span class="number">13</span> = Utf8               k</span><br><span class="line">  #<span class="number">14</span> = Utf8               ConstantValue</span><br><span class="line">  #<span class="number">15</span> = Integer            <span class="number">5</span></span><br><span class="line">  #<span class="number">16</span> = Utf8               i</span><br><span class="line">  #<span class="number">17</span> = Utf8               &lt;init&gt;</span><br><span class="line">  #<span class="number">18</span> = <span class="built_in">Utf8</span>               ()V</span><br><span class="line">  #<span class="number">19</span> = Utf8               Code</span><br><span class="line">  #<span class="number">20</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">21</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">22</span> = Utf8               <span class="keyword">this</span></span><br><span class="line">  #<span class="number">23</span> = Utf8               Lsun/juwin/test/Test;</span><br><span class="line">  #<span class="number">24</span> = <span class="built_in">Utf8</span>               (I)V</span><br><span class="line">  #<span class="number">25</span> = Utf8               getK</span><br><span class="line">  #<span class="number">26</span> = <span class="built_in">Utf8</span>               ()I</span><br><span class="line">  #<span class="number">27</span> = Utf8               sum_i</span><br><span class="line">  #<span class="number">28</span> = <span class="built_in">Utf8</span>               (II)I</span><br><span class="line">  #<span class="number">29</span> = Utf8               a</span><br><span class="line">  #<span class="number">30</span> = Utf8               b</span><br><span class="line">  #<span class="number">31</span> = Utf8               sum</span><br><span class="line">  #<span class="number">32</span> = Utf8               x</span><br><span class="line">  #<span class="number">33</span> = Utf8               y</span><br><span class="line">  #<span class="number">34</span> = Utf8               sum2</span><br><span class="line">  #<span class="number">35</span> = Utf8               result</span><br><span class="line">  #<span class="number">36</span> = Utf8               &lt;clinit&gt;</span><br><span class="line">  #<span class="number">37</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">38</span> = Utf8               Test.java</span><br><span class="line">  #<span class="number">39</span> = NameAndType        #<span class="number">17</span>:#<span class="number">18</span>        <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">40</span> = Class              #<span class="number">50</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">41</span> = NameAndType        #<span class="number">51</span>:#<span class="number">52</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">42</span> = Utf8               Test init !</span><br><span class="line">  #<span class="number">43</span> = Class              #<span class="number">53</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">44</span> = NameAndType        #<span class="number">54</span>:#<span class="number">55</span>        <span class="comment">// println:(Ljava/lang/String;)V</span></span><br><span class="line">  #<span class="number">45</span> = NameAndType        #<span class="number">16</span>:#<span class="number">12</span>        <span class="comment">// i:I</span></span><br><span class="line">  #<span class="number">46</span> = Utf8               sun/juwin/test/Test</span><br><span class="line">  #<span class="number">47</span> = NameAndType        #<span class="number">31</span>:#<span class="number">28</span>        <span class="comment">// sum:(II)I</span></span><br><span class="line">  #<span class="number">48</span> = NameAndType        #<span class="number">11</span>:#<span class="number">12</span>        <span class="comment">// j:I</span></span><br><span class="line">  #<span class="number">49</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">50</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">51</span> = Utf8               out</span><br><span class="line">  #<span class="number">52</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">53</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">54</span> = Utf8               println</span><br><span class="line">  #<span class="number">55</span> = <span class="built_in">Utf8</span>               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">static</span> <span class="keyword">final</span> <span class="type">int</span> j;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: (<span class="number">0x0019</span>) ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">static</span> <span class="keyword">final</span> <span class="type">int</span> k;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: (<span class="number">0x0019</span>) ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line">    ConstantValue: <span class="type">int</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: (<span class="number">0x0002</span>) ACC_PRIVATE</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> sun.juwin.test.<span class="built_in">Test</span>();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (<span class="number">0x0001</span>) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">7</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String Test init !</span></span><br><span class="line">         <span class="number">9</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">        <span class="number">12</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">15</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">16</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">17</span>: <span class="number">12</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">13</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lsun/juwin/test/Test;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> sun.juwin.test.<span class="built_in">Test</span>(<span class="type">int</span>);</span><br><span class="line">    descriptor: (I)V</span><br><span class="line">    flags: (<span class="number">0x0001</span>) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">5</span>                  <span class="comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: iload_1</span><br><span class="line">         <span class="number">6</span>: putfield      #<span class="number">6</span>                  <span class="comment">// Field i:I</span></span><br><span class="line">         <span class="number">9</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">20</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">21</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">22</span>: <span class="number">9</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">10</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lsun/juwin/test/Test;</span><br><span class="line">            <span class="number">0</span>      <span class="number">10</span>     <span class="number">1</span>     <span class="function">i   I</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="type">static</span> <span class="type">int</span> <span class="title">getK</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: (<span class="number">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="number">0</span>: iconst_5</span><br><span class="line">         <span class="number">1</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">25</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="built_in">sum_i</span>(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">    descriptor: (II)I</span><br><span class="line">    flags: (<span class="number">0x0001</span>) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">4</span>, locals=<span class="number">3</span>, args_size=<span class="number">3</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: getfield      #<span class="number">6</span>                  <span class="comment">// Field i:I</span></span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: iload_1</span><br><span class="line">         <span class="number">6</span>: iload_2</span><br><span class="line">         <span class="number">7</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method sum:(II)I</span></span><br><span class="line">        <span class="number">10</span>: iadd</span><br><span class="line">        <span class="number">11</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">29</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">12</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lsun/juwin/test/Test;</span><br><span class="line">            <span class="number">0</span>      <span class="number">12</span>     <span class="number">1</span>     a   I</span><br><span class="line">            <span class="number">0</span>      <span class="number">12</span>     <span class="number">2</span>     <span class="function">b   I</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">    descriptor: (II)I</span><br><span class="line">    flags: (<span class="number">0x0001</span>) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">3</span></span><br><span class="line">         <span class="number">0</span>: iload_1</span><br><span class="line">         <span class="number">1</span>: iload_2</span><br><span class="line">         <span class="number">2</span>: iadd</span><br><span class="line">         <span class="number">3</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">33</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">4</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lsun/juwin/test/Test;</span><br><span class="line">            <span class="number">0</span>       <span class="number">4</span>     <span class="number">1</span>     x   I</span><br><span class="line">            <span class="number">0</span>       <span class="number">4</span>     <span class="number">2</span>     <span class="function">y   I</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="type">int</span> <span class="title">sum2</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">    descriptor: (II)I</span><br><span class="line">    flags: (<span class="number">0x0001</span>) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">3</span></span><br><span class="line">         <span class="number">0</span>: iload_1</span><br><span class="line">         <span class="number">1</span>: iload_2</span><br><span class="line">         <span class="number">2</span>: iadd</span><br><span class="line">         <span class="number">3</span>: istore_3</span><br><span class="line">         <span class="number">4</span>: iload_3</span><br><span class="line">         <span class="number">5</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">37</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">38</span>: <span class="number">4</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">6</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lsun/juwin/test/Test;</span><br><span class="line">            <span class="number">0</span>       <span class="number">6</span>     <span class="number">1</span>     x   I</span><br><span class="line">            <span class="number">0</span>       <span class="number">6</span>     <span class="number">2</span>     y   I</span><br><span class="line">            <span class="number">4</span>       <span class="number">2</span>     <span class="number">3</span> result   I</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (<span class="number">0x0008</span>) ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">6</span></span><br><span class="line">         <span class="number">2</span>: putstatic     #<span class="number">9</span>                  <span class="comment">// Field j:I</span></span><br><span class="line">         <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;Test.java&quot;</span></span><br></pre></td></tr></table></figure><p>太长了，我们来将上面的字节码信息拆解一下进行详细分析。</p><h4 id="10-2-3：字节码-头部"><a href="#10-2-3：字节码-头部" class="headerlink" title="10.2.3：字节码-头部"></a>10.2.3：字节码-头部</h4><figure class="highlight c++"><figcaption><span>代码块4 头部</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">&quot;Test.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">sun</span>.juwin.test.Test</span><br><span class="line">  minor version: <span class="number">0</span>  <span class="comment">//这是次版本号</span></span><br><span class="line">  major version: <span class="number">55</span> <span class="comment">//这是主版本号</span></span><br><span class="line">  flags: (<span class="number">0x0021</span>) ACC_PUBLIC, ACC_SUPER <span class="comment">//这是访问标志，将0x0021转换成二进制，再跟图17一一对应，就可以得出ACC_PUBLIC和ACC_SUPER的结论</span></span><br><span class="line">  this_class: #<span class="number">7</span> <span class="comment">//#7是个常量池索引，其值为sun/juwin/test/Test，代表该类的全限定名</span></span><br><span class="line">  super_class: #<span class="number">10</span> <span class="comment">//#10也是个常量池索引，其值为java/lang/Object，代表该类的父类全限定名，默认为Object，如果真的继承了其他父类，则该值为对应父类的全限定名</span></span><br><span class="line">  interfaces: <span class="number">0</span>, fields: <span class="number">3</span>, methods: <span class="number">7</span>, attributes: <span class="number">1</span> <span class="comment">//该类实现了0个接口，共有3个字段（i、j、k），7个方法（静态块、Test()、Test(int i)、getK、sum_i、sum、sum2），1个attributes？？这个我自己没搞懂，如果指代属性表，那远不止1个，如果不是指属性表，那是什么意思呢？</span></span><br></pre></td></tr></table></figure><h4 id="10-2-3：字节码-常量池"><a href="#10-2-3：字节码-常量池" class="headerlink" title="10.2.3：字节码-常量池"></a>10.2.3：字节码-常量池</h4><figure class="highlight c++"><figcaption><span>代码块5 常量池</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">Constant pool: <span class="comment">//下面就是大杂烩的常量池了，#xx代表一个索引，所以看得时候需要找序号的按照这个值找就行了。</span></span><br><span class="line"><span class="comment">//这里说一下XXXref，在4.10和4.11介绍过，它们是指在该类内被引用到的字段或方法，因此像System.out就是一个FieldRef，而println就是一个MethodRef，同样的在sum_i方法里有对sum方法的调用，因此sum方法也是一个MethodRef</span></span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">10.</span>#<span class="number">39</span> <span class="comment">//由于该类构造器被调用时会触发其父类构造器的调用，因此父类构造器是一个MethodRef，其值为：java/lang/Object.&quot;&lt;init&gt;&quot;:()V（前面为该方法所属类的全限定名，后面为该方法的名称和描述符，#39可以往下找，是个NameAndType）</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">40.</span>#<span class="number">41</span> <span class="comment">//一个被该类引用的属性，这个找法类似上面的MethodRef，其值为：java/lang/System.out:Ljava/io/PrintStream;即：Test()方法里的System.out属性</span></span><br><span class="line">   #<span class="number">3</span> = String             #<span class="number">42</span> <span class="comment">//String字面量，指向内容为&quot;Test init !&quot;的Utf8_info</span></span><br><span class="line">   #<span class="number">4</span> = Methodref          #<span class="number">43.</span>#<span class="number">44</span> <span class="comment">//值为java/io/PrintStream.println:(Ljava/lang/String;)V，因为println被我们所引用，所以它也成为了该类的一个MethodRef</span></span><br><span class="line">   #<span class="number">5</span> = Methodref          #<span class="number">7.</span>#<span class="number">39</span> <span class="comment">//该类的一个无参构造器，值为sun/juwin/test/Test.&quot;&lt;init&gt;&quot;:()V，因为我们的有参构造器引用了它，所以它也是MethodRef，下面的各类Ref以此类推</span></span><br><span class="line">   #<span class="number">6</span> = Fieldref           #<span class="number">7.</span>#<span class="number">45</span> <span class="comment">//值为sun/juwin/test/Test.i:I</span></span><br><span class="line">   #<span class="number">7</span> = Class              #<span class="number">46</span> <span class="comment">//该类的全限定名，指向的值为sun/juwin/test/Test</span></span><br><span class="line">   #<span class="number">8</span> = Methodref          #<span class="number">7.</span>#<span class="number">47</span> <span class="comment">//值为sun/juwin/test/Test.sum:(II)I</span></span><br><span class="line">   #<span class="number">9</span> = Fieldref           #<span class="number">7.</span>#<span class="number">48</span> <span class="comment">//值为sun/juwin/test/Test.j:I</span></span><br><span class="line">  #<span class="number">10</span> = Class              #<span class="number">49</span> <span class="comment">//父类的全限定名，它已经被#1引用过一次了，值为java/lang/Object</span></span><br><span class="line">  #<span class="number">11</span> = Utf8               j <span class="comment">//字段j的简单名称文本值，应被某个字段表索引，参考7.2</span></span><br><span class="line">  #<span class="number">12</span> = Utf8               I <span class="comment">//字段的描述符文本值，同样应被某个字段表索引，参考7.2，只需要一个I即可，因为本类所定义的属性只有int一个类型</span></span><br><span class="line">  #<span class="number">13</span> = Utf8               k <span class="comment">//字段k的简单名称文本值</span></span><br><span class="line">  #<span class="number">14</span> = Utf8               ConstantValue <span class="comment">//属性表名称文本值，应被某个属性表索引，参考9.1</span></span><br><span class="line">  #<span class="number">15</span> = Integer            <span class="number">5</span> <span class="comment">//某Integer字面量的值，本例中被属性k的ConstantValue索引，参考9.1</span></span><br><span class="line">  #<span class="number">16</span> = Utf8               i <span class="comment">//字段i的简单名称文本值</span></span><br><span class="line">  #<span class="number">17</span> = Utf8               &lt;init&gt; <span class="comment">//该类构造方法的简单名称文本值，应被某个方法表索引，参考8.2</span></span><br><span class="line">  #<span class="number">18</span> = <span class="built_in">Utf8</span>               ()V <span class="comment">//某方法的描述符文本值，()V代表无参无返回值（描述符规则参考4.1.2），应被某个方法表索引，参考8.2</span></span><br><span class="line">  #<span class="number">19</span> = Utf8               Code <span class="comment">//属性表名称文本值，应被某个属性表索引，参考9.2</span></span><br><span class="line">  #<span class="number">20</span> = Utf8               LineNumberTable <span class="comment">//属性表名称文本值，应被某个属性表索引，LineNumberTable是Code属性表的一部分，参考9.2</span></span><br><span class="line">  #<span class="number">21</span> = Utf8               LocalVariableTable <span class="comment">//属性表名称文本值，应被某个属性表索引，LocalVariableTable是Code属性表的一部分，参考9.2</span></span><br><span class="line">  #<span class="number">22</span> = Utf8               <span class="keyword">this</span> <span class="comment">//字段this的简单名称（this属于隐式字段）</span></span><br><span class="line">  #<span class="number">23</span> = Utf8               Lsun/juwin/test/Test; <span class="comment">//字段描述符文本值，所有类型为sun/juwin/test/Test类型的字段，都可以使用该值作为自己的描述符</span></span><br><span class="line">  #<span class="number">24</span> = <span class="built_in">Utf8</span>               (I)V <span class="comment">//某个入参为一个int型无返回值的方法描述符文本值，本例子指Test(int i)方法</span></span><br><span class="line">  #<span class="number">25</span> = Utf8               getK <span class="comment">//getK方法的简单名称文本值</span></span><br><span class="line">  #<span class="number">26</span> = <span class="built_in">Utf8</span>               ()I <span class="comment">//某个无参返回int数据的方法的描述符文本值，本例可以指代getK()方法</span></span><br><span class="line">  #<span class="number">27</span> = Utf8               sum_i <span class="comment">//sum_i方法的简单名称文本值</span></span><br><span class="line">  #<span class="number">28</span> = <span class="built_in">Utf8</span>               (II)I <span class="comment">//某个入参为两个int型，返回一个int型值的方法的描述符文本值，在本例中，可以用来作sum_i、sum、sum2的描述符</span></span><br><span class="line">  #<span class="number">29</span> = Utf8               a <span class="comment">//这种位于局部变量表的变量名，都是在开启调试模式时（javac -g）编译的class文件才有，普通javac是没有的，下方b、x、y、result同理</span></span><br><span class="line">  #<span class="number">30</span> = Utf8               b</span><br><span class="line">  #<span class="number">31</span> = Utf8               sum <span class="comment">//sum方法的简单名称文本值</span></span><br><span class="line">  #<span class="number">32</span> = Utf8               x</span><br><span class="line">  #<span class="number">33</span> = Utf8               y</span><br><span class="line">  #<span class="number">34</span> = Utf8               sum2 <span class="comment">//sum2方法的简单名称文本值</span></span><br><span class="line">  #<span class="number">35</span> = Utf8               result</span><br><span class="line">  #<span class="number">36</span> = Utf8               &lt;clinit&gt; <span class="comment">//类初始化方法的简单名称，就是静态块，静态块被认为是类本身的&quot;构造器&quot;，如果没有静态块，那么也不会有这个方法</span></span><br><span class="line">  #<span class="number">37</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">38</span> = Utf8               Test.java <span class="comment">//本类源文件名称</span></span><br><span class="line">  #<span class="number">39</span> = NameAndType        #<span class="number">17</span>:#<span class="number">18</span> <span class="comment">//已经被#1和#5的MethodRef引用，其值为：&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">40</span> = Class              #<span class="number">50</span> <span class="comment">//类限定名：java/lang/System，被#2引用</span></span><br><span class="line">  #<span class="number">41</span> = NameAndType        #<span class="number">51</span>:#<span class="number">52</span> <span class="comment">//被#2引用，其值为：out:Ljava/io/PrintStream;即：System.out这个属性的名称和描述符</span></span><br><span class="line">  #<span class="number">42</span> = Utf8               Test init ! <span class="comment">//Test()方法里的字符串文本值，被#3引用</span></span><br><span class="line">  #<span class="number">43</span> = Class              #<span class="number">53</span> <span class="comment">//类限定名：java/io/PrintStream，被#4引用</span></span><br><span class="line">  #<span class="number">44</span> = NameAndType        #<span class="number">54</span>:#<span class="number">55</span> <span class="comment">//被#4引用，其值为：println:(Ljava/lang/String;)V，即：out.println这个方法的名称和描述符</span></span><br><span class="line">  #<span class="number">45</span> = NameAndType        #<span class="number">16</span>:#<span class="number">12</span> <span class="comment">//被#6引用，其值为：i:I，即该实例中i这个成员变量的名称和描述符</span></span><br><span class="line">  #<span class="number">46</span> = Utf8               sun/juwin/test/Test <span class="comment">//类全限定名的文本值，被#7引用</span></span><br><span class="line">  #<span class="number">47</span> = NameAndType        #<span class="number">31</span>:#<span class="number">28</span> <span class="comment">//被#8引用，其值为：sum:(II)I，即该实例中sum方法的简单名称和描述符</span></span><br><span class="line">  #<span class="number">48</span> = NameAndType        #<span class="number">11</span>:#<span class="number">12</span> <span class="comment">//被#9引用，其值为：j:I，即该实例中j这个类变量的名称和描述符</span></span><br><span class="line">  #<span class="number">49</span> = Utf8               java/lang/Object <span class="comment">//类全限定名的文本值，被#10引用</span></span><br><span class="line">  #<span class="number">50</span> = Utf8               java/lang/System <span class="comment">//类全限定名文本值，被#40引用</span></span><br><span class="line">  #<span class="number">51</span> = Utf8               out <span class="comment">//属性简单名称文本值，被#41引用</span></span><br><span class="line">  #<span class="number">52</span> = Utf8               Ljava/io/PrintStream; <span class="comment">//属性的描述符文本值，被#41引用</span></span><br><span class="line">  #<span class="number">53</span> = Utf8               java/io/PrintStream <span class="comment">//类全限定名的文本值，被#43引用</span></span><br><span class="line">  #<span class="number">54</span> = Utf8               println <span class="comment">//方法简单名称文本值，被#44引用</span></span><br><span class="line">  #<span class="number">55</span> = <span class="built_in">Utf8</span>               (Ljava/lang/String;)V <span class="comment">//方法描述符的文本值，被#44引用</span></span><br></pre></td></tr></table></figure><h4 id="10-2-4：字节码-字段表"><a href="#10-2-4：字节码-字段表" class="headerlink" title="10.2.4：字节码-字段表"></a>10.2.4：字节码-字段表</h4><p>看完了最为复杂的常量池，下面来看下字段表部分，这部分简单许多：</p><figure class="highlight c++"><figcaption><span>代码块6 字段表</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">static</span> <span class="keyword">final</span> <span class="type">int</span> j; <span class="comment">//类变量j</span></span><br><span class="line">  descriptor: I <span class="comment">//描述符，指向#12</span></span><br><span class="line">  flags: (<span class="number">0x0019</span>) ACC_PUBLIC, ACC_STATIC, ACC_FINAL <span class="comment">//参考7.1,将十六进制的0x0019转成二进制后看看哪些bit位是1哪些就是它的修饰符，显然是ACC_PUBLIC、ACC_STATIC、ACC_FINAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">static</span> <span class="keyword">final</span> <span class="type">int</span> k; <span class="comment">//类变量k</span></span><br><span class="line">  descriptor: I</span><br><span class="line">  flags: (<span class="number">0x0019</span>) ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line">  ConstantValue: <span class="type">int</span> <span class="number">5</span> <span class="comment">//参考9.1，如果一个static final的常量有直接的初始值，那么必定跟一个ConstantValue的属性表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> i; <span class="comment">//成员变量i</span></span><br><span class="line">  descriptor: I</span><br><span class="line">  flags: (<span class="number">0x0002</span>) ACC_PRIVATE</span><br></pre></td></tr></table></figure><h4 id="10-2-5：字节码-方法表"><a href="#10-2-5：字节码-方法表" class="headerlink" title="10.2.5：字节码-方法表"></a>10.2.5：字节码-方法表</h4><blockquote><p>ps：想用更加简洁的方式看方法指令的话，建议使用<code>javap -c</code>。本节只挑选<code>代码块2</code>实例中的几个具有代表性的方法来说明。</p></blockquote><p>下面就是我们的方法表了，内部会包含Code这个涵盖方法主要逻辑的指令码，我们这节会一点点分析这些指令是如何在<code>操作数栈</code>里运行的（<code>操作数栈</code>是运行期要学的一个结构，先做个了解，它位于<code>栈帧</code>内，主要负责执行Code指令码），这里要注意：栈是一种<code>先进后出</code>的数据结构，既然操作数栈是栈，那么必然满足这一点特性。</p><h5 id="10-2-5-1：无参构造器-Test"><a href="#10-2-5-1：无参构造器-Test" class="headerlink" title="10.2.5.1：无参构造器-Test()"></a>10.2.5.1：无参构造器-Test()</h5><p>javap输出的详细信息：</p><figure class="highlight c++"><figcaption><span>代码块7 方法表-Test()</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> sun.juwin.test.<span class="built_in">Test</span>(); <span class="comment">//Test方法，Code区域的指令集是如何在操作数栈运行的？请看图27</span></span><br><span class="line">  descriptor: ()V <span class="comment">//方法描述符，指向#18</span></span><br><span class="line">  flags: (<span class="number">0x0001</span>) ACC_PUBLIC <span class="comment">//参考8.1</span></span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span> <span class="comment">//依次为：最大栈深、逻辑Slot数量（实际上可能少于这个，因为Slot可复用）、参数size，成员方法默认传入this，所以即便Test()里没有参数，这里args_size也是1</span></span><br><span class="line">       <span class="number">0</span>: aload_0 <span class="comment">//取this</span></span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span> <span class="comment">//调用方法：java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: getstatic     #<span class="number">2</span> <span class="comment">//获取类属性：java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">7</span>: ldc           #<span class="number">3</span> <span class="comment">//ldc是指从常量池中取值，放入操作数栈，值为：Test init !</span></span><br><span class="line">       <span class="number">9</span>: invokevirtual #<span class="number">4</span> <span class="comment">//调用方法：java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">12</span>: <span class="keyword">return</span> <span class="comment">//返回指令，用于终止程序</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">15</span>: <span class="number">0</span> <span class="comment">//源代码15行对应指令码第0行，剩下的类推即可（这里源代码以代码块2为准）</span></span><br><span class="line">      line <span class="number">16</span>: <span class="number">4</span></span><br><span class="line">      line <span class="number">17</span>: <span class="number">12</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature <span class="comment">//这里只有一个Slot，它的下标为0</span></span><br><span class="line">          <span class="number">0</span>      <span class="number">13</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lsun/juwin/test/Test;</span><br></pre></td></tr></table></figure><p>先来看下其源代码：</p><figure class="highlight java"><figcaption><span>代码块8</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span> &#123; <span class="comment">//隐式传入this作参数</span></span><br><span class="line">  <span class="built_in">super</span>(); <span class="comment">//隐式调了父类构造器</span></span><br><span class="line">System.out.println(<span class="string">&quot;Test init !&quot;</span>); <span class="comment">//输出一段话</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它对应的指令码参考<code>代码块7-Code部分</code></p><p>当一个线程运行到此方法，会为其创建一个<code>栈帧</code>。</p><blockquote><p><strong>栈帧的基本概念</strong></p><p>栈帧是用于支持jvm进行<code>方法调用</code>和<code>方法执行</code>的<code>数据结构</code>，它是运行期保存在<code>虚拟机栈</code>中的栈元素，是线程运行的基本单元，由<code>执行引擎</code>触发执行其内部保存的字节码指令（这里执行引擎在执行代码时还分为<code>解释执行</code>和<code>编译执行</code>）。栈帧由<code>局部变量表</code>、<code>操作数栈</code>、<code>动态连接</code>、<code>方法返回地址</code>、<code>附加信息</code>组成</p></blockquote><p>Test()方法栈帧结构如图：</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-26.png?imageView2/0/w/1024" alt="图27"></p><p>现在，让我们看一下这个方法在运行时，栈帧内部是如何变化的：</p><p>栈帧初始状态：入参首先填充进局部变量表</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-27-fix.png?imageView2/0/w/600" alt="图28"></p><blockquote><p>解释：首先Test方法是一个非静态方法，其方法第一个入参就是<code>this</code>这个reference类型的变量，因此aload_0就是将该变量推向操作数栈的栈顶。</p></blockquote><p>第一步：<code>aload_0</code>，代表将局部变量表内第0个Slot内保存的变量入栈</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-28-fix.png?imageView2/0/w/600" alt="图29"></p><p>第二步：<code>invokespecial</code>，代表一次构造方法的调用，根据<code>代码块7</code>可知这里调用的是其父类的构造方法</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-29-fix2.png?imageView2/0/w/650" alt="图30"></p><p>随着Object构造方法触发，随之又产生了一个Object构造器的栈帧，用来执行父类构造器逻辑，传入的是<code>子类对象指针this</code>，这点要记住。为了优化内存，jvm开发者们经常会将新开栈帧的<code>局部变量表</code>和上一栈帧的<code>操作数栈</code>共享一些数据，共享是完全按照下一栈帧接收的参数个数来的，比如下一栈帧需要5个参数，那么当前栈帧操作数栈从栈顶开始往下数5个，全部会共享进下一栈帧的局部变量表里。</p><p>还有一点需要说明一下，我们知道在一个对象的构造器被触发时，它的父类构造器首先会被触发，此时很多人认为父类跟子类一样，肯定也是被<code>new</code>了一次，其实不然，集合<code>图29</code>和<code>图30</code>可知，在Test类的构造器被触发之前，就已经存在<code>this指针</code>了，那意味着类对象已经产生了，因此构造器是在对象产生后主动触发的，而父类也没有被new，仅仅是触发了一下它的构造器而已，你可以理解，一个子类对象，其实就是包含了其父类公共方法的类，不存在对象嵌套的情况（即一个子类的对象是不会包含一个父类对象的），这个在<code>第六节</code>会详细讲，本节做个预热即可。</p><p>最后随着新开栈帧运行结束，线程又会再次回到当前栈帧，并将当前栈帧内的操作数栈<code>共享部分</code>清空，若下一栈帧有<code>返回值</code>，则将该值存入当前栈帧的<code>栈顶</code>，否则不进行其他操作。说到这里也知道为什么栈帧也是栈了，先进入的栈帧最后才会执行完，越是新开的栈帧越先结束，这似乎也是栈的特性。</p><p>第三步：<code>getstatic</code>，用来获取某个类的静态属性，由<code>代码块7</code>可知，这里是从类常量池里获取到的<code>PrintStream</code>类型的<code>System</code>类的<code>out</code>静态属性，即<code>System.out</code>。</p><blockquote><p>提示：<code>getstatic</code>的执行流程应为：从常量池获取常量的<code>描述符</code>，然后根据描述符里指示的类和属性名，去对应的类里拿到该属性的值。</p></blockquote><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-30-fix.png?imageView2/0/w/600" alt="图31"></p><p>第四步：<code>ldc</code>，由<code>代码块7</code>可知，这是从常量池里加载String类型字面量“Test init !”入栈</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-31.png?imageView2/0/w/600" alt="图32"></p><p>第五步：<code>invokevirtual</code>，代表了一次虚方法的调用，本例指的是对out对象的<code>println</code>方法的调用</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-32-fix2.png?imageView2/0/w/650" alt="图33"></p><p>结合上图来思考下println的两个参数，首先我们需要明确一点，println不是静态方法，因此它传入的第一个参数一定是“this”，即对象引用，其实任何非静态方法的访问都是如此，需要知道自己的对象是哪位，否则没意义，那么针对println这个方法的“this”，又是谁呢？答案是out，我们是用out对象调用的它，所以这里第一个入参一定是out对象，第二个入参则是“Test init !”，所以上图中共享给下游栈帧的一共有俩，已用<code>红框</code>标出。</p><p>第六步：<code>return</code>，方法执行结束，栈帧出让，就不画图了。</p><p>到这里，我们已经完成了一组指令码的执行过程解析。</p><h5 id="10-2-5-2：sum-i-int-a-int-b"><a href="#10-2-5-2：sum-i-int-a-int-b" class="headerlink" title="10.2.5.2：sum_i(int a, int b)"></a>10.2.5.2：sum_i(int a, int b)</h5><p>再来分析一个方法的执行流程，我们把javap的信息丢出来（这里就不加注释了）：</p><figure class="highlight c++"><figcaption><span>代码块9</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">sum_i</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">  descriptor: (II)I</span><br><span class="line">  flags: (<span class="number">0x0001</span>) ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">4</span>, locals=<span class="number">3</span>, args_size=<span class="number">3</span></span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: getfield      #<span class="number">6</span>                  <span class="comment">// Field i:I</span></span><br><span class="line">       <span class="number">4</span>: aload_0</span><br><span class="line">       <span class="number">5</span>: iload_1</span><br><span class="line">       <span class="number">6</span>: iload_2</span><br><span class="line">       <span class="number">7</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method sum:(II)I</span></span><br><span class="line">      <span class="number">10</span>: iadd</span><br><span class="line">      <span class="number">11</span>: ireturn</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">29</span>: <span class="number">0</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">0</span>      <span class="number">12</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lsun/juwin/test/Test;</span><br><span class="line">          <span class="number">0</span>      <span class="number">12</span>     <span class="number">1</span>     a   I</span><br><span class="line">          <span class="number">0</span>      <span class="number">12</span>     <span class="number">2</span>     b   I</span><br></pre></td></tr></table></figure><p>它的源代码如下：</p><figure class="highlight java"><figcaption><span>代码块10</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum_i</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> i + sum(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它有3个参数，还发生过一次方法调用，最后还要将方法返回的值再加上i属性，然后将结果返回出去，我们来看下这个方法的运行过程。</p><p>老样子，来看下栈帧初始状态：入参首先填充进局部变量表</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-33-fix.png?imageView2/0/w/600" alt="图34"></p><p>这是个非静态方法，第一个参数依然是该方法对应类的某个对象的引用指针（即this），剩下两个参数就是源代码里的a和b。</p><p>第一步：<code>aload_0</code>，代表将局部变量表内第0个Slot内保存的变量入栈，即this入栈，因为接下来的<code>getfield</code>指令要用到，这跟非静态方法需要this的道理一样，获取某个非静态的属性，也需要知道是哪个对象，才能取到对应的值，这就是非静态属性和方法与静态属性方法最大的区别。</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-34-fix.png?imageView2/0/w/600" alt="图35"></p><p>第二步：<code>getfield</code>，这个指令用来获取某对象的某个属性值，本例中为<code>i</code></p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-35-fix.png?imageView2/0/w/600" alt="图36"></p><blockquote><p>提示：<code>getfield</code>执行流程：从常量池获取属性的<code>描述符</code>，然后根据描述符里指示的类和属性名，去对应的<code>类对象</code>里拿到该属性的值。（图中第2步就是利用当前栈顶的this，来打入其内部，将其对应<code>属性i</code>的值取出，并设置入栈顶，替换掉原来的this）</p></blockquote><p>第三步：<code>aload_0</code>，再次将局部变量表内第0个Slot内保存的变量入栈</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-36.png?imageView2/0/w/600" alt="图37"></p><p>第四步：将入参a和b入栈</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-37.png?imageView2/0/w/600" alt="图38"></p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-38.png?imageView2/0/w/600" alt="图39"></p><p>第五步：<code>invokevirtual</code>，虚方法调用，本例指的是对<code>sum方法</code>的调用，通过实例代码可知，sum方法拥有三个参数，即<code>this</code>、<code>a</code>、<code>b</code>，因此开栈帧时需要共享当前栈帧自栈顶往下数3个栈位作为新栈帧的入参</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-39.png?imageView2/0/w/790" alt="图40"></p><p>注意，<code>sum方法</code>是有返回值的，返回值为a和b相加的结果，最终sum栈帧执行完毕再次回到sum_i栈帧时，会将其返回结果入栈，最终sum执行完毕后的情况如下：</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-40.png?imageView2/0/w/600" alt="图41"></p><p>第六步：<code>iadd</code>，将栈顶两int型数值相加，并且其运算结果入栈</p><p><img src="http://myblog.sharemer.com/2020/05/06/20200506-1-41.png?imageView2/0/w/600" alt="图42"></p><p>第七步：<code>ireturn</code>，将现在位于栈顶的数据返回出去给上游的栈帧，就不画图了。</p><p>到目前，sum_i方法的执行流程就剖析完毕。</p><h2 id="十一、小结"><a href="#十一、小结" class="headerlink" title="十一、小结"></a>十一、小结</h2><p>本章介绍了Class文件本身的<code>组成</code>以及它内部数据的<code>堆叠</code>方式，还介绍了运行期指令码是怎么被<code>执行引擎</code>所运行的，可以尝试利用这些知识，分析日常中较为复杂的类的字节码文件，熟悉字节码指令对于我们理解日常java代码的一些“特殊性质”有一定的积极作用。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、JAVA的平台无关性&quot;&gt;&lt;a href=&quot;#一、JAVA的平台无关性&quot; class=&quot;headerlink&quot; title=&quot;一、JAVA的平台无关性&quot;&gt;&lt;/a&gt;一、JAVA的平台无关性&lt;/h2&gt;&lt;p&gt;我们最开始学习java的时候了解到java代码文件必须经过&lt;code&gt;javac&lt;/code&gt;的编译，生成字节码文件才可以被JVM识别并运行，而JVM则拥有多种操作系统的版本：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://myblog.sharemer.com/2020/05/06/20200506-1-1-fixed.png?imageView2/0/w/700&quot; alt=&quot;图1&quot;&gt;&lt;/p&gt;
&lt;p&gt;正是因为这些不同操作系统下的JVM版本，使得我们被编译后的字节码文件可以被不同操作系统上的JVM识别并运行，继而实现跨平台。&lt;/p&gt;</summary>
    
    
    
    <category term="JVM" scheme="http://example.com/categories/JVM/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JAVA有关位运算的全套梳理</title>
    <link href="http://example.com/2020/03/10/JAVA%E6%9C%89%E5%85%B3%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%85%A8%E5%A5%97%E6%A2%B3%E7%90%86/"/>
    <id>http://example.com/2020/03/10/JAVA%E6%9C%89%E5%85%B3%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%85%A8%E5%A5%97%E6%A2%B3%E7%90%86/</id>
    <published>2020-03-09T21:11:00.000Z</published>
    <updated>2023-12-05T02:43:14.334Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、在计算机中数据是如何进行计算的？"><a href="#一、在计算机中数据是如何进行计算的？" class="headerlink" title="一、在计算机中数据是如何进行计算的？"></a>一、在计算机中数据是如何进行计算的？</h2><h3 id="1-1：java中的byte型数据取值范围"><a href="#1-1：java中的byte型数据取值范围" class="headerlink" title="1.1：java中的byte型数据取值范围"></a>1.1：java中的byte型数据取值范围</h3><p>我们最开始学习java的时候知道，byte类型的数据占了8个bit位，每个位上或0或1，左边第一位表示符号位，符号位如果为1表示负数，为0则表示正数，因此要推算byte的取值范围，只需要让数值位每一位上都等于1即可。<br>我们来用我们的常规思维来分析下byte类型的取值范围：</p><span id="more"></span><p><img src="http://myblog.sharemer.com/2020/03/10/20200310-1-1.png?imageView2/0/w/700" alt="图1"></p><p>如果按照这种思路来推算，七个1的二进制数转换为十进制是127，算上符号位，取值范围应为：<code>-127~127</code>，但事实上我们知道，byte的取值范围是<code>-128~127</code>，这里先打个问号，接着往下看。<br>现在让我们计算下byte类型的7加上byte类型的-2是多少：</p><p><img src="http://myblog.sharemer.com/2020/03/10/20200310-1-2.png?imageView2/0/w/600" alt="图2"></p><p>诶？跟我们预想的不一样，因为我们是知道7和-2的和应该是5才对，结果应该表示为：00000101，但事实上通过图2的结果来看确实跟预想的不一样，所以计算机在做计算的时候，肯定不是表面上的符号位+数值位的方式进行的计算的。</p><h3 id="1-2：原码，反码，补码"><a href="#1-2：原码，反码，补码" class="headerlink" title="1.2：原码，反码，补码"></a>1.2：原码，反码，补码</h3><p>我们先来看下定义：</p><p>👉 <strong>原码定义：</strong>符号位加后面的数值，比如<code>图2</code>里的<code>00000111</code>和<code>10000010</code>都是原码，原码比较简单，就是我们在上面单纯理解上的原值。</p><p>👉 <strong>反码定义：</strong>正数的反码就是它的原码，负数的反码符号位不变，其余数值位全部按位取反，例如：</p><blockquote><p><code>00000111</code>的反码：<code>00000111</code><br><code>10000010</code>的反码：<code>11111101</code></p></blockquote><p>👉 <strong>补码定义：</strong>同样的，正数的补码仍然等于它的原码本身，负数的补码等于它自己的反码+1，例如：</p><blockquote><p><code>00000111</code>的补码：<code>00000111</code><br><code>10000010</code>的补码：<code>11111110</code></p></blockquote><p>🌴 总结：正数的原码、反码、补码完全一致，负数的反码等于它原码的数值位按位取反，负数的补码等于它的反码+1</p><p>现在让我们用反码的方式来计算下<code>图2</code>中的式子：</p><p><img src="http://myblog.sharemer.com/2020/03/10/20200310-1-3.png?imageView2/0/w/500" alt="图3"></p><p>利用数值的反码计算出的结果已经很接近正确答案了，+4的反码等于它的原码，现在只需要让它+1就是正确答案，还记得补码的定义吗？负数的补码等于它的反码+1，那现在让我们用补码做下计算试试？</p><p><img src="http://myblog.sharemer.com/2020/03/10/20200310-1-4.png?imageView2/0/w/500" alt="图4"></p><p>ok，我们发现，用它们的补码做加法，得到的数值就是我们想要的正确答案，事实上，计算机并没有减法运算器，所有的减法运算，都是以一个正数加上一个负数的形式来交给加法运算器计算的，由于负数的符号位为1，虽然我们人是知道它的含义，但是作为计算机，它是不知道第一位是符号位的，它要做的就仅仅是让两个数相加而已，正是因为如此，我们才不能简简单单保存负数，通过图4我们知道，两个数的补码相加，可以得到一个准确的数值。</p><p>再举个相加结果为负数的例子，让两个负数相加：</p><p><img src="http://myblog.sharemer.com/2020/03/10/20200310-1-5.png?imageView2/0/w/600" alt="图5"></p><p>如果结果为负数的话，也是适用的，只是它仍然是以补码的形式存放的，需要转成原码才符合我们人的理解方式。</p><p>现在回到上面留下的问题，为什么byte的取值范围是-128~127呢？</p><p>我们之前按照<code>图1</code>里的理解，理所应当的以为它应该是-127~127的范围，那是因为我们按照<code>图1</code>的理解方式，数值就是以符号位+数值位的方式理解的（也就是按照原码的方式理解的），但是你可以想一下，如果按照<code>图1</code>那种理解方式，是不是会存在两个0值呢？</p><p>即：<code>10000000</code>和<code>00000000</code>，<code>+0</code>和<code>-0</code>；</p><p>其次如果站在机器角度上来说，所有的负数都很大，至少要比所有正数大，因为负数的最高位也就是符号位都是1，显然这是不对的，通过本节我们知道了，所有的数均通过自己的补码完成计算，如果将最后得到的结果转成原码，就是我们人眼可以理解的最终值（符号位+数值位），如果现在利用补码的方式做理解，符号位为0的数没啥好说的，自然取值区间为：0~127，但是符号位为1的负数呢？负数就存在一个特殊值（也就是我们之前片面理解的-0）：10000000，如果按照原码理解它是-0，但我们前面说过，计算机里所有数字，都是以补码的方式参与运算的，而负数的补码不等于其原码，这个10000000在计算机里显然是某个负数的补码，那么问题就变的简单多了，即10000000是谁的补码呢？答案是：-128，这也是为什么负数的取值范围会比正数多一个的原因，byte类型如此，其它类型也是如此，比如int型的负数取值也比正数多1。</p><p>这一块的定义要清晰，对理解后面的位运算会有很大的帮助。</p><h2 id="二、java中的位运算"><a href="#二、java中的位运算" class="headerlink" title="二、java中的位运算"></a>二、java中的位运算</h2><h3 id="2-1：与运算"><a href="#2-1：与运算" class="headerlink" title="2.1：与运算"></a>2.1：与运算</h3><p>与运算符号：<code>&amp;</code></p><p>与运算特点：<strong>1&amp;1&#x3D;1、1&amp;0&#x3D;0、0&amp;1&#x3D;0、0&amp;0&#x3D;0</strong></p><p>现在我们来举一个例子：</p><p><img src="http://myblog.sharemer.com/2020/03/10/20200310-1-6.png?imageView2/0/w/700" alt="图6"></p><p>让我们再来试试负数：</p><p><img src="http://myblog.sharemer.com/2020/03/10/20200310-1-7.png?imageView2/0/w/700" alt="图7"></p><h3 id="2-2：或、异或"><a href="#2-2：或、异或" class="headerlink" title="2.2：或、异或"></a>2.2：或、异或</h3><p>跟与运算的运算方式一致，只不过规则不太一样：</p><p>或运算符号：<code>|</code></p><p>或运算规则：<strong>1|1&#x3D;1、1|0&#x3D;1、0|1&#x3D;1、0|0&#x3D;0</strong></p><p>异或运算符号：<code>^</code></p><p>异或运算规则：<strong>1^1&#x3D;0、1^0&#x3D;1、0^1&#x3D;1、0^0&#x3D;0</strong></p><h3 id="2-3：按位取反"><a href="#2-3：按位取反" class="headerlink" title="2.3：按位取反"></a>2.3：按位取反</h3><p>取反符号：<code>~</code></p><p>即一个数对自己取反，例如：</p><p>某个数字<strong>a</strong>的二进制为： <code>1010110</code>，则**~a**为： <code>0101001</code></p><h3 id="2-4：左移运算"><a href="#2-4：左移运算" class="headerlink" title="2.4：左移运算"></a>2.4：左移运算</h3><p>左移运算符：<code>&lt;&lt;</code></p><p>例如：</p><p><img src="http://myblog.sharemer.com/2020/03/10/20200310-1-8.png?imageView2/0/w/700" alt="图8"></p><p><strong>位运算越界&amp;数位抛弃：</strong></p><p><code>图8</code>中的116的二进制数的数值位为7位，符号位为0，此时如果左移超过24位，就会出现负数，为什么会这样？因为java中的位移越界时，java会抛弃高位越界部分，我们知道java里int类型的第一位是符号位，如果符号位是1，则表示其为负数，现在将数值位占7bit符号位为0的116左移24位，就会出现下方结果：</p><p><code>01110100000000000000000000000000</code></p><p>正好31位占全，顶至符号位，低位补0，我们称24为116的不越界的最大左移值，若超出这个值，就会越界，比如左移25位：</p><p><code>11101000000000000000000000000000</code></p><p>显然左移25位后会把数值位的1移动到符号位，这时它表示为一个负数的补码。根据这个规则，我们如果让其左移28位，则值为：</p><p><code>01000000000000000000000000000000</code></p><p>也就是十进制的1073741824，即：116 &lt;&lt; 28 &#x3D; 1073741824，那如果越界过多呢？比如int型的数据，左移32位：116 &lt;&lt; 32 &#x3D; 116</p><p>会发现，如果左移自己位数一样多的位数，那么这个数就等于它本身，因此运算符合以下规则：</p><p>设x为被位移值，y为本次位移的位数，z为x所属类型的最大存储位数：</p><p><strong>x &lt;&lt; y &#x3D; x &lt;&lt; (y%z)</strong></p><p>如果是int型（32位，long型就用64代入计算），符合如下规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">116</span> &lt;&lt; <span class="number">4</span> = <span class="number">116</span> &lt;&lt; (<span class="number">4</span>%<span class="number">32</span>) = <span class="number">116</span> &lt;&lt; <span class="number">4</span> = <span class="number">1856</span></span><br><span class="line"><span class="number">116</span> &lt;&lt; <span class="number">32</span> = <span class="number">116</span> &lt;&lt; (<span class="number">32</span>%<span class="number">32</span>) = <span class="number">116</span> &lt;&lt; <span class="number">0</span> = <span class="number">116</span></span><br><span class="line"><span class="number">116</span> &lt;&lt; <span class="number">36</span> = <span class="number">116</span> &lt;&lt; (<span class="number">36</span>%<span class="number">32</span>) = <span class="number">116</span> &lt;&lt; <span class="number">4</span> = <span class="number">1856</span></span><br></pre></td></tr></table></figure><h3 id="2-5：有符号右移运算-无符号右移运算"><a href="#2-5：有符号右移运算-无符号右移运算" class="headerlink" title="2.5：有符号右移运算&amp;无符号右移运算"></a>2.5：有符号右移运算&amp;无符号右移运算</h3><p>有符号右移运算符：<code>&gt;&gt;</code></p><p>无符号右移运算符：<code>&gt;&gt;&gt;</code></p><p>例如：a &gt;&gt; b表示a右移b位，跟上面的左移例子一样，右移也会有越界问题，只是右移越界是从右边开始抛弃越界部分的，右移操作有符号位干扰，如果是正数右移，无此干扰项，因为符号位本就是0右移不会影响值的准确性，但如果是负数，第一位是符号位，且值为1，右移就有影响了，现在仍然以116为例：</p><p>正数右移：</p><p><img src="http://myblog.sharemer.com/2020/03/10/20200310-1-9.png?imageView2/0/w/600" alt="图9"></p><p>上述是正数，右移无影响，但是负数，这里以-116为例，我们知道负数在计算机里是以补码的形式存储的，所以图里直接用-116的补码做运算，位移过程如下：</p><p><img src="http://myblog.sharemer.com/2020/03/10/20200310-1-10.png?imageView2/0/w/600" alt="图10"></p><p>你会发现右移跟左移不一样，左移是不用担心自己符号位存在“补位”问题的，但是右移存在，如图中-116右移4位后，左边第一位，也就是符号位，就面临着补位的问题，那我现在是该补1呢，还是补0呢？这也就是为什么右移操作会存在有符号右移和无符号右移两种移动方式：</p><p><strong>☘️ 有符号右移：</strong>依照原符号位，如果原符号位是1，那么图4里需要补位的空位全部补1，如果原符号位为0，则全部补0</p><p><strong>☘️ 无符号右移：</strong>无视原符号位，全部补0</p><p>现在让我们用有符号的方式将-116右移4位，即-116 &gt;&gt; 4，按照有符号的规则，补位符合原符号位，则右边4位全部补1：</p><p><img src="http://myblog.sharemer.com/2020/03/10/20200310-1-11.png?imageView2/0/w/600" alt="图11"></p><p>得到的仍然是个负数，它仍然是一个补码，图里展示不开，它的结果为：<code>11111111111111111111111111111000</code>，经转换可知它是-8的补码，即：**-116 &gt;&gt; 4 &#x3D; -8**</p><p>现在再试试用无符号右移，根据无符号的特点，右移后的前四位无脑补0：</p><p><img src="http://myblog.sharemer.com/2020/03/10/20200310-1-12.png?imageView2/0/w/600" alt="图12"></p><p>图里展示不开，它的结果为：<code>00001111111111111111111111111000</code></p><p>可见它是个正数，转换成十进制为：268435448，即：**-116 &gt;&gt;&gt; 4 &#x3D; 268435448**</p><p>最后说一下，跟左移一样，右移里不管是有符号还是无符号，也符合取余的方式，计算出位移的最终位数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">116</span> &gt;&gt; <span class="number">4</span> = -<span class="number">116</span> &gt;&gt; (<span class="number">4</span>%<span class="number">32</span>) = -<span class="number">116</span> &gt;&gt; <span class="number">4</span> = -<span class="number">8</span></span><br><span class="line">-<span class="number">116</span> &gt;&gt; <span class="number">32</span> = -<span class="number">116</span> &gt;&gt; (<span class="number">32</span>%<span class="number">32</span>) = -<span class="number">116</span> &gt;&gt; <span class="number">0</span> = -<span class="number">116</span></span><br><span class="line">-<span class="number">116</span> &gt;&gt; <span class="number">36</span> = -<span class="number">116</span> &gt;&gt; (<span class="number">36</span>%<span class="number">32</span>) = -<span class="number">116</span> &gt;&gt; <span class="number">4</span> = -<span class="number">8</span></span><br></pre></td></tr></table></figure><h3 id="2-6：类型转换溢出"><a href="#2-6：类型转换溢出" class="headerlink" title="2.6：类型转换溢出"></a>2.6：类型转换溢出</h3><p>了解完位运算，来看一个比较实际的问题，看下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8934567890233345621L</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">int</span>) a; <span class="comment">//b的值为-1493678507</span></span><br></pre></td></tr></table></figure><p>最终b的值是一个负数，这是由于long型64位，让int型强行接收，会出现位溢出的问题，这个流程如下：</p><p><img src="http://myblog.sharemer.com/2020/03/10/20200310-1-13.png?imageView2/0/w/1000" alt="图13"></p><h2 id="三、位运算在实际项目中的运用"><a href="#三、位运算在实际项目中的运用" class="headerlink" title="三、位运算在实际项目中的运用"></a>三、位运算在实际项目中的运用</h2><p>位运算的性能是非常好的，相比运算流程，计算机更喜欢这种纯粹的逻辑门和移动位置的运算，但位运算在平常的业务代码里并不太常见，因为它的可读性不太好，但是我们仍然可以利用位运算来解决一些实际项目里的问题。</p><p>比如用来表示开关的功能，比如需求里经常有这种字段：是否允许xx（0不允许，1允许），是否有yy权限（0没有，1有），是否存在zz（0不存在，1存在）</p><p>上面只是举例，类似这种只有两种取值状态的属性，如果当成数据库字段放进去的话，太过浪费，如果之后又有类似的字段，又得新增数据库字段，为了只有两种取值的字段，实在是不太值得。</p><p>这个时候何不用一个字段来表示这些字段呢？你可能已经猜到要怎么做了：</p><p><img src="http://myblog.sharemer.com/2020/03/10/20200310-1-14.png?imageView2/0/w/800" alt="图14"></p><p>顶一个int型或者long型的字段，让它的每一个二进制位拥有特殊含义即可，然后按照位运算将其对应的位置上的数值变成0或1，那如何将某个数的二进制位第x位上的数值变成1或0呢？其实这在位图结构里经常用到，就是利用1这个特殊的值作位移运算后再与原值进行位运算，让我们看下这个过程：</p><p>把一个数的第2位的字符变成1，现在假设这个数初始化为0，int型，我们把它当成二进制展示出来：</p><p><img src="http://myblog.sharemer.com/2020/03/10/20200310-1-15.png?imageView2/0/w/1000" alt="图15"></p><p>现在如何把这个数的第二位变成1呢？目前是这样做的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> | <span class="number">1</span> &lt;&lt; <span class="number">1</span></span><br></pre></td></tr></table></figure><p>即原值跟1左移1位后的值作或运算，先来看看<code>1 &lt;&lt; 1</code>的结果：</p><p><img src="http://myblog.sharemer.com/2020/03/10/20200310-1-16.png?imageView2/0/w/1000" alt="图16"></p><p>然后拿着<code>图16</code>的结果，跟<code>原数</code>（也就是0）进行<code>或运算</code>：</p><p><img src="http://myblog.sharemer.com/2020/03/10/20200310-1-17.png?imageView2/0/w/1000" alt="图17"></p><p>可以看到，原数的第二位已经被置为1了，它的十进制对应2，其它位的数置为1也大同小异，例如，现在让第6位也变成1只需要：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> | <span class="number">1</span> &lt;&lt; <span class="number">5</span></span><br></pre></td></tr></table></figure><p>即拿着原值（现在为2）跟1左移5位后的数做或运算，这个流程如下：</p><p><img src="http://myblog.sharemer.com/2020/03/10/20200310-1-18.png?imageView2/0/w/1024" alt="图18"></p><p>看完了把某个位置的数值置为1，那如何把某位设置为0呢？我们现在把<code>图18</code>里的结果的第6位重新置回0，目前的做法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">34</span> &amp; ~(<span class="number">1</span> &lt;&lt; <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>即拿着原值（经过上面几步的运算，现在值为34）跟1左移5位按位取反后的数做与运算，来看下这个流程：</p><p><img src="http://myblog.sharemer.com/2020/03/10/20200310-1-19.png?imageView2/0/w/1024" alt="图19"></p><p>经过上面的流程，就可以把原值的第6位变成0了。</p><p>那么我们知道了让一个数的二进制位的某位变成0或1的方法，那如何知道一个数的某位上究竟是0还是1呢？毕竟我们业务代码需要知道第几位代表什么意思并且获取到对应位置上的值。</p><p>假如我现在想知道十进制int型数34的第6位是0还是1，写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">34</span> &gt;&gt; <span class="number">5</span> &amp; <span class="number">1</span></span><br></pre></td></tr></table></figure><p>即让原值（34）右移5位后跟1做与运算，来看下这个流程：</p><p><img src="http://myblog.sharemer.com/2020/03/10/20200310-1-20.png?imageView2/0/w/1024" alt="图20"></p><p>由图可以看出，想要知道一个数的第几位是1还是0，只需要将其对应位置上的值“逼”到最后一位，然后跟1相与即可，如果对应位置上的值是0，那么与1相与后的结果一定为0，反之一定为1.</p><p><strong>☘️ 总结</strong></p><p>到这里已经说完了为什么要用一个数表示那么多开关，以及如何给一个开关位设置对应的开关值，以及如何找到对应开关位的值，有了这些操作，我们再也不需要为这种只有0和1取值的字段新增数据库字段了，因为一个int型的数字，就可以表达32个开关属性，如果超了，还可以扩成64位的long型~</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、在计算机中数据是如何进行计算的？&quot;&gt;&lt;a href=&quot;#一、在计算机中数据是如何进行计算的？&quot; class=&quot;headerlink&quot; title=&quot;一、在计算机中数据是如何进行计算的？&quot;&gt;&lt;/a&gt;一、在计算机中数据是如何进行计算的？&lt;/h2&gt;&lt;h3 id=&quot;1-1：java中的byte型数据取值范围&quot;&gt;&lt;a href=&quot;#1-1：java中的byte型数据取值范围&quot; class=&quot;headerlink&quot; title=&quot;1.1：java中的byte型数据取值范围&quot;&gt;&lt;/a&gt;1.1：java中的byte型数据取值范围&lt;/h3&gt;&lt;p&gt;我们最开始学习java的时候知道，byte类型的数据占了8个bit位，每个位上或0或1，左边第一位表示符号位，符号位如果为1表示负数，为0则表示正数，因此要推算byte的取值范围，只需要让数值位每一位上都等于1即可。&lt;br&gt;我们来用我们的常规思维来分析下byte类型的取值范围：&lt;/p&gt;</summary>
    
    
    
    <category term="JAVA基础" scheme="http://example.com/categories/JAVA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="位运算" scheme="http://example.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    <category term="JAVA" scheme="http://example.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>【JAVA进化论】序</title>
    <link href="http://example.com/2020/02/24/%E3%80%90JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA%E3%80%91%E5%BA%8F/"/>
    <id>http://example.com/2020/02/24/%E3%80%90JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA%E3%80%91%E5%BA%8F/</id>
    <published>2020-02-24T07:26:00.000Z</published>
    <updated>2023-12-06T11:17:16.570Z</updated>
    
    <content type="html"><![CDATA[<h3 id="序章"><a href="#序章" class="headerlink" title="序章"></a>序章</h3><blockquote><p>☕️ 这是一套JAVA基础教程，每一课时的内容下方有链接～</p><p>最近有一项工作，让测试同学对java这门语言进行入门，并且可以独立review开发写出来的代码。想着自己正式做java开发已经快4年了，想着给别人讲一些基础做下入门应该没啥大问题了吧，但在整理过程中发现，有些东西想整理的很通俗易懂还是很难的，好在基础篇的教程最后还是坚持下来了，自己收获也不少，很多基础知识在自己整理的过程中又加深了一遍印象，同时作为一种个人经历，我也想把这些文档放到个人的文库里。</p><p>关于进阶篇，没有继续更新，因为整理的太细，课程耗时会很久，就采用了另一种速成的方式教他们了，所以文档本身到基础篇就断掉了。</p></blockquote><span id="more"></span><h3 id="知识大纲"><a href="#知识大纲" class="headerlink" title="知识大纲"></a>知识大纲</h3><p>下面的脑图是对java基础知识&amp;进阶知识的梳理：</p><p><img src="http://myblog.sharemer.com/2020/02/24/20200224-1-1.png?imageView2/0/w/1500" alt="基础篇"></p><p><img src="http://myblog.sharemer.com/2020/02/24/20200224-1-2.png?imageView2/0/w/1329" alt="进阶篇"></p><h3 id="基础篇教程目录"><a href="#基础篇教程目录" class="headerlink" title="基础篇教程目录"></a>基础篇教程目录</h3><h4 id="第一课时"><a href="#第一课时" class="headerlink" title="第一课时"></a>第一课时</h4><p><a href="/2020/02/25/%E3%80%90JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA%E3%80%91LV1-1%EF%BC%9A%E5%AE%89%E8%A3%85java%E7%8E%AF%E5%A2%83&%E7%AC%AC%E4%B8%80%E4%B8%AAjava%E7%A8%8B%E5%BA%8F/">LV1-1：安装java环境&amp;第一个java程序</a></p><p><a href="/2020/02/26/%E3%80%90JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA%E3%80%91LV1-2%EF%BC%9Ajava%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/">LV1-2：java中的变量类型</a></p><p><a href="/2020/02/28/%E3%80%90JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA%E3%80%91LV1-3%EF%BC%9Ajava%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6/">LV1-3：java中的运算符</a></p><p><a href="/2020/03/02/%E3%80%90JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA%E3%80%91LV1-4%EF%BC%9A%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5&%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/">LV1-4：条件语句&amp;循环语句</a></p><h4 id="第二课时"><a href="#第二课时" class="headerlink" title="第二课时"></a>第二课时</h4><p><a href="/2020/03/02/%E3%80%90JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA%E3%80%91LV2-1%EF%BC%9A%E7%B1%BB&%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/">LV2-1：类&amp;引用变量的简单介绍</a></p><p><a href="/2020/03/05/%E3%80%90JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA%E3%80%91LV2-2%EF%BC%9A%E5%8C%85%E7%9A%84%E5%AE%9A%E4%B9%89%E3%80%81%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90%E3%80%81%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/">LV2-2：包的定义、类的基本组成、访问权限修饰符</a></p><p><a href="/2020/03/05/%E3%80%90JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA%E3%80%91LV2-3%EF%BC%9A%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/">LV2-3：变量的作用域</a></p><p><a href="/2020/03/10/%E3%80%90JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA%E3%80%91LV2-4%EF%BC%9A%E7%B1%BB%E7%9A%84%E7%89%B9%E6%80%A7%E3%80%81%E5%85%B3%E7%B3%BB/">LV2-4：类的特性、关系</a></p><p><a href="/2020/03/12/%E3%80%90JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA%E3%80%91LV2-5%EF%BC%9A%E6%8E%A5%E5%8F%A3/">LV2-5：接口</a></p><p><a href="/2020/03/12/%E3%80%90JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA%E3%80%91LV2-6%EF%BC%9Ajava%E5%8E%9F%E7%94%9F%E7%B1%BB&%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85%E4%BE%9D%E8%B5%96/">LV2-6：java原生类&amp;第三方包依赖</a></p><p><a href="/2020/03/12/%E3%80%90JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA%E3%80%91LV2-7%EF%BC%9A%E3%80%90%E6%A1%88%E4%BE%8B%E3%80%91%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/">LV2-7：【案例】学生信息管理系统</a></p><h4 id="第三课时"><a href="#第三课时" class="headerlink" title="第三课时"></a>第三课时</h4><p><a href="/2020/03/12/%E3%80%90JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA%E3%80%91LV3-1%EF%BC%9A%E4%BD%9C%E7%94%A8%E5%9C%A8%E7%B1%BB%E3%80%81%E5%8F%98%E9%87%8F%E3%80%81%E6%96%B9%E6%B3%95%E4%B8%8A%E7%9A%84%E5%85%B6%E5%AE%83%E4%BF%AE%E9%A5%B0%E7%AC%A6/">LV3-1：作用在类、变量、方法上的其它修饰符</a></p><p><a href="/2020/03/12/%E3%80%90JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA%E3%80%91LV3-2%EF%BC%9A%E5%86%85%E9%83%A8%E7%B1%BB/">LV3-2：内部类</a></p><p><a href="/2020/03/17/%E3%80%90JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA%E3%80%91LV3-3%EF%BC%9AObject&%E6%B3%9B%E5%9E%8B/">LV3-3：Object&amp;泛型</a></p><p><a href="/2020/03/17/%E3%80%90JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA%E3%80%91LV3-4%EF%BC%9A%E5%8F%8D%E5%B0%84%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91/">LV3-4：反射【转载】</a></p><h4 id="第四课时"><a href="#第四课时" class="headerlink" title="第四课时"></a>第四课时</h4><p><a href="/2020/03/20/%E3%80%90JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA%E3%80%91LV4-1%EF%BC%9Ajava%E7%9A%84IO-API/">LV4-1：java的IO-API</a></p><p><a href="/2020/03/23/%E3%80%90JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA%E3%80%91LV4-2%EF%BC%9Ajava%E5%B8%B8%E7%94%A8%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/">LV4-2：java常用的集合类以及它们之间的区别</a></p><p><a href="/2020/03/23/%E3%80%90JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA%E3%80%91LV4-3%EF%BC%9Ajava%E9%87%8C%E7%9A%84Map/">LV4-3：java里的Map</a></p><p><a href="/2020/03/25/%E3%80%90JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA%E3%80%91LV4-4%EF%BC%9A%E4%BD%8D%E5%9B%BE/">LV4-4：位图</a></p><p><a href="/2020/03/27/%E3%80%90JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA%E3%80%91LV4-5%EF%BC%9A%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E3%80%81%E5%8D%8F%E8%AE%AE%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E3%80%81%E7%A8%8B%E5%BA%8F%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB/">LV4-5：网络通信、协议、序列化、程序之间的联系</a></p><h4 id="第五课时"><a href="#第五课时" class="headerlink" title="第五课时"></a>第五课时</h4><p><a href="/2020/03/31/%E3%80%90JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA%E3%80%91LV5-1%EF%BC%9A%E8%BF%9B%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E7%BA%BF%E7%A8%8B%E5%8F%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/">LV5-1：进程是什么？线程又是什么？</a></p><p><a href="/2020/04/01/%E3%80%90JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA%E3%80%91LV5-2%EF%BC%9A%E5%B9%B6%E5%8F%91&%E5%B9%B6%E8%A1%8C/">LV5-2：并发&amp;并行</a></p><p><a href="/2020/04/01/%E3%80%90JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA%E3%80%91LV5-3%EF%BC%9Ajava%E9%87%8C%E7%9A%84%E5%90%8C%E6%AD%A5%E9%94%81/">LV5-3：java里的同步锁</a></p><p><a href="/2020/04/01/%E3%80%90JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA%E3%80%91LV5-4%EF%BC%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%9Await%E3%80%81notify%E3%80%81notifyall/">LV5-4：线程通信：wait、notify、notifyall</a></p><p><a href="/2020/04/02/%E3%80%90JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA%E3%80%91LV5-5%EF%BC%9A%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%EF%BC%9Ajoin%E3%80%81yield%E3%80%81sleep%E3%80%81interrupt/">LV5-5：线程调度：join、yield、sleep、interrupt</a></p><p><a href="/2020/04/02/%E3%80%90JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA%E3%80%91LV5-6%EF%BC%9Ajava%E5%B9%B6%E5%8F%91%E5%8C%85-juc%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/">LV5-6：java并发包-juc的简单介绍</a></p><h3 id="进阶篇教程目录"><a href="#进阶篇教程目录" class="headerlink" title="进阶篇教程目录"></a>进阶篇教程目录</h3><p>🐦：咕咕…咕咕咕…</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;序章&quot;&gt;&lt;a href=&quot;#序章&quot; class=&quot;headerlink&quot; title=&quot;序章&quot;&gt;&lt;/a&gt;序章&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;☕️ 这是一套JAVA基础教程，每一课时的内容下方有链接～&lt;/p&gt;
&lt;p&gt;最近有一项工作，让测试同学对java这门语言进行入门，并且可以独立review开发写出来的代码。想着自己正式做java开发已经快4年了，想着给别人讲一些基础做下入门应该没啥大问题了吧，但在整理过程中发现，有些东西想整理的很通俗易懂还是很难的，好在基础篇的教程最后还是坚持下来了，自己收获也不少，很多基础知识在自己整理的过程中又加深了一遍印象，同时作为一种个人经历，我也想把这些文档放到个人的文库里。&lt;/p&gt;
&lt;p&gt;关于进阶篇，没有继续更新，因为整理的太细，课程耗时会很久，就采用了另一种速成的方式教他们了，所以文档本身到基础篇就断掉了。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="JAVA进化论" scheme="http://example.com/categories/JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA/"/>
    
    
    <category term="JAVA进化论" scheme="http://example.com/tags/JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>IDEA插件开发：一个简单的表单demo</title>
    <link href="http://example.com/2019/12/13/IDEA%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%EF%BC%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%A1%A8%E5%8D%95demo/"/>
    <id>http://example.com/2019/12/13/IDEA%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%EF%BC%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%A1%A8%E5%8D%95demo/</id>
    <published>2019-12-13T04:12:00.000Z</published>
    <updated>2023-12-05T02:53:24.724Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>🐜 版本信息：<img src="https://img.shields.io/badge/JDK-v1.8%2B-orange"/><img src="https://img.shields.io/badge/IntelliJ%20IDEA-2019.03-blueviolet"/> </p><p>🐝 插件项目基于<code>gradle</code>构建。</p><p>🦟 知识背景：<code>swing</code></p><p>🦇 参考文档：</p><p><a href="http://www.jetbrains.org/intellij/sdk/docs/tutorials/build_system/prerequisites.html">http://www.jetbrains.org/intellij/sdk/docs/tutorials/build_system/prerequisites.html</a></p><p><a href="http://www.jetbrains.org/intellij/sdk/docs/user_interface_components/tool_windows.html">http://www.jetbrains.org/intellij/sdk/docs/user_interface_components/tool_windows.html</a></p><p><a href="http://www.jetbrains.org/intellij/sdk/docs/user_interface_components/dialog_wrapper.html">http://www.jetbrains.org/intellij/sdk/docs/user_interface_components/dialog_wrapper.html</a></p><p><a href="https://intellij-support.jetbrains.com/hc/en-us/community/posts/360003338799-Build-compatible-plugin">https://intellij-support.jetbrains.com/hc/en-us/community/posts/360003338799-Build-compatible-plugin</a></p></blockquote><span id="more"></span><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>本实例实现一个<code>Idea</code>的插件，弹出一个<code>表单Dialog</code>，然后点击按钮，获取表单里输入的内容，然后将内容打印在表单的上方。</p><p>成品图展示：</p><p><img src="http://myblog.sharemer.com/2019/12/13/20191213-1-1.png?imageView2/0/w/500" alt="图1"></p><h2 id="一、项目初始化"><a href="#一、项目初始化" class="headerlink" title="一、项目初始化"></a>一、项目初始化</h2><p>新建一个<code>gradle</code>项目，修改其<code>build.gradle</code>文件：</p><figure class="highlight groovy"><figcaption><span>代码块1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;java&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;org.jetbrains.intellij&#x27;</span> version <span class="string">&#x27;0.4.14&#x27;</span> <span class="comment">//引入intellij的gradle插件</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">group <span class="string">&#x27;org.example&#x27;</span></span><br><span class="line">version <span class="string">&#x27;1.0&#x27;</span> <span class="comment">//定义jar包/zip包的版本号</span></span><br><span class="line"> </span><br><span class="line">sourceCompatibility = <span class="number">1.8</span> <span class="comment">//限制jdk的使用版本号，这里限制到8，表示生成的idea插件只能运行在jdk8以上的环境中</span></span><br><span class="line"> </span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral() <span class="comment">//远程仓库</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">//这里引别的依赖包</span></span><br><span class="line">    testCompile <span class="attr">group:</span> <span class="string">&#x27;junit&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;junit&#x27;</span>, <span class="attr">version:</span> <span class="string">&#x27;4.12&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// See https://github.com/JetBrains/gradle-intellij-plugin/</span></span><br><span class="line">intellij &#123;</span><br><span class="line">    <span class="comment">// 这里是指打插件包的时候用idea什么版本的依赖包打</span></span><br><span class="line">    <span class="comment">// 比如这里用2019.3打包，如果你的插件实现源码里用了2019.3不存在的依赖包或类，就会报错</span></span><br><span class="line">    <span class="comment">// 一般就填当前IDEA的版本号即可</span></span><br><span class="line">    version <span class="string">&quot;2019.3&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">patchPluginXml &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//changeNotes里的内容展示位置参考图14</span></span><br><span class="line">    changeNotes <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">      1.0版本.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      第1.0版本：初始化这个测试插件项目&quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 这个意思是说当前定义的这个插件最早支持到什么版本的IDEA</span></span><br><span class="line">    <span class="comment">// 这里配置sinceBuild=191，表示插件只能被版本号大于等于2019.1版本的IDEA安装，低于这个版本的将抛无法兼容的错误</span></span><br><span class="line">    <span class="comment">// ↑上方参考这篇问答：https://intellij-support.jetbrains.com/hc/en-us/community/posts/360003338799-Build-compatible-plugin</span></span><br><span class="line">    sinceBuild <span class="string">&quot;191&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后Idea的右边栏gradle将会多出intellij选项：</p><p><img src="http://myblog.sharemer.com/2019/12/13/20191213-1-2.png?imageView2/0/w/500" alt="图2"></p><p>这里说下<code>runIde</code>，它用来调试插件，运行它会再次启动一个Idea，这个Idea会自动安装上你当前定义的插件包，让你用来调试。</p><h2 id="二、新增plugin-xml"><a href="#二、新增plugin-xml" class="headerlink" title="二、新增plugin.xml"></a>二、新增plugin.xml</h2><p>这个文件非常重要，它可以指定你定义的插件出现在IDEA的哪个位置，可以指定具体的处理逻辑，还可以定义插件名称、子名称等等。</p><p>这个文件位于<code>MATE-INF</code>下：</p><p><img src="http://myblog.sharemer.com/2019/12/13/20191213-1-3.png?imageView2/0/w/500" alt="图3"></p><p>配置内容为：</p><figure class="highlight xml"><figcaption><span>代码块2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">idea-plugin</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--插件的id，注意不要跟其他插件重复，这个id全局唯一，尽可能复杂些--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>plugin.test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--插件的名称--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>PluginTest<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">vendor</span> <span class="attr">email</span>=<span class="string">&quot;xxxx@qq.com&quot;</span> <span class="attr">url</span>=<span class="string">&quot;http://www.bilibili.com&quot;</span>&gt;</span>你公司的名字<span class="tag">&lt;/<span class="name">vendor</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--插件的描述信息，支持html，展示的位置参考图14--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>&lt;![CDATA[</span><br><span class="line">    Plugin Test&lt;br&gt;</span><br><span class="line">    第一行：单纯只是个测试&lt;br&gt;</span><br><span class="line">    第二行：都说了只是个测试(●￣(ｴ)￣●)&lt;br&gt;</span><br><span class="line">    &lt;a href=&#x27;https://www.bilibili.com&#x27;&gt;你猜猜这是哪个网站？&lt;/a&gt;</span><br><span class="line">    &lt;em&gt;v1.0&lt;/em&gt;</span><br><span class="line">    ]]&gt;<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">extensions</span> <span class="attr">defaultExtensionNs</span>=<span class="string">&quot;com.intellij&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Add your extensions here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--跟build.gradle里的sinceBuild一致即可，意义相同，必须配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">idea-version</span> <span class="attr">since-build</span>=<span class="string">&quot;191&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">actions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--下面的group是分组，分组需要有一个唯一的id标识，text用来控制分组出现在IDEA时呈现的文案，description是描述，不会展现出来，简单描述下分组就行--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">group</span> <span class="attr">id</span>=<span class="string">&quot;PluginTest&quot;</span> <span class="attr">text</span>=<span class="string">&quot;插件测试组&quot;</span> <span class="attr">description</span>=<span class="string">&quot;插件测试描述&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--add-to-group控制把该分组加到IDEA里，group-id用来描述加在哪个位置，MainMenu表示加在IDEA上方的主菜单栏里，</span></span><br><span class="line"><span class="comment">            anchor表示顺序，last表示最后一个，所以下面的配置可以描述为：将该插件加到IDEA上方主菜单栏的最后一位--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">add-to-group</span> <span class="attr">group-id</span>=<span class="string">&quot;MainMenu&quot;</span> <span class="attr">anchor</span>=<span class="string">&quot;last&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--这个用来指定一个分组下的触发动作，同样的需要一个id，自定义；class就是用来处理这个动作的逻辑类，具体的插件逻辑都会写到对应的action类里，text用来控制文案，description为描述--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span> <span class="attr">id</span>=<span class="string">&quot;Plugin.Test.Action&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">class</span>=<span class="string">&quot;plugin.test.FromAction&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">text</span>=<span class="string">&quot;表单测试&quot;</span> <span class="attr">description</span>=<span class="string">&quot;表单测试描述&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">actions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">idea-plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后定义一个Action类，记为FormAction，继承AnAction，实现其抽象方法actionPerformed即可：</p><figure class="highlight java"><figcaption><span>代码块3</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FromAction</span> <span class="keyword">extends</span> <span class="title class_">AnAction</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(<span class="meta">@NotNull</span> AnActionEvent e)</span> &#123;</span><br><span class="line">        <span class="comment">//TODO 这里放插件逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、启动"><a href="#三、启动" class="headerlink" title="三、启动"></a>三、启动</h2><p>现在双击<code>runIde</code>即可调出另外一个安装了这个插件的IDEA界面，然后可以看运行结果进行调试。 runIde还支持<code>debug模式</code>，不过运行时要<code>右击</code>选择：</p><p><img src="http://myblog.sharemer.com/2019/12/13/20191213-1-4.png?imageView2/0/w/550" alt="图4"></p><p>来看下调试IDEA的界面运行效果：</p><p><img src="http://myblog.sharemer.com/2019/12/13/20191213-1-5.png?imageView2/0/w/1024" alt="图5"></p><h2 id="四、定义Action"><a href="#四、定义Action" class="headerlink" title="四、定义Action"></a>四、定义Action</h2><h3 id="4-1：定义会话框类"><a href="#4-1：定义会话框类" class="headerlink" title="4.1：定义会话框类"></a>4.1：定义会话框类</h3><p>经过上面三步的配置，插件的基本样式已经展示出来，但是点击下方“表单测试”的action，并没有什么用，因为其绑定的FormAction类里没有任何有意义的实现。现在来实现开始的目标，点击“表单测试”后，弹出一个自定义的表单会话框，然后点击按钮，获取表单内容后打印在会话框内。</p><p>会话框（<code>Dialog</code>）需要定义一个继承了IDEA的<code>DialogWrapper</code>抽象类的子类，这个子类就是自定义的会话框实现，所有的样式定义、功能触发都是放到这个子类里的，现定于如下子类：</p><figure class="highlight java"><figcaption><span>代码块4</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FormTestDialog</span> <span class="keyword">extends</span> <span class="title class_">DialogWrapper</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String projectName; <span class="comment">//假如需要获取到项目名，作为该类的属性放进来</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// DialogWrapper没有默认的无参构造方法，所以需要重写构造方法，它提供了很多重载构造方法，</span></span><br><span class="line">    <span class="comment">// 这里使用传project类型参数的那个，通过Project对象可以获取当前IDEA内打开的项目的一些属性，</span></span><br><span class="line">    <span class="comment">// 比如项目名，项目路径等</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FormTestDialog</span><span class="params">(<span class="meta">@Nullable</span> Project project)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(project);</span><br><span class="line">        setTitle(<span class="string">&quot;表单测试~~&quot;</span>); <span class="comment">// 设置会话框标题</span></span><br><span class="line">        <span class="built_in">this</span>.projectName = project.getName();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 重写下面的方法，返回一个自定义的swing样式，该样式会展示在会话框的最上方的位置</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> JComponent <span class="title function_">createNorthPanel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 重写下面的方法，返回一个自定义的swing样式，该样式会展示在会话框的最下方的位置</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> JComponent <span class="title function_">createSouthPanel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 重写下面的方法，返回一个自定义的swing样式，该样式会展示在会话框的中央位置</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> JComponent <span class="title function_">createCenterPanel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2：会话框模块-类元素对照"><a href="#4-2：会话框模块-类元素对照" class="headerlink" title="4.2：会话框模块&amp;类元素对照"></a>4.2：会话框模块&amp;类元素对照</h3><p>找个实际的会话框为例，针对上述中几个方法所控制的会话框里的元素如下：</p><p><img src="http://myblog.sharemer.com/2019/12/13/20191213-1-6.png?imageView2/0/w/1024" alt="图6"></p><h3 id="4-3：自定义会话框元素"><a href="#4-3：自定义会话框元素" class="headerlink" title="4.3：自定义会话框元素"></a>4.3：自定义会话框元素</h3><h4 id="4-3-1：会话框方法重定义"><a href="#4-3-1：会话框方法重定义" class="headerlink" title="4.3.1：会话框方法重定义"></a>4.3.1：会话框方法重定义</h4><p>按照本文的实现目标，自定义的表单主体部分可以位于<code>createCenterPanel</code>里，然后表单的大标题可以放到<code>createNorthPanel</code>里，提交按钮可以放到<code>createSouthPanel</code>里，现在改写如下：</p><figure class="highlight java"><figcaption><span>代码块5</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FormTestDialog</span> <span class="keyword">extends</span> <span class="title class_">DialogWrapper</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String projectName;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//swing样式类，定义在4.3.2</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">FormTestSwing</span> <span class="variable">formTestSwing</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FormTestSwing</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FormTestDialog</span><span class="params">(<span class="meta">@Nullable</span> Project project)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="literal">true</span>);</span><br><span class="line">        setTitle(<span class="string">&quot;表单测试~~&quot;</span>); <span class="comment">//设置会话框标题</span></span><br><span class="line">        <span class="built_in">this</span>.projectName = project.getName(); <span class="comment">//获取到当前项目的名称</span></span><br><span class="line">        init(); <span class="comment">//触发一下init方法，否则swing样式将无法展示在会话框</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> JComponent <span class="title function_">createNorthPanel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> formTestSwing.initNorth(); <span class="comment">//返回位于会话框north位置的swing样式</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 特别说明：不需要展示SouthPanel要重写返回null，否则IDEA将展示默认的&quot;Cancel&quot;和&quot;OK&quot;按钮</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> JComponent <span class="title function_">createSouthPanel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> formTestSwing.initSouth();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> JComponent <span class="title function_">createCenterPanel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//定义表单的主题，放置到IDEA会话框的中央位置</span></span><br><span class="line">        <span class="keyword">return</span> formTestSwing.initCenter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-2：自定义swing样式"><a href="#4-3-2：自定义swing样式" class="headerlink" title="4.3.2：自定义swing样式"></a>4.3.2：自定义swing样式</h4><p>下面是放置swing样式的类：</p><figure class="highlight java"><figcaption><span>代码块6</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FormTestSwing</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="type">JPanel</span> <span class="variable">north</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="type">JPanel</span> <span class="variable">center</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="type">JPanel</span> <span class="variable">south</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//为了让位于底部的按钮可以拿到组件内容，这里把表单组件做成类属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">JLabel</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;输出：&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">JLabel</span> <span class="variable">r2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;NULL&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="type">JLabel</span> <span class="variable">name</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;姓名：&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">JTextField</span> <span class="variable">nameContent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTextField</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="type">JLabel</span> <span class="variable">age</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;年龄：&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">JTextField</span> <span class="variable">ageContent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTextField</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> JPanel <span class="title function_">initNorth</span><span class="params">()</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//定义表单的标题部分，放置到IDEA会话框的顶部位置</span></span><br><span class="line"> </span><br><span class="line">        <span class="type">JLabel</span> <span class="variable">title</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;表单标题&quot;</span>);</span><br><span class="line">        title.setFont(<span class="keyword">new</span> <span class="title class_">Font</span>(<span class="string">&quot;微软雅黑&quot;</span>, Font.PLAIN, <span class="number">26</span>)); <span class="comment">//字体样式</span></span><br><span class="line">        title.setHorizontalAlignment(SwingConstants.CENTER); <span class="comment">//水平居中</span></span><br><span class="line">        title.setVerticalAlignment(SwingConstants.CENTER); <span class="comment">//垂直居中</span></span><br><span class="line">        north.add(title);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> north;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> JPanel <span class="title function_">initCenter</span><span class="params">()</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//定义表单的主体部分，放置到IDEA会话框的中央位置</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//一个简单的3行2列的表格布局</span></span><br><span class="line">        center.setLayout(<span class="keyword">new</span> <span class="title class_">GridLayout</span>(<span class="number">3</span>, <span class="number">2</span>));</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//row1：按钮事件触发后将结果打印在这里</span></span><br><span class="line">        r1.setForeground(<span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">255</span>, <span class="number">47</span>, <span class="number">93</span>)); <span class="comment">//设置字体颜色</span></span><br><span class="line">        center.add(r1);</span><br><span class="line">        r2.setForeground(<span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">139</span>, <span class="number">181</span>, <span class="number">20</span>)); <span class="comment">//设置字体颜色</span></span><br><span class="line">        center.add(r2);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//row2：姓名+文本框</span></span><br><span class="line">        center.add(name);</span><br><span class="line">        center.add(nameContent);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//row3：年龄+文本框</span></span><br><span class="line">        center.add(age);</span><br><span class="line">        center.add(ageContent);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> center;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> JPanel <span class="title function_">initSouth</span><span class="params">()</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//定义表单的提交按钮，放置到IDEA会话框的底部位置</span></span><br><span class="line"> </span><br><span class="line">        <span class="type">JButton</span> <span class="variable">submit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;提交&quot;</span>);</span><br><span class="line">        submit.setHorizontalAlignment(SwingConstants.CENTER); <span class="comment">//水平居中</span></span><br><span class="line">        submit.setVerticalAlignment(SwingConstants.CENTER); <span class="comment">//垂直居中</span></span><br><span class="line">        south.add(submit);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> south;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在点击下<code>runIde</code>按钮，同样的，在调试IDE里点击“表单测试”，然后就会弹出如下表单框：</p><p><img src="http://myblog.sharemer.com/2019/12/13/20191213-1-7.png?imageView2/0/w/550" alt="图7"></p><p>🌿 除非有特殊情况需要自定义swing样式，否则建议不加任何swing样式，这样自定义的swing界面是会随着IDEA的主题改变而去自适应的，比如将图7中的调试IDE的主题设置成Darcula，自定义的表单也会自适应的变成黑色背景：</p><p><a href="http://myblog.sharemer.com/2019/12/13/20191213-1-8.png?imageView2/0/w/550"><img src="http://myblog.sharemer.com/2019/12/13/20191213-1-8.png?imageView2/0/w/550" alt="图8"></a></p><h4 id="4-3-3：事件绑定"><a href="#4-3-3：事件绑定" class="headerlink" title="4.3.3：事件绑定"></a>4.3.3：事件绑定</h4><p>定义好了样式，现在给“提交”按钮绑定一个事件，现在改写下<code>FormTestSwing.initSouth</code>方法：</p><figure class="highlight java"><figcaption><span>代码块7</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> JPanel <span class="title function_">initSouth</span><span class="params">()</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//定义表单的提交按钮，放置到IDEA会话框的底部位置</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">JButton</span> <span class="variable">submit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;提交&quot;</span>);</span><br><span class="line">    submit.setHorizontalAlignment(SwingConstants.CENTER); <span class="comment">//水平居中</span></span><br><span class="line">    submit.setVerticalAlignment(SwingConstants.CENTER); <span class="comment">//垂直居中</span></span><br><span class="line">    south.add(submit);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//按钮事件绑定</span></span><br><span class="line">    submit.addActionListener(e -&gt; &#123;</span><br><span class="line">        <span class="comment">//获取到name和age</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> nameContent.getText();</span><br><span class="line">        <span class="type">String</span> <span class="variable">age</span> <span class="operator">=</span> ageContent.getText();</span><br><span class="line">        <span class="comment">//刷新r2标签里的内容，替换为name和age</span></span><br><span class="line">        r2.setText(String.format(<span class="string">&quot;name:%s, age:%s&quot;</span>, name, age));</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> south;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在再来点击下“提交”按钮，就可以输出表单内容了：</p><p><img src="http://myblog.sharemer.com/2019/12/13/20191213-1-9.png?imageView2/0/w/550" alt="图9"></p><h3 id="4-4：插件绑定类：FormAction"><a href="#4-4：插件绑定类：FormAction" class="headerlink" title="4.4：插件绑定类：FormAction"></a>4.4：插件绑定类：FormAction</h3><p>之前讲过，这个类是插件的入口，结合上面定义好的表单Dialog，来看下它是怎么写的：</p><figure class="highlight java"><figcaption><span>代码块8</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FromAction</span> <span class="keyword">extends</span> <span class="title class_">AnAction</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(<span class="meta">@NotNull</span> AnActionEvent e)</span> &#123;</span><br><span class="line">        <span class="type">FormTestDialog</span> <span class="variable">formTestDialog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FormTestDialog</span>(e.getProject());</span><br><span class="line">        formTestDialog.setResizable(<span class="literal">true</span>); <span class="comment">//是否允许用户通过拖拽的方式扩大或缩小你的表单框，我这里定义为true，表示允许</span></span><br><span class="line">        formTestDialog.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、插件的打包-安装"><a href="#五、插件的打包-安装" class="headerlink" title="五、插件的打包&amp;安装"></a>五、插件的打包&amp;安装</h2><p>截止到第四步，都只是在调试IDE里查看效果，如果一个插件开发完成后，需要被实际的IDEA安装，这个时候就需要借助打包选项来打包你的插件，点击下面的选项构建插件：</p><p><img src="http://myblog.sharemer.com/2019/12/13/20191213-1-10.png?imageView2/0/w/550" alt="图10"></p><p>构建完成后，查看<code>build包</code>下的<code>distributions目录</code>，里面的<code>zip包</code>就可以直接安装进你的IDEA：</p><p><img src="http://myblog.sharemer.com/2019/12/13/20191213-1-11.png?imageView2/0/w/550" alt="图11"></p><p>然后选择IDEA的<code>Preferences</code>下的<code>plugins</code>选项，弹出如下框，按照图里的指示选择<code>zip包</code>安装即可：</p><p><img src="http://myblog.sharemer.com/2019/12/13/20191213-1-12.png?imageView2/0/w/1024" alt="图12"></p><p>然后安装完成，重启IDEA即可：</p><p><img src="http://myblog.sharemer.com/2019/12/13/20191213-1-13.png?imageView2/0/w/1024" alt="图13"></p><p>各个展示模块对应插件项目里配置的来源参考下图：</p><p><img src="http://myblog.sharemer.com/2019/12/13/20191213-1-14.png?imageView2/0/w/1024" alt="图14"></p><p>重启后出现了跟调试IDEA里一样的菜单栏，选中后运行成功：</p><p><img src="http://myblog.sharemer.com/2019/12/13/20191213-1-15.png?imageView2/0/w/550" alt="图15"></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>截止到这里，一个插件的<code>开发</code>、<code>调试</code>、<code>安装</code>就完成了，理论上通过这个简单的例子就可以实现一些实际的功能了，因为其完整展示了<code>数据输入</code>到<code>数据获取</code>整个过程。</p><p>因为工作当中需要写一个代码生成器，想要以一个IDEA插件的方式提供服务，所以在这里做个记录，防止以后再次用到时从零开始。。</p><p>要有一定的<code>swing</code>基础，我在开发代码生成器的时候，就是因为swing基础太差，布局花了非常多的时间。</p><blockquote><p>之后不会深入去研究插件的开发，如果后续工作中有用到插件开发的其他的功能点，会更新在这个分类里，如果想深入搞IDEA插件开发，建议看<a href="http://www.jetbrains.org/intellij/sdk/docs/welcome.html">IDEA的官方文档</a>，官方文档有点乱，有很多只是简单介绍几句甚至没有示例，好在他们有个问答社区，建议搜索时用google搜英文关键词，里面会有人提问，比如版本兼容的问题就是google出来的，社区里正好有一篇问答，链接在文章开头。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;🐜 版本信息：&lt;img src=&quot;https://img.shields.io/badge/JDK-v1.8%2B-orange&quot;/&gt;&lt;img src=&quot;https://img.shields.io/badge/IntelliJ%20IDEA-2019.03-blueviolet&quot;/&gt; &lt;/p&gt;
&lt;p&gt;🐝 插件项目基于&lt;code&gt;gradle&lt;/code&gt;构建。&lt;/p&gt;
&lt;p&gt;🦟 知识背景：&lt;code&gt;swing&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;🦇 参考文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.jetbrains.org/intellij/sdk/docs/tutorials/build_system/prerequisites.html&quot;&gt;http://www.jetbrains.org/intellij/sdk/docs/tutorials/build_system/prerequisites.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.jetbrains.org/intellij/sdk/docs/user_interface_components/tool_windows.html&quot;&gt;http://www.jetbrains.org/intellij/sdk/docs/user_interface_components/tool_windows.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.jetbrains.org/intellij/sdk/docs/user_interface_components/dialog_wrapper.html&quot;&gt;http://www.jetbrains.org/intellij/sdk/docs/user_interface_components/dialog_wrapper.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://intellij-support.jetbrains.com/hc/en-us/community/posts/360003338799-Build-compatible-plugin&quot;&gt;https://intellij-support.jetbrains.com/hc/en-us/community/posts/360003338799-Build-compatible-plugin&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="IDEA插件开发" scheme="http://example.com/categories/IDEA%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="IDEA" scheme="http://example.com/tags/IDEA/"/>
    
    <category term="IDEA插件开发" scheme="http://example.com/tags/IDEA%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Resilience4j熔断器-使用与源码解析</title>
    <link href="http://example.com/2019/12/10/Resilience4j%E7%86%94%E6%96%AD%E5%99%A8-%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://example.com/2019/12/10/Resilience4j%E7%86%94%E6%96%AD%E5%99%A8-%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2019-12-10T14:46:00.000Z</published>
    <updated>2023-12-04T03:21:51.325Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>🌏 环境：<img src="https://img.shields.io/badge/JDK-v11-orange"/><img src="https://img.shields.io/badge/IntelliJ%20IDEA-2019.03-blueviolet"/></p><p>🌾 依赖版本：<img src="https://img.shields.io/badge/Resilience4j-v0.13.2-green"/></p><p>🍃 知识依赖：<code>JUC</code>，<code>位图</code></p></blockquote><span id="more"></span><h2 id="一、什么是熔断"><a href="#一、什么是熔断" class="headerlink" title="一、什么是熔断"></a>一、什么是熔断</h2><p>在分布式系统中，各服务间的相互调用更加频繁，上下游调用中充满了可能性，一个服务可能会被很多其他服务依赖并调用，在这个过程中如果某个服务由于某种原因出错（业务出错、负载过高），可能会导致整个分布式调用链路失败：</p><p><img src="http://myblog.sharemer.com/2019/12/10/20191210-1-1.png?imageView2/0/w/700" alt="图1"></p><p>上面这个过程最终可能会导致全链路瘫痪（服务雪崩），此时需要一种可以解决上述问题的策略，此策略设计目标为：</p><ol><li>在发现有服务调用失败后，及时计算失败率</li><li>失败率达到某种阈值时，切断与该服务的所有交互，服务走切断后的自定义逻辑</li><li>切断并且不再调用该服务后主动监听被切断的服务是否已经恢复了处理能力，若恢复，则继续让其提供服务</li></ol><p>这个策略被放进<code>图1</code>中，就变成了下面这样：</p><p><img src="http://myblog.sharemer.com/2019/12/10/20191210-1-2.png?imageView2/0/w/1024" alt="图2"></p><p>这个过程中，C服务在自己出问题的情况下，并不会像<code>图1</code>里那样仍然有大量流量打进来，也不会影响到上游服务，这个结果让调用链看起来比<code>图1</code>更加的稳定，这个过程就叫<code>熔断</code>。</p><p>针对这个过程，可以看到在C不可用时，B走了熔断后的降级逻辑，这个逻辑可以自定义，如果C在整个调用链里属于那种必须要成功的服务，那么这里的逻辑就可以是直接抛错，如果C属于那种失败了也无所谓，不影响整个业务处理，那么降级逻辑里就可以不做处理，例如下面的场景：</p><p><img src="http://myblog.sharemer.com/2019/12/10/20191210-1-3.png?imageView2/0/w/900" alt="图3"></p><p>类似这种接口，降级策略很适合不做处理，返回空信息即可，这样最坏的情况就是页面少了某个板块的信息，可能会对用户造成不太好的体验，但是不影响其对外服务，被熔断的服务恢复后页面也会重新回归正常。熔断后的降级处理方式是件值得思考的事情，熔断和降级是相互独立的概念，熔断后必然会有降级操作（哪怕直接抛异常也是一种降级策略），这个降级操作是熔断这个动作导致的，所以很多时候会把熔断和降级放在一起说，其实降级还可以由其他动作触发，比如限流后抛出“<code>系统繁忙</code>”，这也是一种降级策略，只不过它是由限流触发的，再比如通过开关埋点在系统负载过高时主动关停一些次要服务来提升核心功能的响应速度，这也是一种降级策略，降级是最终产物，而产生它的方式有很多种。</p><h2 id="二、Resilience4j中的熔断器"><a href="#二、Resilience4j中的熔断器" class="headerlink" title="二、Resilience4j中的熔断器"></a>二、Resilience4j中的熔断器</h2><h3 id="2-1：Resilience4j是什么？"><a href="#2-1：Resilience4j是什么？" class="headerlink" title="2.1：Resilience4j是什么？"></a>2.1：Resilience4j是什么？</h3><p>它是一个轻量、易用、可组装的高可用框架，支持<code>熔断</code>、<code>高频控制</code>、<code>隔离</code>、<code>限流</code>、<code>限时</code>、<code>重试</code>等多种高可用机制。本篇文章只关注其<code>熔断部分</code>。</p><h3 id="2-2：如何使用？"><a href="#2-2：如何使用？" class="headerlink" title="2.2：如何使用？"></a>2.2：如何使用？</h3><p>通过第一部分的介绍，可以认为一个熔断器必须要具备统计单位请求内的错误率、全熔断、半熔断放量、恢复这几个流程，带着这个流程，下面来介绍下<code>Resilience4j</code>里熔断器的用法。</p><p>通过<code>图2</code>里服务B调用服务C的例子，现在利用java类来进行简单模拟下这个流程。</p><p>首先定义ServerC类，用于模拟服务C：</p><figure class="highlight java"><figcaption><span>代码块1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerC</span> &#123;</span><br><span class="line">    <span class="comment">//使用该方法模拟服务C获取C信息的方法，假设现在服务C的getCInfo方法里有个bug，当输入的id为0时报错，其他情况正常</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCInfo</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入0异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;id=&quot;</span> + id + <span class="string">&quot;的C信息&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再定义ServerB类，用于模拟服务B，这里给服务B调用服务C方法那里加上熔断器处理，注意这个类里的注释，会详细说明熔断器的主要配置项以及其使用方法：</p><figure class="highlight java"><figcaption><span>代码块2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerB</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CircuitBreakerRegistry breakerRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ServerC</span> <span class="variable">serverC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerC</span>(); <span class="comment">//让服务B持有一个服务C的引用，用来表示正常服务间调用里的一个连接引用</span></span><br><span class="line"></span><br><span class="line">    ServerB() &#123;</span><br><span class="line">        <span class="comment">//初始化breaker注册器，可以利用该对象生产各种breaker对象（注：凡是用同一个注册器生产出来的breaker，都会继承注册器的配置属性）</span></span><br><span class="line">        breakerRegistry = CircuitBreakerRegistry.of(CircuitBreakerConfig.custom() <span class="comment">//of方法里面放的就是breaker的配置属性对象</span></span><br><span class="line">                .enableAutomaticTransitionFromOpenToHalfOpen() <span class="comment">//开启从全开状态经过下面的waitDurationInOpenState时间后自动切换到半开状态</span></span><br><span class="line">                .failureRateThreshold(<span class="number">50</span>) <span class="comment">//熔断器闭合状态下的错误率阈值，50表示50%，如果错误率达到这个阈值，那么熔断器将进入全熔断状态</span></span><br><span class="line">                .ringBufferSizeInClosedState(<span class="number">100</span>) <span class="comment">//熔断器闭合状态下，以该值为单位请求数，计算错误率，跟上面错误率阈值综合理解，这个值表示至少有100个请求，且错误50个以上才会触发全熔断</span></span><br><span class="line">                .ringBufferSizeInHalfOpenState(<span class="number">10</span>) <span class="comment">//熔断器半熔断状态下，以该值为单位请求数，计算错误率，跟上面错误率阈值综合理解，这个值表示至少有10个请求，且错误5个以上会再次触发全熔断，相比闭合状态，半熔断状态下更容易再次进入全熔断状态</span></span><br><span class="line">                .waitDurationInOpenState(Duration.ofMillis(<span class="number">1000L</span>)) <span class="comment">//熔断器全熔断状态持续的时间，全熔断后经过该时间后进入半熔断状态</span></span><br><span class="line">                .build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务B通过服务C来获取到C的info信息，该方法就是用来干这个的，它会发起对服务C的调用</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCInfo</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="comment">//breaker对象是按照name划分全局单例的</span></span><br><span class="line">        <span class="type">CircuitBreaker</span> <span class="variable">breaker</span> <span class="operator">=</span> breakerRegistry.circuitBreaker(<span class="string">&quot;getCInfo&quot;</span>); <span class="comment">//这里给熔断器取个名，一般情况就是一个服务的path或方法名</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> breaker.executeCallable(() -&gt; serverC.getCInfo(id));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CircuitBreakerOpenException e) &#123; <span class="comment">//一旦抛出该异常说明已经进入全熔断状态</span></span><br><span class="line">            <span class="comment">//被熔断后的降级逻辑</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;服务C出错，触发服务B的降级逻辑&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//熔断关闭或者半熔断状态下，C抛出的错误会被catch到这里</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;调用服务C出错&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CircuitBreaker <span class="title function_">getBreaker</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> breakerRegistry.circuitBreaker(<span class="string">&quot;getCInfo&quot;</span>); <span class="comment">//为了方便做测试，这里返回对应的breaker对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述配置的熔断器解释如下：</p><p>在熔断器<code>闭合</code>的情况下（也即是正常情况下），以100个请求为<code>单位窗口</code>计算错误率，一旦错误率达到50%，立刻进入<code>全熔断</code>状态，该状态下服务B不会再发生对服务C的调用，直接走自己的降级逻辑，经过1000ms后恢复为<code>半熔断</code>状态，此时流量开始打进服务C，此时仍然会计算错误率，只是<code>半熔断</code>状态下，是以10个请求为单位窗口计算的错误率，这个可以保证在服务C没有恢复正常的情况下可以更快速的进入<code>全熔断</code>状态。</p><h3 id="2-3：测试-熔断器状态切换"><a href="#2-3：测试-熔断器状态切换" class="headerlink" title="2.3：测试-熔断器状态切换"></a>2.3：测试-熔断器状态切换</h3><p>然后开始编写测试方法，下面会通过测试方法来详细解析该熔断器的状态变迁：</p><figure class="highlight java"><figcaption><span>代码块3</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBreak</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//按照B服务里熔断器的配置，如果进行100次请求，有50次失败了，则对ServerC的调用进入全熔断状态</span></span><br><span class="line">        <span class="comment">//1000ms后恢复为半熔断状态，半熔断状态下进行10次请求，如果有5次依然失败，则再次进入全熔断状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">50</span>) &#123;</span><br><span class="line">                serverB.getCInfo(<span class="number">0</span>); <span class="comment">//前50次全部报错</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                serverB.getCInfo(<span class="number">1</span>); <span class="comment">//后50次全部成功</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//断言：此时熔断器为全熔断状态</span></span><br><span class="line">        System.out.println(serverB.getBreaker().getState().equals(CircuitBreaker.State.OPEN));</span><br><span class="line">        <span class="comment">//全熔断状态下并不会实际调用C，而是会走服务B的降级逻辑，即便我们输入的参数是对的，也一样会被降级</span></span><br><span class="line">        System.out.println(serverB.getCInfo(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">500L</span>);</span><br><span class="line">        <span class="comment">//断言：由于全熔断状态配置的持续时间时1000ms，所以500ms过去后，仍然是全熔断状态</span></span><br><span class="line">        System.out.println(serverB.getBreaker().getState().equals(CircuitBreaker.State.OPEN));</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">500L</span>);</span><br><span class="line">        <span class="comment">//断言：1000ms过后，熔断器处于半熔断状态</span></span><br><span class="line">        System.out.println(serverB.getBreaker().getState().equals(CircuitBreaker.State.HALF_OPEN));</span><br><span class="line">        <span class="comment">//半熔断状态下会尝试恢复，所以会实际调用C，分别输入正确和错误的参数进行测试</span></span><br><span class="line">        System.out.println(serverB.getCInfo(<span class="number">1</span>));</span><br><span class="line">        System.out.println(serverB.getCInfo(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//半熔断状态下，只需要请求10次，有5次出错即可再次进入全熔断状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">4</span>) &#123; <span class="comment">//因为上面传过一次0了，所以这里只需要4次便可以重新回到全开状态</span></span><br><span class="line">                serverB.getCInfo(<span class="number">0</span>); <span class="comment">//前5次全部报错</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                serverB.getCInfo(<span class="number">1</span>); <span class="comment">//后5次全部成功</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//断言：此时熔断器为全熔断状态</span></span><br><span class="line">        System.out.println(serverB.getBreaker().getState().equals(CircuitBreaker.State.OPEN));</span><br><span class="line">        <span class="comment">//同样的，全熔断状态下并不会实际调用C，而是会走服务B的降级逻辑</span></span><br><span class="line">        System.out.println(serverB.getCInfo(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//这时静待1000ms，再次进入半熔断状态，我们尝试恢复服务C的调用</span></span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这时我们让其10次请求里有6次成功</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">6</span>) &#123; <span class="comment">//前6次成功</span></span><br><span class="line">                serverB.getCInfo(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//后4次失败</span></span><br><span class="line">                serverB.getCInfo(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//由于10次请求里只失败了4次，达不到50%的全开阈值，所以此时会恢复</span></span><br><span class="line">        <span class="comment">//断言：此时熔断器为闭合状态</span></span><br><span class="line">        System.out.println(serverB.getBreaker().getState().equals(CircuitBreaker.State.CLOSED));</span><br><span class="line">        System.out.println(serverB.getCInfo(<span class="number">1</span>)); <span class="comment">//正常输出</span></span><br><span class="line">        System.out.println(serverB.getCInfo(<span class="number">0</span>)); <span class="comment">//走普通异常逻辑</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最终输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">服务C出错，触发服务B的降级逻辑</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">id=1的C信息</span><br><span class="line">调用服务C出错</span><br><span class="line">true</span><br><span class="line">服务C出错，触发服务B的降级逻辑</span><br><span class="line">true</span><br><span class="line">id=1的C信息</span><br><span class="line">调用服务C出错</span><br></pre></td></tr></table></figure><p>可以看到，单位请求内达到错误率阈值后熔断器会进入<code>全开状态</code>（<code>全熔断</code>），全开状态下走<code>降级逻辑</code>，此时不再会实际请求服务C，一段时间后（全开持续时间），进入<code>半开状态</code>（<code>半熔断</code>），半开时仍然正常打入服务C，只是由于单位请求量相比闭合时更小，若服务还没恢复，计算错误率会更快达到错误率阈值而迅速进入全开状态，以此类推。如果服务已经恢复，那么将会从半开状态进入闭合状态。</p><h3 id="2-4：测试-错误率统计方式"><a href="#2-4：测试-错误率统计方式" class="headerlink" title="2.4：测试-错误率统计方式"></a>2.4：测试-错误率统计方式</h3><p>通过上面的测试用例可以知道触发熔断器状态切换的时机，而且闭合状态下和半熔断状态下统计错误率的单位请求数不相同，那么这个请求数量又是怎么统计的呢？如果一个请求先错误了49次，然后在第101次请求的时候再错误1次是否可以成功触发熔断器全开？如果把这49次失败往后挪一位呢？现在再来按照设想测试下其错误率的统计方式：</p><figure class="highlight java"><figcaption><span>代码块4</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//首先闭合状态下单位请求仍然是100，现在让前49次全部失败</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">49</span>) &#123;</span><br><span class="line">                serverB.getCInfo(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                serverB.getCInfo(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//断言：虽然请求了100次，但是错误率并没有达到阈值（50%），所以这里仍然是闭合状态的</span></span><br><span class="line">        System.out.println(serverB.getBreaker().getState().equals(CircuitBreaker.State.CLOSED));</span><br><span class="line">        <span class="comment">//这里再让其失败一次</span></span><br><span class="line">        serverB.getCInfo(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//断言：这里应该还是闭合状态的，按照100次单位请求来看，第一次失败的那个请求会被这次失败这个请求顶替掉（这里不理解没关系，下面有图）</span></span><br><span class="line">        System.out.println(serverB.getBreaker().getState().equals(CircuitBreaker.State.CLOSED));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>然后我们让第一次失败的那次请求和其后面出错的请求后移一位：</p><figure class="highlight java"><figcaption><span>代码块5</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//首先闭合状态下单位请求仍然是100，仍然让其错误49次，但现在让第2~50次失败</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; i &lt; <span class="number">50</span>) &#123; <span class="comment">//第2~50次请求失败，总计失败49次</span></span><br><span class="line">                serverB.getCInfo(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                serverB.getCInfo(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//断言：跟上面例子一样，错误率并没有达到阈值，仍然是闭合状态</span></span><br><span class="line">        System.out.println(serverB.getBreaker().getState().equals(CircuitBreaker.State.CLOSED));</span><br><span class="line">        <span class="comment">//这里再让其失败一次</span></span><br><span class="line">        serverB.getCInfo(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//断言：这里应该是全开状态，按照100次单位请求来看，第一次成功的那个请求会被这次失败这个请求顶替掉，然后凑够50次失败请求（参考图4）</span></span><br><span class="line">        System.out.println(serverB.getBreaker().getState().equals(CircuitBreaker.State.OPEN));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>用图来描述下导致这两种情况发生的流程：</p><p><img src="http://myblog.sharemer.com/2019/12/10/20191210-1-4.png?imageView2/0/w/800" alt="图4"></p><p>所以<code>Resilience4j</code>在计算失败率的时候，是会发生滑动的，错误率是根据当前<code>滑动窗口</code>内的请求进行计算得出的，每次请求都会导致窗口移动，重新计算当前失败率，这个在源码解析里会说明这是怎样的一种结构，这里简单了解即可。</p><h2 id="三、源码解析"><a href="#三、源码解析" class="headerlink" title="三、源码解析"></a>三、源码解析</h2><h3 id="3-1：注册器入口"><a href="#3-1：注册器入口" class="headerlink" title="3.1：注册器入口"></a>3.1：注册器入口</h3><p>通过上面ServerB类里的使用，首先会通过<code>CircuitBreakerRegistry.of</code>生成一个注册器对象，然后利用注册器对象的<code>circuitBreaker</code>方法来生成一个实际的<code>breaker对象</code>，代码如下：</p><figure class="highlight java"><figcaption><span>代码块6</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CircuitBreakerRegistry</span> &#123;</span><br><span class="line">    <span class="comment">//静态方法返回了InMemoryCircuitBreakerRegistry的实例</span></span><br><span class="line">    <span class="keyword">static</span> CircuitBreakerRegistry <span class="title function_">of</span><span class="params">(CircuitBreakerConfig circuitBreakerConfig)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InMemoryCircuitBreakerRegistry</span>(circuitBreakerConfig);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>InMemoryCircuitBreakerRegistry</code>类代码如下（已简化处理，只展示流程相关代码）：</p><figure class="highlight java"><figcaption><span>代码块7</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">InMemoryCircuitBreakerRegistry</span> <span class="keyword">implements</span> <span class="title class_">CircuitBreakerRegistry</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//所有的breaker被存方在这个map里，breaker按照name不同而不同，每个breaker里都有自己的一份错误率统计数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, CircuitBreaker&gt; circuitBreakers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CircuitBreakerConfig defaultCircuitBreakerConfig; <span class="comment">//开始的配置对象，闭合状态单位请求量、半开状态单位请求量、错误率阈值等都会放在这里面</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InMemoryCircuitBreakerRegistry</span><span class="params">(CircuitBreakerConfig defaultCircuitBreakerConfig)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.defaultCircuitBreakerConfig = Objects.requireNonNull(defaultCircuitBreakerConfig, <span class="string">&quot;CircuitBreakerConfig must not be null&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.circuitBreakers = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CircuitBreaker <span class="title function_">circuitBreaker</span><span class="params">(String name)</span> &#123; <span class="comment">//添加一个breaker，若存在，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> circuitBreakers.computeIfAbsent(Objects.requireNonNull(name, <span class="string">&quot;Name must not be null&quot;</span>),</span><br><span class="line">                (k) -&gt; CircuitBreaker.of(name, defaultCircuitBreakerConfig));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个流程很简单，就是用一个map来维护所有breaker的，所以需要注意的是，命名breaker的时候，不要携带一些id之类的字段，很容易把map撑爆。</p><h3 id="3-2：Breaker实体-CircuitBreaker"><a href="#3-2：Breaker实体-CircuitBreaker" class="headerlink" title="3.2：Breaker实体-CircuitBreaker"></a>3.2：Breaker实体-CircuitBreaker</h3><p>拿到breaker实体后首先会通过其executeCallable方法执行需要被熔断的逻辑块，之前提到的所有的错误率统计、状态切换都发生在这个实体内。</p><figure class="highlight java"><figcaption><span>代码块8</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CircuitBreaker</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>  T <span class="title function_">executeCallable</span><span class="params">(Callable callable)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">return</span> decorateCallable(<span class="built_in">this</span>, callable).call(); <span class="comment">//包装原始的callable</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法包装，返回一个Callable对象，真正的业务逻辑callable在这里被执行</span></span><br><span class="line">    <span class="keyword">static</span>  Callable <span class="title function_">decorateCallable</span><span class="params">(CircuitBreaker circuitBreaker, Callable callable)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> () -&gt; &#123;</span><br><span class="line">            <span class="comment">//全熔断状态下，这里返回false，会抛出CircuitBreakerOpenException类型的异常，ServerB里判定是否走降级逻辑就是通过catch该异常来决定的</span></span><br><span class="line">            <span class="keyword">if</span>(!circuitBreaker.isCallPermitted()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CircuitBreakerOpenException</span>(String.format(<span class="string">&quot;CircuitBreaker &#x27;%s&#x27; is open&quot;</span>, circuitBreaker.getName()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//非全熔断状态触发下面的逻辑</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">T</span> <span class="variable">returnValue</span> <span class="operator">=</span> callable.call(); <span class="comment">//执行实际的业务逻辑</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">durationInNanos</span> <span class="operator">=</span> System.nanoTime() - start;</span><br><span class="line">                circuitBreaker.onSuccess(durationInNanos); <span class="comment">//非常关键的方法，用来累计执行成功的数量，计算错误率</span></span><br><span class="line">                <span class="keyword">return</span> returnValue;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable throwable) &#123; <span class="comment">//执行异常，调用onError累计出错数</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">durationInNanos</span> <span class="operator">=</span> System.nanoTime() - start;</span><br><span class="line">                circuitBreaker.onError(durationInNanos, throwable); <span class="comment">//非常关键的方法，用来累计执行失败的数量，计算错误率</span></span><br><span class="line">                <span class="keyword">throw</span> throwable;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CircuitBreaker</code>是一个接口，<code>CircuitBreakerStateMachine</code>是它的实现类，上述代码里比较关键的<code>isCallPermitted</code>、<code>onSuccess</code>、<code>onError</code>都是在这个<code>CircuitBreakerStateMachine</code>类里实现的。 <code>CircuitBreakerStateMachine</code>类比较复杂，牵扯到整个熔断器的状态切换、错误统计触发等，精简一下该类，只关注核心部分：</p><figure class="highlight java"><figcaption><span>代码块9</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CircuitBreakerStateMachine</span> <span class="keyword">implements</span> <span class="title class_">CircuitBreaker</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//熔断器的名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非常非常关键的一个属性，它是一个引用对象，CircuitBreakerState一共有以下子类：ClosedState、HalfOpenState、OpenState、DisabledState、ForcedOpenState</span></span><br><span class="line"><span class="comment">     * 熔断器每次发生状态切换，都会new出一个新的XXState对象，让下面的引用指向新的状态对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference stateReference;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始设置的熔断器配置，通过该对象可以拿到错误率阈值、全熔断持续状态等信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CircuitBreakerConfig circuitBreakerConfig;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//&amp;&amp;&amp; 事件处理器，这里不是重点，放到第四部分说，可以先忽略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CircuitBreakerEventProcessor eventProcessor;</span><br><span class="line"></span><br><span class="line">　　 <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CircuitBreakerStateMachine</span><span class="params">(String name, CircuitBreakerConfig circuitBreakerConfig)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.circuitBreakerConfig = circuitBreakerConfig;</span><br><span class="line">        <span class="built_in">this</span>.stateReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ClosedState</span>(<span class="built_in">this</span>)); <span class="comment">//初始化的时候，熔断器状态都是闭合状态，所以首先new一个ClosedState并让stateReference指向它</span></span><br><span class="line">        <span class="built_in">this</span>.eventProcessor = <span class="keyword">new</span> <span class="title class_">CircuitBreakerEventProcessor</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//切换到闭合状态，new ClosedState，可以看到每个XXState对象都持有当前CircuitBreakerStateMachine对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transitionToClosedState</span><span class="params">()</span> &#123;</span><br><span class="line">        stateTransition(CLOSED, currentState -&gt; <span class="keyword">new</span> <span class="title class_">ClosedState</span>(<span class="built_in">this</span>, currentState.getMetrics()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//切换到全熔断状态，new OpenState，</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transitionToOpenState</span><span class="params">()</span> &#123;</span><br><span class="line">        stateTransition(OPEN, currentState -&gt; <span class="keyword">new</span> <span class="title class_">OpenState</span>(<span class="built_in">this</span>, currentState.getMetrics()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//切换到半熔断状态，new HalfOpenState，</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transitionToHalfOpenState</span><span class="params">()</span> &#123;</span><br><span class="line">        stateTransition(HALF_OPEN, currentState -&gt; <span class="keyword">new</span> <span class="title class_">HalfOpenState</span>(<span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态切换方法（也即是XXState对象切换的地方）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">stateTransition</span><span class="params">(State newState, Function&lt;CircuitBreakerState, CircuitBreakerState&gt; newStateGenerator)</span> &#123;</span><br><span class="line">        <span class="comment">//引用指向新的XXState对象</span></span><br><span class="line">        <span class="type">CircuitBreakerState</span> <span class="variable">previousState</span> <span class="operator">=</span> stateReference.getAndUpdate(currentState -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (currentState.getState() == newState) &#123;</span><br><span class="line">                <span class="keyword">return</span> currentState;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> newStateGenerator.apply(currentState);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (previousState.getState() != newState) &#123;</span><br><span class="line">            <span class="comment">//&amp;&amp;&amp; 状态切换事件发布，本部分忽略，参考第四部分</span></span><br><span class="line">            publishStateTransitionEvent(StateTransition.transitionBetween(previousState.getState(), newState));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//代码块8里的isCallPermitted方法，这个方法决定了是否抛出&quot;已熔断&quot;异常</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCallPermitted</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//可以看到，这个解决取决于对应XXState里isCallPermitted方法的返回结果</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">callPermitted</span> <span class="operator">=</span> stateReference.get().isCallPermitted();</span><br><span class="line">        <span class="keyword">if</span> (!callPermitted) &#123;</span><br><span class="line">            <span class="comment">//&amp;&amp;&amp; 已熔断异常事件发布，本部分忽略，参考第四部分</span></span><br><span class="line">            publishCallNotPermittedEvent();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> callPermitted;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//代码块8里的onError方法，业务处理错误后会触发这个方法的调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(<span class="type">long</span> durationInNanos, Throwable throwable)</span> &#123;</span><br><span class="line">        <span class="comment">//这个判断是过滤需要忽略的异常处理，一般情况下没配置的话所有异常都会走下面实际的onError逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (circuitBreakerConfig.getRecordFailurePredicate().test(throwable)) &#123;</span><br><span class="line">            <span class="comment">//&amp;&amp;&amp; 处理错误事件发布，参考第四部分</span></span><br><span class="line">            publishCircuitErrorEvent(name, durationInNanos, throwable);</span><br><span class="line">            <span class="comment">//可以看到，实际上onError也是调用的XXState里的onError方法</span></span><br><span class="line">            stateReference.get().onError(throwable);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//&amp;&amp;&amp; 命中了可忽略的异常，忽略错误事件发布，本部分忽略，参考第四部分</span></span><br><span class="line">            publishCircuitIgnoredErrorEvent(name, durationInNanos, throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//代码块8里的onSuccess方法，业务处理正常会触发这个方法的调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(<span class="type">long</span> durationInNanos)</span> &#123;</span><br><span class="line">        <span class="comment">//&amp;&amp;&amp; 处理正常事件发布，本部分忽略，参考第四部分</span></span><br><span class="line">        publishSuccessEvent(durationInNanos);</span><br><span class="line">        <span class="comment">//同样的，onSuccess也是调用的XXState里的onError方法</span></span><br><span class="line">        stateReference.get().onSuccess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3：状态类"><a href="#3-3：状态类" class="headerlink" title="3.3：状态类"></a>3.3：状态类</h3><p>通过上面的代码可以知道<code>isCallPermitted</code>、<code>onSuccess</code>、<code>onError</code>这三个方法实际上都是调用对应<code>XXState</code>对象里的方法，下面来看下<code>ClosedState</code>、<code>OpenState</code>、<code>HalfOpenState</code>这三个状态对象里有关这三个方法的实现（因为上面的测试用例只涉及这三种状态的互转，实际上这三种状态也是最常用的，所以为了避免混乱，只展示这三种，所有状态类均继承自<code>CircuitBreakerState抽象类</code>）</p><h3 id="3-3-1：ClosedState"><a href="#3-3-1：ClosedState" class="headerlink" title="3.3.1：ClosedState"></a>3.3.1：ClosedState</h3><p>闭合状态时初始状态，中途只会由半熔断状态切换而来，正常情况下都是闭合状态，代码如下：</p><figure class="highlight java"><figcaption><span>代码块10</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ClosedState</span> <span class="keyword">extends</span> <span class="title class_">CircuitBreakerState</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来度量错误率的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CircuitBreakerMetrics circuitBreakerMetrics;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//就是配置里的failureRateThreshold属性，闭合状态时的错误率阈值（第二部分的测试用例中是50）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">float</span> failureRateThreshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//参考代码块9的CircuitBreakerStateMachine构造器中初始化stateReference时，初始态都是闭合状态，最初都是通过该方法完成初始化的</span></span><br><span class="line">    ClosedState(CircuitBreakerStateMachine stateMachine) &#123;</span><br><span class="line">        <span class="built_in">this</span>(stateMachine, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个构造器是状态转换时触发的，参考代码块9里的transitionToClosedState方法</span></span><br><span class="line">    ClosedState(CircuitBreakerStateMachine stateMachine, CircuitBreakerMetrics circuitBreakerMetrics) &#123;</span><br><span class="line">        <span class="built_in">super</span>(stateMachine);</span><br><span class="line">        <span class="comment">//拿到熔断器的配置</span></span><br><span class="line">        <span class="type">CircuitBreakerConfig</span> <span class="variable">circuitBreakerConfig</span> <span class="operator">=</span> stateMachine.getCircuitBreakerConfig();</span><br><span class="line">        <span class="keyword">if</span>(circuitBreakerMetrics == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//初始化metrics对象，传进去的是闭合状态时计算错误率的单位请求数（第二部分的测试用例中是100）</span></span><br><span class="line">            <span class="built_in">this</span>.circuitBreakerMetrics = <span class="keyword">new</span> <span class="title class_">CircuitBreakerMetrics</span>(</span><br><span class="line">                    circuitBreakerConfig.getRingBufferSizeInClosedState());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//中途进行状态转换，调用的都是这里的逻辑，利用circuitBreakerMetrics的copy方法，重新赋值给circuitBreakerMetrics属性，暂时忽略，参考第3.4部分</span></span><br><span class="line">            <span class="built_in">this</span>.circuitBreakerMetrics = circuitBreakerMetrics.copy(circuitBreakerConfig.getRingBufferSizeInClosedState());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//赋值错误率阈值</span></span><br><span class="line">        <span class="built_in">this</span>.failureRateThreshold = stateMachine.getCircuitBreakerConfig().getFailureRateThreshold();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCallPermitted</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//闭合状态下返回true，不会触发降级逻辑（ps：只有在全熔断状态下才会返回true）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">        <span class="comment">// 闭合状态下，onerror需要记录错误率，注：circuitBreakerMetrics的onError方法会记录一笔错误的记录，并把当前的错误率返回</span></span><br><span class="line">        checkFailureRate(circuitBreakerMetrics.onError());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 闭合状态下，onerror需要记录成功数，注：circuitBreakerMetrics的onSuccess方法会记录一笔正确的记录，并把当前的错误率返回</span></span><br><span class="line">        checkFailureRate(circuitBreakerMetrics.onSuccess());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据当前的错误率，决定是否切到半熔断状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkFailureRate</span><span class="params">(<span class="type">float</span> currentFailureRate)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentFailureRate &gt;= failureRateThreshold) &#123; <span class="comment">//这里判断当前错误率是否超过阈值</span></span><br><span class="line">            <span class="comment">// 利用CircuitBreakerStateMachine的transitionToOpenState方法，将状态对象转换成OpenState</span></span><br><span class="line">            stateMachine.transitionToOpenState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-2：OpenState"><a href="#3-3-2：OpenState" class="headerlink" title="3.3.2：OpenState"></a>3.3.2：OpenState</h3><p>一般全熔断状态会从闭合或者半熔断状态里切换而来，它的代码如下：</p><figure class="highlight java"><figcaption><span>代码块11</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">OpenState</span> <span class="keyword">extends</span> <span class="title class_">CircuitBreakerState</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据全熔断持续时间推出的进入半熔断状态的时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Instant retryAfterWaitDuration;</span><br><span class="line">    <span class="comment">//同样是用来度量错误率的对象，该对象就是上一个State对象里的Metrics对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CircuitBreakerMetrics circuitBreakerMetrics;</span><br><span class="line"></span><br><span class="line">    OpenState(CircuitBreakerStateMachine stateMachine, CircuitBreakerMetrics circuitBreakerMetrics) &#123;</span><br><span class="line">        <span class="built_in">super</span>(stateMachine);</span><br><span class="line">        <span class="comment">//就是配置里的waitDurationInOpenState属性，全熔断持续时间（第二部分的测试用例中是100ms）</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Duration</span> <span class="variable">waitDurationInOpenState</span> <span class="operator">=</span> stateMachine.getCircuitBreakerConfig().getWaitDurationInOpenState();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当前时间加上持续时间，就是切换至半熔断状态的时机</span></span><br><span class="line">        <span class="built_in">this</span>.retryAfterWaitDuration = Instant.now().plus(waitDurationInOpenState);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//直接用之前的circuitBreakerMetrics对象</span></span><br><span class="line">        <span class="built_in">this</span>.circuitBreakerMetrics = circuitBreakerMetrics;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果配置了自动切换半熔断状态的开关为true，则会发起一个延时任务，用来主动切换状态</span></span><br><span class="line">        <span class="keyword">if</span> (stateMachine.getCircuitBreakerConfig().isAutomaticTransitionFromOpenToHalfOpenEnabled()) &#123;</span><br><span class="line">            AutoTransitioner.scheduleAutoTransition(stateMachine::transitionToHalfOpenState, waitDurationInOpenState);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCallPermitted</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果全熔断状态持续时间超出目标范围，则认为现在可以切换为半熔断状态，然后返回true</span></span><br><span class="line">        <span class="keyword">if</span> (Instant.now().isAfter(retryAfterWaitDuration)) &#123;</span><br><span class="line">            stateMachine.transitionToHalfOpenState();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        circuitBreakerMetrics.onCallNotPermitted(); <span class="comment">//记录一次NotPermitted（简单的累加）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//全熔断状态，直接返回false，表示已被熔断，让调用方抛出CircuitBreakerOpenException异常</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">        <span class="comment">//理论上处于全熔断状态，isCallPermitted返回false，onError不会被触发（参考代码块8里的decorateCallable方法）</span></span><br><span class="line">        <span class="comment">//但是存在一种特殊的情况，假设有俩线程，线程1执行的时候还是闭合状态，isCallPermitted返回true，这时线程2里触发了熔断阈值</span></span><br><span class="line">        <span class="comment">//线程2把stateReference的指向置为OpenState，这时线程1继续往下执行，触发的onError其实是OpenState里的onError（也即是本例中的这个方法）</span></span><br><span class="line">        <span class="comment">//全熔断状态下即便是上面这种临界情况发生，这次失败也会被统计上去</span></span><br><span class="line">        circuitBreakerMetrics.onError();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Should never be called when isCallPermitted returns false.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//跟onError一样，有概率会访问到</span></span><br><span class="line">        circuitBreakerMetrics.onSuccess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-3：HalfOpenState"><a href="#3-3-3：HalfOpenState" class="headerlink" title="3.3.3：HalfOpenState"></a>3.3.3：HalfOpenState</h3><p>半熔断状态一定是由全熔断切换出来的，来看下它的代码：</p><figure class="highlight java"><figcaption><span>代码块12</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HalfOpenState</span> <span class="keyword">extends</span> <span class="title class_">CircuitBreakerState</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同样是用来度量错误率的对象</span></span><br><span class="line">    <span class="keyword">private</span> CircuitBreakerMetrics circuitBreakerMetrics;</span><br><span class="line">    <span class="comment">//同样是配置里的failureRateThreshold属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">float</span> failureRateThreshold;</span><br><span class="line"></span><br><span class="line">    HalfOpenState(CircuitBreakerStateMachine stateMachine) &#123;</span><br><span class="line">        <span class="built_in">super</span>(stateMachine);</span><br><span class="line">        <span class="type">CircuitBreakerConfig</span> <span class="variable">circuitBreakerConfig</span> <span class="operator">=</span> stateMachine.getCircuitBreakerConfig();</span><br><span class="line">        <span class="comment">//初始化度量对象，相比闭合状态，这里传入的是ringBufferSizeInHalfOpenState（第二部分的测试用例中是10）</span></span><br><span class="line">        <span class="built_in">this</span>.circuitBreakerMetrics = <span class="keyword">new</span> <span class="title class_">CircuitBreakerMetrics</span>(</span><br><span class="line">                circuitBreakerConfig.getRingBufferSizeInHalfOpenState());</span><br><span class="line">        <span class="comment">//闭合状态和半开状态共用同一个错误率阈值（第二部分的测试用例中是50）</span></span><br><span class="line">        <span class="built_in">this</span>.failureRateThreshold = stateMachine.getCircuitBreakerConfig().getFailureRateThreshold();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCallPermitted</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//跟闭合状态一样，返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">        <span class="comment">// 跟闭合状态一样，要记录和判断当前的错误率（来决定是恢复闭合状态还是进入全熔断状态）</span></span><br><span class="line">        checkFailureRate(circuitBreakerMetrics.onError());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 同上</span></span><br><span class="line">        checkFailureRate(circuitBreakerMetrics.onSuccess());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过该方法，判断错误率，决定是否恢复为闭合状态或者再次进入全熔断状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkFailureRate</span><span class="params">(<span class="type">float</span> currentFailureRate)</span> &#123;</span><br><span class="line">        <span class="comment">//Metrics返回-1表示请求量表示还没有达到单位请求量（ringBufferSizeInHalfOpenState）</span></span><br><span class="line">        <span class="comment">//下面的逻辑可以看出，在半熔断状态下，经过ringBufferSizeInHalfOpenState次请求后根据错误率判断，就可以决定出下一步切换到哪个状态了</span></span><br><span class="line">        <span class="keyword">if</span> (currentFailureRate != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//当前错误率如果再次超出阈值，则再次进入全熔断状态</span></span><br><span class="line">            <span class="keyword">if</span> (currentFailureRate &gt;= failureRateThreshold) &#123;</span><br><span class="line">                stateMachine.transitionToOpenState();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//否则恢复为闭合状态</span></span><br><span class="line">                stateMachine.transitionToClosedState();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-4：状态间的切换关系"><a href="#3-3-4：状态间的切换关系" class="headerlink" title="3.3.4：状态间的切换关系"></a>3.3.4：状态间的切换关系</h3><p>上面三种状态的切换关系如下：</p><p><img src="http://myblog.sharemer.com/2019/12/10/20191210-1-5.png?imageView2/0/w/750" alt="图5"></p><p>在这些状态中，最初为熔断闭合状态，ServerB的所有请求正常访问ServerC，ServerC报错，错误率累计达到50%后触发熔断全开状态，此时Server对ServerC发出的请求将走ServerB的降级逻辑，不再实际访问ServerC的方法，这个状态会持续<code>waitDurationInOpenState</code>这么久（测试用例中是1000ms），然后进入熔断半开状态，此时跟闭合状态一样，ServerB的所有请求仍会正常访问ServerC，不同的是半开状态下只需要满足<code>ringBufferSizeInHalfOpenState</code>次调用（测试用例中是10次)，就可以直接判断错误率是否达到阈值，这点可以在<code>代码块12</code>里的<code>checkFailureRate</code>方法体现，<code>图5</code>中可以看到，如果未达到错误阈值表示ServerC已恢复，则可以关闭熔断，否则再次进入全熔断状态。</p><h3 id="3-3-5：度量对象（CircuitBreakerMetrics）的传递"><a href="#3-3-5：度量对象（CircuitBreakerMetrics）的传递" class="headerlink" title="3.3.5：度量对象（CircuitBreakerMetrics）的传递"></a>3.3.5：度量对象（CircuitBreakerMetrics）的传递</h3><p>这个对象在<code>3.4</code>中会详细说明，目前只需要知道该类用于做错误统计用，错误率计算的核心，核心方法为<code>onError</code>和<code>onSuccess</code>，这俩方法用于错误&#x2F;正确请求的触发点，用于触发<code>CircuitBreakerMetrics</code>对象对错误率的统计。</p><p>通过<code>代码块10、11、12</code>可以看到<code>CircuitBreakerMetrics</code>对象的流向，首先初始化的时候是调用<code>ClosedState</code>第一个构造器触发第二个构造器，第二个构造器会new一个<code>CircuitBreakerMetrics</code>，传过去的size为<code>ringBufferSizeInClosedState</code>，然后由<code>ClosedState</code>切换至<code>OpenState</code>状态时，其<code>CircuitBreakerMetrics</code>会被传递给<code>OpenState</code>对象，根据<code>代码块11</code>可以知道，<code>OpenState</code>利用该对象统计熔断期间被熔断的次数，然后<code>OpenState</code>切换至<code>HalfOpenState</code>时，<code>HalfOpenState</code>没有接受<code>CircuitBreakerMetrics</code>对象的构造器，不管由谁切换到<code>半开状态</code>，<code>CircuitBreakerMetrics</code>对象都是全新的，由<code>代码块12</code>可知，初始化<code>CircuitBreakerMetrics</code>对象时传过去的size就是<code>ringBufferSizeInHalfOpenState</code>。</p><p><code>CircuitBreakerMetrics</code>对象的传递以及传递后在<code>State对象</code>里所做的操作：</p><p><img src="http://myblog.sharemer.com/2019/12/10/20191210-1-6.png?imageView2/0/w/1024" alt="图6"></p><p><code>图6</code>根据<code>代码块10、11、12</code>画出，简单体现了<code>Metrics对象</code>的生成以及流向，以及这个对象在各<code>State对象</code>里所做的主要操作。通过<code>图6</code>可以看出实际产生新的Metrics对象的地方为<code>闭合态</code>和<code>半开态</code>，因为这俩地方是需要做错误统计的，需要全新的Metric对象，全开态下仅接收前一状态的Metrics对象，在命中熔断后对其内部<code>numberOfNotPermittedCalls</code>（不是很懂这个属性，简单的累加，连用到的地方都没，可能仅仅是做个熔断数统计让业务方获取的吧，做监控可以用），在半开态再次进入闭合态时，其Metrics仍然被传递给了闭合态，由<code>代码块10</code>可知，如果传了<code>Metrics对象</code>，<code>闭合态</code>在产生新的<code>Metrics对象</code>时，会通过<code>copy</code>方法来产生，这个方法在<code>3.4</code>会详细说明，简单来说就是把前一个状态（只可能是<code>半开态</code>）的Metrics里的请求计数同步到它自己的Metrics里，这样做有一个好处，就是新的闭合态不用重新累计错误率了，以单元测试所配的参数试想一下，如果在半开态下，进行了10次请求，发生了4次错误，此时会切回闭合态，闭合态<code>copy</code>了这10次请求的数据，那么只需要再经过90次请求和46次错误便可以再次进入全熔断状态（其实就是保证了状态的<code>平滑切换</code>，不丢失之前已经统计了的数据）。</p><h3 id="3-4：错误统计"><a href="#3-4：错误统计" class="headerlink" title="3.4：错误统计"></a>3.4：错误统计</h3><h3 id="3-4-1：CircuitBreakerMetrics"><a href="#3-4-1：CircuitBreakerMetrics" class="headerlink" title="3.4.1：CircuitBreakerMetrics"></a>3.4.1：CircuitBreakerMetrics</h3><p>通过<code>3.3</code>的了解，闭合和半开时的请求状态计数都是通过<code>CircuitBreakerMetrics</code>对象来完成的，现在来看下这个类里都干了些什么：</p><figure class="highlight java"><figcaption><span>代码块13</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CircuitBreakerMetrics</span> <span class="keyword">implements</span> <span class="title class_">CircuitBreaker</span>.Metrics &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过3.3的代码块可知，该值就是闭合或者半开状态下设置的ringBufferSizeInClosedState和ringBufferSizeInHalfOpenState</span></span><br><span class="line">    <span class="comment">//表示一次请求窗口的大小，测试用例中就是闭合时的100以及半开时的10，通过图4和下方的getFailureRate方法可以知道，</span></span><br><span class="line">    <span class="comment">//至少要累计完成一个请求窗口的请求量后才会实际计算错误率</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> ringBufferSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实际用来记录一个请求窗口的请求统计数据的结构，本节不深究，详细参考3.4.2</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RingBitSet ringBitSet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//全开状态下累计被熔断的请求个数，触发点参考图6以及代码块11</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LongAdder numberOfNotPermittedCalls;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器1，参考图6，在最开始的闭合状态以及后续的半开状态下初始化Metrics对象用的就是该构造器</span></span><br><span class="line">    CircuitBreakerMetrics(<span class="type">int</span> ringBufferSize) &#123;</span><br><span class="line">        <span class="built_in">this</span>(ringBufferSize, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//参考图6，由半开转到闭合态的时候，是通过该方法进行初始化的</span></span><br><span class="line">    <span class="keyword">public</span> CircuitBreakerMetrics <span class="title function_">copy</span><span class="params">(<span class="type">int</span> targetRingBufferSize)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CircuitBreakerMetrics</span>(targetRingBufferSize, <span class="built_in">this</span>.ringBitSet); <span class="comment">//这里会把当前Metrics对象里的ringBitSet传递下去</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器2</span></span><br><span class="line">    CircuitBreakerMetrics(<span class="type">int</span> ringBufferSize, RingBitSet sourceSet) &#123;</span><br><span class="line">        <span class="built_in">this</span>.ringBufferSize = ringBufferSize;</span><br><span class="line">        <span class="keyword">if</span>(sourceSet != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//通过copy初始化会走这里（每次的半开态转闭合态），将原来Metrics对象里的ringBitSet传递下去（用来初始化新的请求窗口）</span></span><br><span class="line">            <span class="built_in">this</span>.ringBitSet = <span class="keyword">new</span> <span class="title class_">RingBitSet</span>(<span class="built_in">this</span>.ringBufferSize, sourceSet);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//非copy新建Metrics对象（每次的半开态和最初的闭合态）</span></span><br><span class="line">            <span class="built_in">this</span>.ringBitSet = <span class="keyword">new</span> <span class="title class_">RingBitSet</span>(<span class="built_in">this</span>.ringBufferSize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.numberOfNotPermittedCalls = <span class="keyword">new</span> <span class="title class_">LongAdder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//onError和onSuccess的触发点参考3.3里的State类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当请求发生错误时触发该方法，该方法用于记一次失败，然后把当前错误率返回</span></span><br><span class="line">    <span class="type">float</span> <span class="title function_">onError</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">currentNumberOfFailedCalls</span> <span class="operator">=</span> ringBitSet.setNextBit(<span class="literal">true</span>); <span class="comment">//通过ringBitSet的setNextBit置为true，算作一笔失败的记录</span></span><br><span class="line">        <span class="keyword">return</span> getFailureRate(currentNumberOfFailedCalls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当请求正常时触发该方法，该方法用于记一次成功，然后把当前错误率返回</span></span><br><span class="line">    <span class="type">float</span> <span class="title function_">onSuccess</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">currentNumberOfFailedCalls</span> <span class="operator">=</span> ringBitSet.setNextBit(<span class="literal">false</span>); <span class="comment">//通过ringBitSet的setNextBit置为false，算作一笔成功的记录</span></span><br><span class="line">        <span class="keyword">return</span> getFailureRate(currentNumberOfFailedCalls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//全开状态下累计被熔断的请求个数</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onCallNotPermitted</span><span class="params">()</span> &#123;</span><br><span class="line">        numberOfNotPermittedCalls.increment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过getFailureRate计算错误率并返回</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getFailureRate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getFailureRate(getNumberOfFailedCalls());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下方注释中的窗口大小就是ringBufferSize属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法通过ringBitSet对象返回当前请求窗口内发生请求的总次数，如果达到了ringBufferSize次，则这个值就恒等于ringBufferSize</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumberOfBufferedCalls</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.ringBitSet.length();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法通过ringBitSet对象返回当前请求窗口内发生错误的次数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumberOfFailedCalls</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.ringBitSet.cardinality();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//错误率计算方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> <span class="title function_">getFailureRate</span><span class="params">(<span class="type">int</span> numberOfFailedCalls)</span> &#123;</span><br><span class="line">        <span class="comment">//若请求还没有完成一个请求窗口，则返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (getNumberOfBufferedCalls() &lt; ringBufferSize) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//完成了一次请求窗口，才会真正计算错误率</span></span><br><span class="line">        <span class="keyword">return</span> numberOfFailedCalls * <span class="number">100.0f</span> / ringBufferSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码可以知道最终统计错误数的是在<code>RingBitSet</code>结构中，下面来仔细了解下这个类~</p><h3 id="3-4-2：位图-BitSetMod"><a href="#3-4-2：位图-BitSetMod" class="headerlink" title="3.4.2：位图&amp;BitSetMod"></a>3.4.2：位图&amp;BitSetMod</h3><p>了解<code>RingBitSet</code>之前，先来了解一种数据结构-<code>位图</code>，如果已经了解过位图，那么可以直接去看RingBitSet。</p><p>RingBitSet持有一个<code>BitSetMod</code>对象，BitSetMod基于位图实现，位图是怎样的一种结构呢？先看下<code>图7</code>，然后再去解析它的源码实现。</p><p><img src="http://myblog.sharemer.com/2019/12/10/20191210-1-7.png?imageView2/0/w/700" alt="图7"></p><p>通过上图可知，位图就是利用数组内每个元素的bit位存入一个标记，标记只有存在或者不存在（对应二进制的0和1），这样就可以做到用一个long型的数字就可以产生出64个标记信息，非常适合数据量庞大而判断状态少的应用场景，比如判断一个词语是否是屏蔽词，首先屏蔽词状态只有两种：命中or不命中，但是屏蔽词可能是个非常庞大的集合，如果一个个拿来比较，效率完全保证不了，那么就可以利用这个数据结构来解决这类问题，可以首先把所有的屏蔽词放到一个位图结构里，如果有相同的词语，只需要简单的两部运算就可以拿到是否命中结果，构建这个位图结构的过程如下：</p><p><img src="http://myblog.sharemer.com/2019/12/10/20191210-1-8.png?imageView2/0/w/1024" alt="图8"></p><p>通过上图，屏蔽词位图结构就构建好了，如果有个词语需要判定是否命中屏蔽词，只需要让这个词语通过上面的哈希算法计算出哈希值，然后找到对应的数组下标，通过位运算算出其所在位置，将该位置的值取出，如果是0，则认为没有命中，1则认为命中。</p><p>以上就是位图结构，通过上面的例子，可以认为同一个值一定命中位图里的同一个位置，那么抽象成熔断器的错误率，错误状态只有0和1，1表示错误，0表示正确，给每次请求编号，当成是图8中的哈希值，相同编号的请求一定会落到同一个位置，现在不理解没关系，这个要结合RingBitSet一起看，目前只需要理解位图特性即可。</p><p>Resilience4j里通过BitSetMod简单实现了一个位图结构，来看下代码（注：代码里有大量位运算，过程说明都写在了注释里）：</p><figure class="highlight java"><figcaption><span>代码块14</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下方为源码注释↓↓</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> io.github.resilience4j.circuitbreaker.internal.BitSetMod&#125; is simplified version of &#123;<span class="doctag">@link</span> java.util.BitSet&#125;.</span></span><br><span class="line"><span class="comment"> * It has no dynamic allocation, expanding logic, boundary checks</span></span><br><span class="line"><span class="comment"> * and it&#x27;s set method returns previous bit state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BitSetMod</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.此类是一种怎样的数据结构？</span></span><br><span class="line"><span class="comment">     * 根据原有注释，可知这是一个简易版的BitSet，即位图结构，可以通过图7更为直观的了解下该结构</span></span><br><span class="line"><span class="comment">     * 由图7可知，位图分为x，y轴，y轴就是本类的long型的数组（words），其中内部每一个元素都包括64个bit，因此bit位横向扩展就是x轴（x轴大小恒等于64）</span></span><br><span class="line"><span class="comment">     * 如果要标记一个数字是否存在于图中，只需要先找到所属的y轴位置（即对应的words下标），然后再计算出它应该出现的x轴long型数字中哪个bit位，</span></span><br><span class="line"><span class="comment">     * 然后判断该bit位是否已被标记为true，若是，则返回已存在，否则返回不存在。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 2.位运算</span></span><br><span class="line"><span class="comment">     * 简单了解下本类中出现的位运算，任意两个数的乘法或除法都可以用&lt;&lt;（左移）或&gt;&gt;（右移）来表示</span></span><br><span class="line"><span class="comment">     * 例：</span></span><br><span class="line"><span class="comment">     * a * b == a &lt;&lt; log2(b)</span></span><br><span class="line"><span class="comment">     * a / b == a &gt;&gt; log2(b)</span></span><br><span class="line"><span class="comment">     * 本例中的ADDRESS_BITS_PER_WORD属性，其实就是long型位数以2为底的对数，即log2(64) = 6</span></span><br><span class="line"><span class="comment">     * 那么接下来代码中针对ADDRESS_BITS_PER_WORD的位运算就可以简单理解为乘以/除以64了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//long类型bit位的对数，即log2(64)＝6，利用该值可以进行简单的乘除法的位运算</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ADDRESS_BITS_PER_WORD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最终可以存放的总位数，计算方式：words.length * 64（每个long型有64位，利用数组长度乘以位数，就计算出了位图的总位数）</span></span><br><span class="line">    <span class="comment">//用位运算表示为：words.length &lt;&lt; 6（右移表示乘法，右移6位表示乘以2^6，即words.length * 64）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//位图数组，long型，64个bit位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span>[] words;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器，传入位图的容量大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BitSetMod</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> capacity)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算数组大小（即y轴大小），根据上面对位图的基本解释，可以知道，y轴是一个long型数组，</span></span><br><span class="line">        <span class="comment">//而每次一个数字进来，会首先找到y轴所属的位置，那么这个数组得多大才合适呢？我们知道x轴固定为64个，</span></span><br><span class="line">        <span class="comment">//也就是说正常情况下，任意数字进来后都会被分到某个y轴对应的long型数字里的某一位，那么y轴大小就很好推算了，</span></span><br><span class="line">        <span class="comment">//利用给出的容量大小（这个表示任意数最大时为多大），除以64进行平均分组，这样不管传的任意数为多大，始终都可以找到对应的[x,y]，且不会越界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">countOfWordsRequired</span> <span class="operator">=</span> wordIndex(capacity - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//上面说过，size就是位图里所有位数，即x * y，也就是words.length * 64，用位运算表示为：words.length &lt;&lt; 6</span></span><br><span class="line">        size = countOfWordsRequired &lt;&lt; ADDRESS_BITS_PER_WORD;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最终((capacity - 1)/64)+1就是y轴数组大小，初始化数组即可</span></span><br><span class="line">        words = <span class="keyword">new</span> <span class="title class_">long</span>[countOfWordsRequired];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//到这里，一个位图对象就被我们创建好了，数组（y轴）是它实际的实体，x轴是数组里long型数字的二进制位（64）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">wordIndex</span><span class="params">(<span class="type">int</span> bitIndex)</span> &#123;</span><br><span class="line">        <span class="comment">//下面这个位运算等同于：bitIndex/64</span></span><br><span class="line">        <span class="keyword">return</span> bitIndex &gt;&gt; ADDRESS_BITS_PER_WORD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始设置数字信息，bitIndex为目标放置位置，value为值（0或1）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> bitIndex, <span class="type">boolean</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">// 利用位置数字除以64，推算出它对应的y轴下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">wordIndex</span> <span class="operator">=</span> wordIndex(bitIndex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注：下面的代码都是位运算，开始前先来了解一下如何定位某个数字的二进制第n位上的数字是0还是1</span></span><br><span class="line">        <span class="comment">// 将1右移bitIndex位，可以得到一个类似1000000的二进制数字，利用这个数字跟原来的数字本身做位与运算，可以推算出原数第bitIndex位上的数字是1还是0</span></span><br><span class="line">        <span class="comment">// 举个例子，我想知道下面这个二进制数字中第5位的数字是0还是1（跟十进制一样，位数是从右往左数，位数最高的在最左边，下标从0开始算起）</span></span><br><span class="line">        <span class="comment">// 假设该二进制数为λ，设：λ=101010101</span></span><br><span class="line">        <span class="comment">// 现在将1右移5位得到bitMask，它用二进制表示为：100000，1的位置正好位于第5位（从右往左，下标从0算起）</span></span><br><span class="line">        <span class="comment">// 利用λ跟bitMask进行位与运算：</span></span><br><span class="line">        <span class="comment">//    101010101（λ）</span></span><br><span class="line">        <span class="comment">//    &amp;</span></span><br><span class="line">        <span class="comment">//    000100000（bitMask）</span></span><br><span class="line">        <span class="comment">//    ------------------</span></span><br><span class="line">        <span class="comment">//    000000000（位与结果）</span></span><br><span class="line">        <span class="comment">// 由这个过程可以发现，λ的第5位如果是0，位与后的结果也是0，如果是1，那么位与运算后的结果肯定是不等于0的，通过这种方式，我们就可以利用1右移的方式，</span></span><br><span class="line">        <span class="comment">// 知道λ的第n位是0还是1</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 通过上面的例子，可以知道，任意数与1右移后的数字（bitMask）进行位与运算的结果要么不等于0，要么等于0，因为1右移n位后生成的二进制数在其n位上一定为1，</span></span><br><span class="line">        <span class="comment">// 其余位置一定为0，0&amp;0、0&amp;1均为0，所以最后的结果要么是000000000，要么还等于1右移后的那个数：000010000，这取决于原始数字里第n位上是否是1，</span></span><br><span class="line">        <span class="comment">// 如果是1，则相与后的结果值一定不等于0，反之则等于0</span></span><br><span class="line"><span class="comment">// 结合上面所有的描述，这里可以再思考一个问题，为什么位不会相互覆盖？比如我传了一个bitIndex为100，long型1&lt;&lt;100等价于1&lt;&lt;36（以64为模轮回），那么当我传100的时候岂不是会覆盖掉传36时那次做标记？</span></span><br><span class="line"><span class="comment">// 这个问题答案是否定的，因为在最初的时候就已经把bitIndex按照64为单位进行相除计算出下标了，也就是说bitIndex等于100那次，跟bitIndex等于36那次，不在一个下标里（不在一个次元）</span></span><br><span class="line">        <span class="comment">// 根据这些规则，下面的代码就好理解了。</span></span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">bitMask</span> <span class="operator">=</span> <span class="number">1L</span> &lt;&lt; bitIndex;</span><br><span class="line">        <span class="type">int</span> <span class="variable">previous</span> <span class="operator">=</span> (words[wordIndex] &amp; bitMask) != <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">//把该位置上当前的值（0或1）赋值给previous（也就是最后返回出去的结果）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value) &#123;</span><br><span class="line">            <span class="comment">// 重新赋值，注意，这里是原值跟bitMask进行或运算，意味着目标位的值会直接变成1，其余位置的值均不变</span></span><br><span class="line">            words[wordIndex] = words[wordIndex] | bitMask;</span><br><span class="line">            <span class="comment">// 结合例子，参考下面这个过程更容易理解</span></span><br><span class="line">            <span class="comment">//    101010101</span></span><br><span class="line">            <span class="comment">//    |</span></span><br><span class="line">            <span class="comment">//    000100000</span></span><br><span class="line">            <span class="comment">//    ---------</span></span><br><span class="line">            <span class="comment">//    101110101</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// value等于false的时候，bitMask取反后跟原值进行与运算，跟上面相反，这是把目标位变成0</span></span><br><span class="line">            words[wordIndex] = words[wordIndex] &amp; ~bitMask;</span><br><span class="line">            <span class="comment">// 结合例子，参考下面这个过程更容易理解</span></span><br><span class="line">            <span class="comment">//    101010101</span></span><br><span class="line">            <span class="comment">//    &amp;</span></span><br><span class="line">            <span class="comment">//    111011111（bitMask的反码）</span></span><br><span class="line">            <span class="comment">//    ---------</span></span><br><span class="line">            <span class="comment">//    101010101</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> previous;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//返回位图里的总位数</span></span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> bitIndex)</span> &#123;</span><br><span class="line">        <span class="comment">// 注：如果对下方的右移等操作还不是很了解，请先看set方法里的注释</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先还是利用位置数字除以64，推算出它对应的y轴下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">wordIndex</span> <span class="operator">=</span> wordIndex(bitIndex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果set里的位运算理解了，下面这个很容易理解，这个流程跟set方法里获取previous一样</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">bitMask</span> <span class="operator">=</span> <span class="number">1L</span> &lt;&lt; bitIndex;</span><br><span class="line">        <span class="keyword">return</span> (words[wordIndex] &amp; bitMask) != <span class="number">0</span>; <span class="comment">//大于0时返回true，表示目标位是1，否则返回false，目标位是0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是Resilience4j针对位图的简单实现，它负责存储单位请求内的<code>错误/成功</code>标志。</p><h3 id="3-4-3：RingBitSet"><a href="#3-4-3：RingBitSet" class="headerlink" title="3.4.3：RingBitSet"></a>3.4.3：RingBitSet</h3><p>之前说过，最终请求被放到了一个环形结构里才对，沿着环执行一周就是一次单位请求，回看下图4，其实第101次请求就是顶替掉第一次请求的结果罢了，现在把图4中以100为请求窗口弯曲成一个环，假如第一次请求是失败的，第101次请求是成功的（绿色背景表示成功的请求，红色背景表示失败的请求）：</p><p><img src="http://myblog.sharemer.com/2019/12/10/20191210-1-9.png?imageView2/0/w/650" alt="图9"></p><p>如何利用位图结构记录每次请求的<code>错误/成功</code>标记然后再实现<code>图9</code>里的<code>环形结构</code>呢？Resilience4j通过<code>RingBitSet</code>来实现，来看下它的代码：</p><figure class="highlight java"><figcaption><span>代码块15</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RingBitSet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单位请求数，根据State类初始化RingSet时给的size值，可以确定该值就是各种ringBufferSize</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">//真正存放错误率的位图结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BitSetMod bitSet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在完成一个请求窗口后，该值为false，表示请求已满一次请求窗口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> notFull;</span><br><span class="line">    <span class="comment">//给请求编号，方便位图计算位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求数量，最终等于size</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> length;</span><br><span class="line">    <span class="comment">//当前请求窗口内的错误数，就是利用这个数实时计算错误率的（参考CircuitBreakerMetrics.getNumberOfFailedCalls）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">cardinality</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    RingBitSet(<span class="type">int</span> bitSetSize) &#123;</span><br><span class="line">        notFull = <span class="literal">true</span>;</span><br><span class="line">        size = bitSetSize;</span><br><span class="line">        bitSet = <span class="keyword">new</span> <span class="title class_">BitSetMod</span>(bitSetSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//携带RingBitSet参数的构造器会把sourceSet里的统计数据赋值给新的RingBitSet（继承其请求数、错误率等）</span></span><br><span class="line">    <span class="comment">//调用该构造器的触发点在CircuitBreakerMetrics.copy中触发，通过图6可知，每次由半开状态转到闭合状态时，都会调用copy方法，</span></span><br><span class="line">    <span class="comment">//让新的闭合态继承上次半开态的请求量和错误率，这是合理的，比较平滑无损的过度到闭合态。</span></span><br><span class="line">    RingBitSet(<span class="type">int</span> bitSetSize, RingBitSet sourceSet) &#123;</span><br><span class="line">        <span class="built_in">this</span>(bitSetSize);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">targetLength</span> <span class="operator">=</span> Integer.min(bitSetSize, sourceSet.length);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sourceIndex</span> <span class="operator">=</span> sourceSet.index;</span><br><span class="line">        <span class="type">int</span> <span class="variable">forwardIndex</span> <span class="operator">=</span> sourceSet.size - sourceIndex;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; targetLength; i++) &#123;</span><br><span class="line">            <span class="built_in">this</span>.setNextBit(sourceSet.bitSet.get(sourceIndex));</span><br><span class="line">            <span class="comment">// looping sourceIndex backwards without conditional statements</span></span><br><span class="line">            forwardIndex = (forwardIndex + <span class="number">1</span>) % sourceSet.size;</span><br><span class="line">            sourceIndex = (sourceSet.size - forwardIndex) % sourceSet.size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非常非常重要的方法，它的触发点在CircuitBreakerMetrics的onError和onSuccess，主要用于记录错误率</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">setNextBit</span><span class="params">(<span class="type">boolean</span> value)</span> &#123;</span><br><span class="line">        increaseLength();</span><br><span class="line">        <span class="comment">//环形结构依靠这里来实现，index永远在0~size间循环累加，类似：[0,1,2,3...99,0,1,2,3...99]</span></span><br><span class="line">        index = (index + <span class="number">1</span>) % size;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//利用位图，将本次的错误/成功标记设置到对应index的位置上，</span></span><br><span class="line">　　　　 <span class="comment">//并且拿到当前index对应上次请求窗口中同样为index位置的请求结果previous，至于为啥要拿到这个值，参考下方的逻辑</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">previous</span> <span class="operator">=</span> bitSet.set(index, value);</span><br><span class="line">        <span class="comment">//本次请求结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> value ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//下面这一步就是刷新错误数的，计算方式为：减去同位置上个请求窗口的请求结果，然后加上这次的请求结果</span></span><br><span class="line">        <span class="comment">//举个例子，假设单位请求窗口是100，第一个请求窗口的第一次请求错误，index=0的位置被标为1，第101次请求，也就是第二个请求窗口的第一次请求，</span></span><br><span class="line">        <span class="comment">//意味着index仍然为0，那么第101次请求的结果就会覆盖掉第1次请求的那个结果，以此来完成窗口滚动（参考图9）</span></span><br><span class="line">        cardinality = cardinality - previous + current;</span><br><span class="line">        <span class="keyword">return</span> cardinality;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回当前请求窗口内的错误总量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cardinality</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cardinality;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bitSet.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            result.append(bitSet.get(i) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//累加当前请求窗口内的请求量，当完成一次单位请求窗口时，length恒等于单位请求窗口大小（size）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">increaseLength</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (notFull) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextLength</span> <span class="operator">=</span> length + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nextLength &lt; size) &#123;</span><br><span class="line">                length = nextLength;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                length = size;</span><br><span class="line">                notFull = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>Resilience4j通过<code>CircuitBreakerStateMachine</code>来独立出一个熔断器，其内部持有一个<code>CircuitBreakerState</code>对象的引用，在错误率达到某个阈值时，会发生状态切换，CircuitBreakerState的引用会指向新的状态对象。每个状态对象持有一个<code>CircuitBreakerMetrics</code>对象，用于做实时统计和错误率监听使用，CircuitBreakerMetrics对象通过<code>RingBitSet</code>来完成单位请求窗口的错误率统计，这个统计是实时的，每次请求都会触发一次错误率的判断。RingBitSet通过Resilience4j自己实现的一个轻量级的<code>位图</code>结构<code>BitSetMod</code>来标记请求<code>错误/成功</code>，顺便说下，这里通过RingBitSet来保证<code>环形结构</code>，而位图只负责存储请求结果，那么既然这样，我用普通的数组或者其他的可以通过下标获取数值的集合结构也可以实现啊，为什么一定要用位图呢？猜测是位图既可以保证跟数组一样高效，都是<code>O(1)</code>的复杂度，又可以节省存储空间，比如我的单位请求是1w次，如果是数组结构，虽然效率跟位图一样高，但是数组却需要存1w个0或1这样的数组，即便用byte类型的数组，每个数组元素都浪费了7个bit位。其他集合就更不用说了，效率无法保证，其次他们浪费的内存比单纯数组要高，所以，类似这种只有true或false的数据的存储，位图再适合不过了。</p><p>感觉有些地方说的不太清晰，待后续改进描述方式。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;🌏 环境：&lt;img src=&quot;https://img.shields.io/badge/JDK-v11-orange&quot;/&gt;&lt;img src=&quot;https://img.shields.io/badge/IntelliJ%20IDEA-2019.03-blueviolet&quot;/&gt;&lt;/p&gt;
&lt;p&gt;🌾 依赖版本：&lt;img src=&quot;https://img.shields.io/badge/Resilience4j-v0.13.2-green&quot;/&gt;&lt;/p&gt;
&lt;p&gt;🍃 知识依赖：&lt;code&gt;JUC&lt;/code&gt;，&lt;code&gt;位图&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="服务治理" scheme="http://example.com/categories/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    
    
    <category term="服务治理" scheme="http://example.com/tags/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    
    <category term="Resilience4j" scheme="http://example.com/tags/Resilience4j/"/>
    
    <category term="熔断&amp;限流" scheme="http://example.com/tags/%E7%86%94%E6%96%AD-%E9%99%90%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>工作中有关分布式缓存的使用和需要注意的问题梳理</title>
    <link href="http://example.com/2019/10/24/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E6%9C%89%E5%85%B3%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98%E6%A2%B3%E7%90%86/"/>
    <id>http://example.com/2019/10/24/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E6%9C%89%E5%85%B3%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98%E6%A2%B3%E7%90%86/</id>
    <published>2019-10-23T17:05:00.000Z</published>
    <updated>2023-12-04T03:29:09.232Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>目前工作中用到的分布式缓存技术有<code>redis</code>和<code>memcached</code>两种，缓存的目的是为了在高并发系统中有效降低DB的压力，但是在使用的时候可能会因为缓存结构设计不当造成一些问题，这里会把可能遇到的坑整理出来，方便日后查找。</p></blockquote><span id="more"></span><h2 id="一、常用的两种缓存技术的服务端特点"><a href="#一、常用的两种缓存技术的服务端特点" class="headerlink" title="一、常用的两种缓存技术的服务端特点"></a>一、常用的两种缓存技术的服务端特点</h2><h3 id="1-1：Memcache服务端"><a href="#1-1：Memcache服务端" class="headerlink" title="1.1：Memcache服务端"></a>1.1：Memcache服务端</h3><p><code>Memcache</code>（下面简称<code>mc</code>）服务端是没有集群概念的，所有的存储分发全部交由mc client去做，我这里使用的是<code>xmemcached</code>，这个客户端支持多种哈希策略，默认使用key与实例数取模来进行简单的数据分片，这种分片方式会导致一个问题，那就是新增或者减少节点后会在一瞬间导致大量key失效，最终导致缓存雪崩的发生，给DB带来巨大压力，所以我们的mc client启用了<code>xmemcached</code>的<code>一致性哈希算法</code>来进行数据分片：</p><figure class="highlight java"><figcaption><span>代码块1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">XMemcachedClientBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMemcachedClientBuilder</span>(AddrUtil.getAddresses(servers));</span><br><span class="line">builder.setOpTimeout(opTimeout);</span><br><span class="line">builder.setConnectTimeout(connectTimeout);</span><br><span class="line">builder.setTranscoder(transcoder);</span><br><span class="line">builder.setConnectionPoolSize(connectPoolSize);</span><br><span class="line">builder.setKeyProvider(keyProvider);</span><br><span class="line">builder.setSessionLocator(<span class="keyword">new</span> <span class="title class_">KetamaMemcachedSessionLocator</span>()); <span class="comment">//启用ketama一致性哈希算法进行数据分片</span></span><br></pre></td></tr></table></figure><p>根据<code>一致性哈希算法</code>的特性，在新增或减少mc的节点只会影响较少一部分的数据。但这种模式下也意味着分配不均匀，新增的节点可能并不能及时达到均摊数据的效果，不过mc采用了<code>虚拟节点</code>的方式来优化原始<code>一致性哈希算法</code>（由<a href="https://www.jianshu.com/p/f78a31725582">ketama</a>算法控制实现），实现了新增物理节点后也可以均摊数据的能力。</p><p>最后，mc服务端是<code>多线程</code>处理模式，mc一个value最大只能存储<code>1M</code>的数据，所有的k-v过期后不会自动移除，而是下次访问时与当前时间做对比，过期时间小于当前时间则删除，如果一个k-v产生后就没有再次访问了，那么数据将会一直存在在内存中，直到触发<code>LRU</code>。</p><h3 id="1-2：Redis服务端"><a href="#1-2：Redis服务端" class="headerlink" title="1.2：Redis服务端"></a>1.2：Redis服务端</h3><p>redis服务端有集群模式，key的路由交由redis服务端做处理，除此之外redis有主从配置以达到服务高可用。</p><p>redis服务端是<code>单线程</code>处理模式，这意味着如果有一个指令导致redis处理过慢，会阻塞其他指令的响应，所以redis禁止在生产环境使用重量级操作（例如keys，再例如缓存较大的值导致传输过慢）</p><p>redis服务端并没有采用一致性哈希来做数据分片，而是采用了<code>哈希槽</code>的概念来做数据分片，一个redis cluster整体拥有<code>16384</code>个哈希槽（<code>slot</code>），这些哈希槽按照编号区间的不同，分布在不同节点上，然后一个key进来，通过内部哈希算法（<code>CRC16(key)</code>）计算出槽位置，然后将数据存放进对应的哈希槽对应的空间，redis在新增或者减少节点时，其实就是对这些哈希槽进行重新分配，以新增节点为例，新增节点意味着原先节点上的哈希槽区间会相对缩小，被减去的那些哈希槽里的数据将会顺延至下一个对应节点，这个过程由redis服务端协调完成，过程如下：</p><p><img src="http://myblog.sharemer.com/2019/10/24/20191024-1-1.png?imageView2/0/w/1024" alt="图1"></p><p>迁移过程是以槽为单位，将槽内的key按批次进行迁移的（<code>migrate</code>）。</p><p>有关哈希槽和一致性哈希算法的对比参考：<a href="https://www.jianshu.com/p/4163916a2a8a">一致性哈希和哈希槽对比</a></p><h2 id="二、选型问题"><a href="#二、选型问题" class="headerlink" title="二、选型问题"></a>二、选型问题</h2><h3 id="2-1：缓存结构化选型"><a href="#2-1：缓存结构化选型" class="headerlink" title="2.1：缓存结构化选型"></a>2.1：缓存结构化选型</h3><p>mc提供简单的k-v存储，value最大可以存储<code>1M</code>的数据，多线程处理模式，不会出现因为某次处理慢而导致其他请求排队等待的情况，适合存储数据的文本信息。</p><p>redis提供丰富的数据结构，服务端是单线程处理模式，虽然处理速度很快，但是如果有一次查询出现瓶颈，那么后续的操作将被阻塞，所以相比k-v这种可能因为数据过大而导致网络交互产生瓶颈的结构来说，它更适合处理一些数据结构的<code>查询</code>、<code>排序</code>、<code>分页</code>等操作，这些操作往往复杂度不高，且耗时极短，因此不太可能会阻塞redis的处理。</p><p>使用这两种缓存服务来构建我们的缓存数据，目前提倡所有数据按照标志性字段（例如<code>id</code>）组成自己的信息缓存存储，这个一般由mc的k-v结构来完成存储。而redis提供了很多好用的数据结构，一般构建结构化的缓存数据都使用redis的数据结构来保存数据的基本结构，然后组装数据时根据redis里缓存的标志性字段去mc里查询具体数据，例如一个排行榜接口的获取：</p><p><img src="http://myblog.sharemer.com/2019/10/24/20191024-1-2.png?imageView2/0/w/500" alt="图2"></p><p>上图redis提供排行榜的结构存储，排行榜里存储的是id和score，通过redis可以获取到结构内所有信息的id，然后利用获得的id可以从mc中查出详细信息，redis在这个过程负责分页、排序，mc则负责存储详细信息。</p><p>上面是比较合适的缓存做法，<strong>建议每条数据都有一个自己的基本缓存数据，这样便于管理，而不是把一个接口的巨大结构完全缓存到mc或者redis里，这样划分太粗，日积月累下来每个接口或者巨大方法都有一个缓存，key会越来越多，越来越杂。</strong></p><h3 id="2-2：Redis的数据结构"><a href="#2-2：Redis的数据结构" class="headerlink" title="2.2：Redis的数据结构"></a>2.2：Redis的数据结构</h3><p>常用操作和时间复杂度：<a href="https://blog.csdn.net/zzm848166546/article/details/80360665">Redis基础、常用类型介绍、时间复杂度</a></p><p>特殊结构BitMap：<a href="https://gitlib.com/page/redis-bitmap.html">Redis中BitMap使用</a></p><p>BitMap适用于实现用户签到、在线状态等功能，空间占有量极低，除此之外还可以用它来实现一个BloomFilter。</p><p>在使用redis时，对于时间复杂度<code>非O(1)</code>的操作都需要推算现有的数据量是否可能导致redis<code>阻塞</code>（分页操作一般不会命中这个问题，因为单页个数有限，出问题较多的一般都是全量输出大列表导致的，生产环境应避免全量操作）。</p><h3 id="2-3：Redis构造大索引回源问题"><a href="#2-3：Redis构造大索引回源问题" class="headerlink" title="2.3：Redis构造大索引回源问题"></a>2.3：Redis构造大索引回源问题</h3><p>Redis如果做缓存使用，始终会有过期时间存在，如果到了过期时间，使用redis构建的索引将会消失，这个时候回源，如果存在大批量的数据需要构建redis索引，就会存在回源方法过慢的问题，这里以某个评论系统为例：</p><p>评论系统采用有序集合作为评论列表的索引，存储的是评论id，用于排序的score值则按照排序维度拆分，比如发布时间、点赞数等，这也意味着一个资源下的评论列表根据排序维度不同存在着多个redis索引列表，而具体评论内容存mc，正常情况下结构如下：</p><p><img src="http://myblog.sharemer.com/2019/10/24/20191024-1-3.png?imageView2/0/w/800" alt="图3"></p><p>上面是正常触发一个资源的评论区，每次触发读缓存，都会顺带延长一次缓存的过期时间，这样可以保证较热的内容不会轻易过期，但是如果一个评论区时间过长没人访问过，redis索引就会过期，如果一个评论区有数万条评论数据，长时间没人访问，突然有人过去考古，那么在回源构建redis索引时会很缓慢，如果没有控制措施，还会造成下面<code>缓存穿透</code>的问题，从而导致这种重量级操作反复被多个线程执行，对DB造成巨大压力。</p><p>对于上面这种回源构建索引缓慢的问题，处理方式可以是下面这样：</p><p><img src="http://myblog.sharemer.com/2019/10/24/20191024-1-4.png?imageView2/0/w/800" alt="图4"></p><p>相比直接执行回源方法，这种通过消息队列构造redis索引的方法更加适合，首先仅构建单页或者前面几页的索引数据，然后通过队列通知job（这里可以理解为消费者）进行完整索引构造，当然，这只适合对一致性要求不高的场景。</p><h2 id="三、一致性问题"><a href="#三、一致性问题" class="headerlink" title="三、一致性问题"></a>三、一致性问题</h2><p>一般情况下缓存内的数据要和数据库源数据保持一致性，这就涉及到更新DB后主动失效缓存策略（通俗叫法：清缓存），大部分会经过如下过程：</p><p><img src="http://myblog.sharemer.com/2019/10/24/20191024-1-5.png?imageView2/0/w/700" alt="图5"></p><p>假如现在有两个服务，服务A和服务B，现在假设服务A会触发某个数据的写操作，而服务B则是只读程序，数据被缓存在一个Cache服务内，现在假如服务A更新了一次数据库，那么结合上图得出以下流程：</p><ol><li>服务A触发更新数据库的操作</li><li>更新完成后删除数据对应的缓存key</li><li>只读服务（服务B）读取缓存时发现缓存miss</li><li>服务B读取数据库源信息</li><li>写入缓存并返回对应信息</li></ol><p>这个过程乍一看是没什么问题的，但是往往多线程运转的程序会导致意想不到的结果，现在来想象下服务A和服务B被多个线程运行着，这个时候重复上述过程，就会存在一致性问题：</p><h3 id="3-1：并发读写导致的一致性问题"><a href="#3-1：并发读写导致的一致性问题" class="headerlink" title="3.1：并发读写导致的一致性问题"></a>3.1：并发读写导致的一致性问题</h3><p><img src="http://myblog.sharemer.com/2019/10/24/20191024-1-6.png?imageView2/0/w/900" alt="图6"></p><ol><li>运行着服务A的<code>线程1</code>首先修改数据，然后删除缓存</li><li>运行着服务B的<code>线程3</code>读缓存时发现缓存miss，开始读取DB中的源数据，需要注意的是这次读出来的数据是<code>线程1</code>修改后的那份</li><li>这个时候运行着服务A的<code>线程2</code>上线，开始修改数据库，同样的，删除缓存，需要注意的是，这次删除的其实是一个空缓存，没有意义，因为本来<code>线程3</code>那边还没有回源完成</li><li>运行着服务B的<code>线程3</code>将读到的由<code>线程1</code>写的那份数据回写进Cache</li></ol><p>上述过程完成后，最终结果就是DB里保存的最终数据是<code>线程2</code>写进去的那份，而Cache经过<code>线程3</code>的回源后保存的却是<code>线程1</code>写的那份数据，不一致问题出现。</p><h3 id="3-2：主从同步延时导致的一致性问题"><a href="#3-2：主从同步延时导致的一致性问题" class="headerlink" title="3.2：主从同步延时导致的一致性问题"></a>3.2：主从同步延时导致的一致性问题</h3><p>这种情况要稍微修改下程序的流程图，多出一个从库：</p><p><img src="http://myblog.sharemer.com/2019/10/24/20191024-1-7.png?imageView2/0/w/700" alt="图7"></p><p>现在读操作走从库，这个时候如果在主库写操作删除缓存后，由于主从同步有可能稍微慢于回源流程触发，回源时读取从库仍然会读到老数据。</p><h3 id="3-3：缓存污染导致的一致性问题"><a href="#3-3：缓存污染导致的一致性问题" class="headerlink" title="3.3：缓存污染导致的一致性问题"></a>3.3：缓存污染导致的一致性问题</h3><p>每次做新需求时更新了原有的缓存结构，或去除几个属性，或新增几个属性，假如新需求是给某个缓存<code>对象O</code>新增一个<code>属性B</code>，如果新逻辑已经在<code>预发</code>或者处于<code>灰度</code>中，就会出现生产环境回源后的缓存数据<code>没有B属性</code>的情况，而预发和灰度时，新逻辑需要使用<code>B属性</code>，就会导致<code>生产&amp;预发缓存污染</code>。过程大致如下：</p><p><img src="http://myblog.sharemer.com/2019/10/24/20191024-1-8.png?imageView2/0/w/1024" alt="图8"></p><h2 id="四、应对缓存一致性问题"><a href="#四、应对缓存一致性问题" class="headerlink" title="四、应对缓存一致性问题"></a>四、应对缓存一致性问题</h2><h3 id="4-1：binlog-消息队列-消费者del-cache"><a href="#4-1：binlog-消息队列-消费者del-cache" class="headerlink" title="4.1：binlog+消息队列+消费者del cache"></a>4.1：binlog+消息队列+消费者del cache</h3><p><img src="http://myblog.sharemer.com/2019/10/24/20191024-1-9.png?imageView2/0/w/700" alt="图9"></p><p>上图是现在常用的清缓存策略，每次表发生变动，通过mysql产生的<code>binlog</code>去给消息队列发送变动消息，这里监听DB变动的服务由<code>canal</code>提供，canal可以简单理解成一个实现了mysql通信协议的从库，通过mysql主从配置完成binlog同步，且它只接收binlog，通过这种机制，就可以很自然的监听数据库表数据变动了，可以保证每次数据库发生的变动，都会被顺序发往消费者去清除对应的缓存key。</p><h3 id="4-2：从库binlog-消息队列-消费者del-cache"><a href="#4-2：从库binlog-消息队列-消费者del-cache" class="headerlink" title="4.2：从库binlog+消息队列+消费者del cache"></a>4.2：从库binlog+消息队列+消费者del cache</h3><p>上面的过程能保证写库时清缓存的顺序问题，看似并没有什么问题，但是生产环境往往存在主从分离的情况，也就是说上面的图中如果回源时读的是从库（参考<code>问题3.2</code>），那上面的过程仍然是存在一致性问题的：</p><p><img src="http://myblog.sharemer.com/2019/10/24/20191024-1-10.png?imageView2/0/w/700" alt="图10"></p><p>从库延迟导致的脏读问题，如何解决这类问题呢？只需要将canal监听的数据库设置成从库即可，保证在canal推送过来消息时，所有的从库和主库完全一致，不过这只针对<code>一主一从</code>的情况，如果<code>一主多从</code>，且回源读取的从库有多个，那么上述也是存在一定的风险的（一主多从需要订阅每个从节点的binlog，找出最后发过来的那个节点，然后清缓存，确保所有的从节点全部和主节点一致）。</p><p>不过，正常情况下，从库binlog的同步速度都要比canal发消息快，因为canal要接收binlog，然后组装数据变动实体（这一步是有额外开销的），然后通过消息队列推送给各消费者（这一步也是有开销的），所以即便是订阅的master库的表变更，出问题的概率也极小。</p><blockquote><p>ps：目前笔者公司内数据库都是一主一从，canal监听的都是从库的变动。</p></blockquote><h3 id="4-3：更新后key升级"><a href="#4-3：更新后key升级" class="headerlink" title="4.3：更新后key升级"></a>4.3：更新后key升级</h3><p>针对上面的一致性<code>问题3.3</code>（缓存污染），修改某个缓存结构可能导致在预发或者灰度中状态时和实际生产环境的缓存相互污染，这个时候建议每次更新结构时都进行一次key升级（比如在原有的key名称基础上加上_v2的后缀）。</p><center>⚡⚡⚡那么binlog是否真的准确无误呢？⚡⚡⚡</center><p><img src="http://myblog.sharemer.com/2019/10/24/20191024-1-11.png?imageView2/0/w/800" alt="图11"></p><p>并不是，比如上面的情况：</p><ol><li>首先线程1走到服务A，写DB，发binlog删除缓存</li><li>然后线程3运行的服务B这时cache miss，然后读取DB回源（这时读到的数据是线程1写入的那份数据）</li><li>此时线程2再次触发服务A写DB，同样发送binlog删除缓存</li><li>最后线程3把读到的数据写入cache，最终导致DB里存储的是线程2写入的数据，但是cache里存储的却是线程1写入的数据，不一致达成</li></ol><p>这种情况比较难以触发，因为极少会出现线程3那里写cache的动作会晚于第二次binlog发送的，除非在回源时做了别的带有阻塞性质的操作，所以根据现有的策略，针对<code>问题3.1</code>，没有特别完美的解决方案，只能尽可能保证一致性，但由于实际生产环境就像<code>问题3.1</code>里那样，处于多线程并发读写的环境，即便有binlog做最终的保证，也不能保证最后回源方法写缓存那里的顺序性。除非回源全部交由binlog消费者来做，不过这本就不太现实，这样等于说服务B没有回源方法了。</p><p>针对这个问题，出现概率最大的就是那种写并发概率很大的情况，这个时候伴随而来的还有<code>命中率（参考五）</code>问题。</p><h3 id="4-4：一致性问题解决总结"><a href="#4-4：一致性问题解决总结" class="headerlink" title="4.4：一致性问题解决总结"></a>4.4：一致性问题解决总结</h3><p>没有很好的避免<code>问题3.1</code>的方法，从库binlog订阅+清缓存可以保证在清缓存后服务回源读到的一定是最新数据，但是这并不妨碍<code>图11</code>中的问题发生，只是概率极小，在高并发写+读回源时没有什么办法是可以保证完全没有问题的，可以加分布式锁控制回源方法（这样出问题的概率就更加低了）。当然，只有在这种大量写操作的情况下，才会使<code>问题3.1</code>出现的概率提升，一般这种大量写的还会有命中率低的问题，所以这类缓存的更新一般交给binlog消费者直接去做，在单线程处理模式下，一致性问题几乎不会出现。相比<code>问题3.1</code>里的直接delete缓存，binlog模式可以保证清缓存后缓存回源时读到的内容一定是最新的，极大的降低了因为主从配置导致的<code>问题3.1、3.2</code>出现的概率。</p><h2 id="五、命中率问题"><a href="#五、命中率问题" class="headerlink" title="五、命中率问题"></a>五、命中率问题</h2><p>通过前面的流程，抛开特殊因素，已经解决了一致性的问题，但随着清缓存而来的另一个问题就是命中率问题，比如一个数据变更过于频繁，以至于产生过多的binlog消息，这个时候每次都会触发消费者的清缓存操作，这样的话缓存的命中率会瞬间下降，导致大部分用户访问直接访问DB，而且这种频繁变更的数据还会加大问题①出现的概率，所以针对这种频繁变更的数据，不再删除缓存key，而是直接在binlog消费者那里直接回源更新缓存，这样即便表频繁变更，用户访问时每次都是消费者更新好的那份缓存数据，只是这时候消费者要严格按照消息顺序来处理，否则也会有写脏的危险，比如开两个线程同时消费binlog消息，线程1接收到了第一次数据变更的binlog，而线程2接收到了第二次数据变更的binlog，这时线程1读出数据（旧数据），线程2读出数据（新数据）更新缓存，然后线程1再执行更新，这时缓存又会被写脏，所以为了保证消费顺序，必须是单线程处理，如果想要启用多线程均摊压力，可以利用key、id等标识性字段做任务分组，这样同一个id的binlog消息始终会被同一个线程执行。</p><h2 id="六、缓存穿透"><a href="#六、缓存穿透" class="headerlink" title="六、缓存穿透"></a>六、缓存穿透</h2><h3 id="6-1：什么是缓存穿透？"><a href="#6-1：什么是缓存穿透？" class="headerlink" title="6.1：什么是缓存穿透？"></a>6.1：什么是缓存穿透？</h3><p>正常情况下用户请求一个数据时会携带标记性的参数（比如id），而我们的缓存key则会以这些标记性的参数来划分不同的cache value，然后我们根据这些参数去查缓存，查到就返回，否则回源，然后写入cache服务后返回，详细过程参考上述第三部分。</p><p>这个过程看起来也没什么问题，但是某些情况下，根据带进来的参数，在数据库里并不能找到对应的信息，这个时候每次带有这种参数的请求，都会走到数据库回源，这种现象叫做缓存穿透，比较典型的出现这种问题的情况有：</p><p>①恶意攻击或者爬虫，携带数据库里本就不存在的数据做参数回源</p><p>②公司内部别的业务方调用我方的接口时，由于沟通不当或其他原因导致的参数大量误传</p><p>③客户端bug导致的参数大量误传</p><h3 id="6-2：如何解决缓存穿透问题？"><a href="#6-2：如何解决缓存穿透问题？" class="headerlink" title="6.2：如何解决缓存穿透问题？"></a>6.2：如何解决缓存穿透问题？</h3><p>目前我们提倡的做法是回源查不到信息时直接缓存空数据（注意：空数据缓存的过期时间要尽可能小，防止无意义内容过多占用Cache内存），这样即便是有参数误传、恶意攻击等情况，也不会每次都打进DB。</p><p>但是目前这种做法仍然存在被攻击的风险，如果恶意攻击时携带少量参数还好，这样不存在的空数据缓存仅仅会占用少量内存，但是如果攻击者使用大量穿透攻击，携带的参数千奇百怪，这样就会产生大量无意义的空对象缓存，使得我们的缓存服务器内存暴增，这个时候就需要服务端来进行简单的控制：按照业务内自己的估算，合理的id大致在什么范围内，比如按照用户id做标记的缓存，就直接在获取缓存前判断所传用户id参数是否超过了某个阈值，超过直接返回空。（比如用户总量才几十万或者上百万，结果用户id传过来个几千万甚至几亿明显不合理的情况）</p><p>还可以通过<code>布隆过滤器</code>的方式存储合理的key数据，一旦发现key未命中布隆过滤器就直接返回空对象。</p><h2 id="七、缓存击穿"><a href="#七、缓存击穿" class="headerlink" title="七、缓存击穿"></a>七、缓存击穿</h2><h3 id="7-1：什么是缓存击穿？"><a href="#7-1：什么是缓存击穿？" class="headerlink" title="7.1：什么是缓存击穿？"></a>7.1：什么是缓存击穿？</h3><p>缓存击穿是指在一个key失效后，大量请求打进回源方法，多线程并发回源的问题。</p><p>这种情况在少量访问时不能算作一个问题，但是当一个热点key失效后，就会发生回源时涌进过多流量，全部打在DB上，这样会导致DB在这一时刻压力剧增。</p><h3 id="7-2：如何解决缓存击穿？"><a href="#7-2：如何解决缓存击穿？" class="headerlink" title="7.2：如何解决缓存击穿？"></a>7.2：如何解决缓存击穿？</h3><h4 id="7-2-1：回源方法内追加互斥锁"><a href="#7-2-1：回源方法内追加互斥锁" class="headerlink" title="7.2.1：回源方法内追加互斥锁"></a>7.2.1：回源方法内追加互斥锁</h4><p>这个可以避免多次回源，但是n台实例群模式下，仍然会存在实例并发回源的情况，但这个量级相比之前大量打进，已经降低不少了。</p><h4 id="7-2-2：回源方法内追加分布式锁"><a href="#7-2-2：回源方法内追加分布式锁" class="headerlink" title="7.2.2：回源方法内追加分布式锁"></a>7.2.2：回源方法内追加分布式锁</h4><p>这个可以完全避免上面多实例下并发回源的情况，但是缺点也很明显，那就是又引入了一个新的服务，这意味着系统复杂度和发生异常的风险会加大。</p><h2 id="八、缓存雪崩"><a href="#八、缓存雪崩" class="headerlink" title="八、缓存雪崩"></a>八、缓存雪崩</h2><h3 id="8-1：什么是缓存雪崩？"><a href="#8-1：什么是缓存雪崩？" class="headerlink" title="8.1：什么是缓存雪崩？"></a>8.1：什么是缓存雪崩？</h3><p>缓存雪崩是指缓存数据某一时刻出现大量失效的情况，所有请求全部打进DB，导致短期内DB负载暴增的问题，一般来说造成缓存雪崩有以下几种情况：</p><h4 id="8-1-1：缓存服务扩缩容"><a href="#8-1-1：缓存服务扩缩容" class="headerlink" title="8.1.1：缓存服务扩缩容"></a>8.1.1：缓存服务扩缩容</h4><p>这个是由缓存的数据分片策略的而导致的，如果采用简单的取模运算进行数据分片，那么服务端扩缩容就会导致雪崩的发生。</p><h4 id="8-1-2：缓存服务宕机"><a href="#8-1-2：缓存服务宕机" class="headerlink" title="8.1.2：缓存服务宕机"></a>8.1.2：缓存服务宕机</h4><p>某一时刻缓存服务器出现大量宕机的情况，导致缓存服务不可用，根据现有的实现，是直接打到DB上的。</p><h3 id="8-2：如何避免雪崩的发生？"><a href="#8-2：如何避免雪崩的发生？" class="headerlink" title="8.2：如何避免雪崩的发生？"></a>8.2：如何避免雪崩的发生？</h3><h4 id="8-2-1：缓存服务端的高可用配置"><a href="#8-2-1：缓存服务端的高可用配置" class="headerlink" title="8.2.1：缓存服务端的高可用配置"></a>8.2.1：缓存服务端的高可用配置</h4><p>上面mc和redis的分片策略已经说过，所以扩缩容带来的雪崩几率很小，其次redis服务实现了高可用配置：启用cluster模式，一主一从配置。由于对一致性哈希算法的优化，mc宕机、扩缩容对整体影响不大，所以缓存服务器服务端本身目前是可以保证良好的可用性的，尽可能的避免了雪崩的发生（除非大规模宕机，概率很小）。</p><h4 id="8-2-2：数据分片策略调整"><a href="#8-2-2：数据分片策略调整" class="headerlink" title="8.2.2：数据分片策略调整"></a>8.2.2：数据分片策略调整</h4><p>调整缓存服务器的分片策略，比如上面第一部分所讲的，给mc开启一致性哈希算法的分片策略，防止缓存服务端扩缩容后缓存数据大量不可用。</p><h4 id="8-2-3：回源限流"><a href="#8-2-3：回源限流" class="headerlink" title="8.2.3：回源限流"></a>8.2.3：回源限流</h4><p>如果缓存服务真的挂掉了，请求全打在DB上，以至于超出了DB所能承受之重，这个时候建议回源时进行整体限流，被限到的请求紫自动走降级逻辑。</p><h2 id="九、热key问题"><a href="#九、热key问题" class="headerlink" title="九、热key问题"></a>九、热key问题</h2><h3 id="9-1：什么是热key问题？"><a href="#9-1：什么是热key问题？" class="headerlink" title="9.1：什么是热key问题？"></a>9.1：什么是热key问题？</h3><p>了解了缓存服务端的实现，可以知道某一个确定的key始终会落到某一台服务器上，如果某个key在生产环境被大量访问，就导致了某个缓存服务节点流量暴增，等访问超出单节点负载，就可能会出现单点故障，单点故障后转移该key的数据到其他节点，单点问题依旧存在，则可能继续会让被转移到的节点也出现故障，最终影响整个缓存服务集群。</p><h3 id="9-2：如何解决热key问题？"><a href="#9-2：如何解决热key问题？" class="headerlink" title="9.2：如何解决热key问题？"></a>9.2：如何解决热key问题？</h3><h4 id="9-2-1：多缓存副本"><a href="#9-2-1：多缓存副本" class="headerlink" title="9.2.1：多缓存副本"></a>9.2.1：多缓存副本</h4><p>预先感知到发生热点访问的key，生成多个副本key，这样可以保证热点key会被多个缓存服务器持有，然后回源方法公用一个，请求时按照一定的算法（哈希取模or随机）访问某个副本key：</p><p><img src="http://myblog.sharemer.com/2019/10/24/20191024-1-12.png?imageView2/0/w/600" alt="图12"></p><h4 id="9-2-2：本地缓存"><a href="#9-2-2：本地缓存" class="headerlink" title="9.2.2：本地缓存"></a>9.2.2：本地缓存</h4><p>针对热点key外面包一层短存活期的本地缓存，用于缓冲热点服务器的压力。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;目前工作中用到的分布式缓存技术有&lt;code&gt;redis&lt;/code&gt;和&lt;code&gt;memcached&lt;/code&gt;两种，缓存的目的是为了在高并发系统中有效降低DB的压力，但是在使用的时候可能会因为缓存结构设计不当造成一些问题，这里会把可能遇到的坑整理出来，方便日后查找。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="缓存设计" scheme="http://example.com/categories/%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
    <category term="缓存设计" scheme="http://example.com/tags/%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="Memcached" scheme="http://example.com/tags/Memcached/"/>
    
  </entry>
  
</feed>
